// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

var LogLevels;
(function(LogLevels1) {
    LogLevels1[LogLevels1["NOTSET"] = 0] = "NOTSET";
    LogLevels1[LogLevels1["DEBUG"] = 10] = "DEBUG";
    LogLevels1[LogLevels1["INFO"] = 20] = "INFO";
    LogLevels1[LogLevels1["WARNING"] = 30] = "WARNING";
    LogLevels1[LogLevels1["ERROR"] = 40] = "ERROR";
    LogLevels1[LogLevels1["CRITICAL"] = 50] = "CRITICAL";
})(LogLevels || (LogLevels = {}));
Object.keys(LogLevels).filter((key1)=>isNaN(Number(key1)));
const byLevel = {
    [String(LogLevels.NOTSET)]: "NOTSET",
    [String(LogLevels.DEBUG)]: "DEBUG",
    [String(LogLevels.INFO)]: "INFO",
    [String(LogLevels.WARNING)]: "WARNING",
    [String(LogLevels.ERROR)]: "ERROR",
    [String(LogLevels.CRITICAL)]: "CRITICAL"
};
function getLevelByName(name) {
    switch(name){
        case "NOTSET":
            return LogLevels.NOTSET;
        case "DEBUG":
            return LogLevels.DEBUG;
        case "INFO":
            return LogLevels.INFO;
        case "WARNING":
            return LogLevels.WARNING;
        case "ERROR":
            return LogLevels.ERROR;
        case "CRITICAL":
            return LogLevels.CRITICAL;
        default:
            throw new Error(`no log level found for "${name}"`);
    }
}
function getLevelName(level) {
    const levelName = byLevel[level];
    if (levelName) {
        return levelName;
    }
    throw new Error(`no level name found for level: ${level}`);
}
class LogRecord {
    msg;
    #args;
    #datetime;
    level;
    levelName;
    loggerName;
    constructor(options){
        this.msg = options.msg;
        this.#args = [
            ...options.args
        ];
        this.level = options.level;
        this.loggerName = options.loggerName;
        this.#datetime = new Date();
        this.levelName = getLevelName(options.level);
    }
    get args() {
        return [
            ...this.#args
        ];
    }
    get datetime() {
        return new Date(this.#datetime.getTime());
    }
}
class Logger {
    #level;
    #handlers;
    #loggerName;
    constructor(loggerName, levelName, options = {}){
        this.#loggerName = loggerName;
        this.#level = getLevelByName(levelName);
        this.#handlers = options.handlers || [];
    }
    get level() {
        return this.#level;
    }
    set level(level) {
        this.#level = level;
    }
    get levelName() {
        return getLevelName(this.#level);
    }
    set levelName(levelName) {
        this.#level = getLevelByName(levelName);
    }
    get loggerName() {
        return this.#loggerName;
    }
    set handlers(hndls) {
        this.#handlers = hndls;
    }
    get handlers() {
        return this.#handlers;
    }
     #_log(level, msg, ...args1) {
        if (this.level > level) {
            return msg instanceof Function ? undefined : msg;
        }
        let fnResult;
        let logMessage;
        if (msg instanceof Function) {
            fnResult = msg();
            logMessage = this.asString(fnResult);
        } else {
            logMessage = this.asString(msg);
        }
        const record = new LogRecord({
            msg: logMessage,
            args: args1,
            level: level,
            loggerName: this.loggerName
        });
        this.#handlers.forEach((handler)=>{
            handler.handle(record);
        });
        return msg instanceof Function ? fnResult : msg;
    }
    asString(data) {
        if (typeof data === "string") {
            return data;
        } else if (data === null || typeof data === "number" || typeof data === "bigint" || typeof data === "boolean" || typeof data === "undefined" || typeof data === "symbol") {
            return String(data);
        } else if (data instanceof Error) {
            return data.stack;
        } else if (typeof data === "object") {
            return JSON.stringify(data);
        }
        return "undefined";
    }
    debug(msg1, ...args1) {
        return this.#_log(LogLevels.DEBUG, msg1, ...args1);
    }
    info(msg2, ...args2) {
        return this.#_log(LogLevels.INFO, msg2, ...args2);
    }
    warning(msg3, ...args3) {
        return this.#_log(LogLevels.WARNING, msg3, ...args3);
    }
    error(msg4, ...args4) {
        return this.#_log(LogLevels.ERROR, msg4, ...args4);
    }
    critical(msg5, ...args5) {
        return this.#_log(LogLevels.CRITICAL, msg5, ...args5);
    }
}
const { Deno: Deno2  } = globalThis;
const noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str1, code1) {
    return enabled ? `${code1.open}${str1.replace(code1.regexp, code1.open)}${code1.close}` : str1;
}
function bold(str2) {
    return run(str2, code([
        1
    ], 22));
}
function red(str3) {
    return run(str3, code([
        31
    ], 39));
}
function yellow(str4) {
    return run(str4, code([
        33
    ], 39));
}
function blue(str5) {
    return run(str5, code([
        34
    ], 39));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
async function exists(filePath) {
    try {
        await Deno.lstat(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function existsSync(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg6 = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg6);
    }
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r1, size = 4096) {
        return r1 instanceof BufReader ? r1 : new BufReader(r1, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i1 = 100; i1 > 0; i1--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r2) {
        this.#reset(this.#buf, r2);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p1) {
        let rr = p1.byteLength;
        if (p1.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p1.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p1);
                const nread = rr ?? 0;
                assert(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p1, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p2) {
        let bytesRead = 0;
        while(bytesRead < p2.length){
            try {
                const rr = await this.read(p2.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p2.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e1 = new PartialReadError();
                    e1.partial = p2.subarray(0, bytesRead);
                    e1.stack = err.stack;
                    e1.message = err.message;
                    e1.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p2;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c1 = this.#buf[this.#r];
        this.#r++;
        return c1;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s1 = 0;
        let slice;
        while(true){
            let i2 = this.#buf.subarray(this.#r + s1, this.#w).indexOf(delim);
            if (i2 >= 0) {
                i2 += s1;
                slice = this.#buf.subarray(this.#r, this.#r + i2 + 1);
                this.#r += i2 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s1 = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e2 = new PartialReadError();
                    e2.partial = slice;
                    e2.stack = err.stack;
                    e2.message = err.message;
                    e2.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e3 = new PartialReadError();
                    e3.partial = this.#buf.subarray(this.#r, this.#w);
                    e3.stack = err.stack;
                    e3.message = err.message;
                    e3.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w1) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w1;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p3 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p3.length){
                nwritten += await this.#writer.write(p3.subarray(nwritten));
            }
        } catch (e4) {
            if (e4 instanceof Error) {
                this.err = e4;
            }
            throw e4;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e5) {
                    if (e5 instanceof Error) {
                        this.err = e5;
                    }
                    throw e5;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w2) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w2;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p4 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p4.length){
                nwritten += this.#writer.writeSync(p4.subarray(nwritten));
            }
        } catch (e6) {
            if (e6 instanceof Error) {
                this.err = e6;
            }
            throw e6;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e7) {
                    if (e7 instanceof Error) {
                        this.err = e7;
                    }
                    throw e7;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const DEFAULT_FORMATTER = "{levelName} {msg}";
class BaseHandler {
    level;
    levelName;
    formatter;
    constructor(levelName, options = {}){
        this.level = getLevelByName(levelName);
        this.levelName = levelName;
        this.formatter = options.formatter || DEFAULT_FORMATTER;
    }
    handle(logRecord) {
        if (this.level > logRecord.level) return;
        const msg7 = this.format(logRecord);
        return this.log(msg7);
    }
    format(logRecord) {
        if (this.formatter instanceof Function) {
            return this.formatter(logRecord);
        }
        return this.formatter.replace(/{([^\s}]+)}/g, (match, p1)=>{
            const value1 = logRecord[p1];
            if (value1 == null) {
                return match;
            }
            return String(value1);
        });
    }
    log(_msg) {}
    async setup() {}
    async destroy() {}
}
class ConsoleHandler extends BaseHandler {
    format(logRecord) {
        let msg8 = super.format(logRecord);
        switch(logRecord.level){
            case LogLevels.INFO:
                msg8 = blue(msg8);
                break;
            case LogLevels.WARNING:
                msg8 = yellow(msg8);
                break;
            case LogLevels.ERROR:
                msg8 = red(msg8);
                break;
            case LogLevels.CRITICAL:
                msg8 = bold(red(msg8));
                break;
            default:
                break;
        }
        return msg8;
    }
    log(msg9) {
        console.log(msg9);
    }
}
class WriterHandler extends BaseHandler {
    _writer;
    #encoder = new TextEncoder();
}
class FileHandler extends WriterHandler {
    _file;
    _buf;
    _filename;
    _mode;
    _openOptions;
    _encoder = new TextEncoder();
    #unloadCallback = (()=>{
        this.destroy();
    }).bind(this);
    constructor(levelName, options){
        super(levelName, options);
        this._filename = options.filename;
        this._mode = options.mode ? options.mode : "a";
        this._openOptions = {
            createNew: this._mode === "x",
            create: this._mode !== "x",
            append: this._mode === "a",
            truncate: this._mode !== "a",
            write: true
        };
    }
    async setup() {
        this._file = await Deno.open(this._filename, this._openOptions);
        this._writer = this._file;
        this._buf = new BufWriterSync(this._file);
        addEventListener("unload", this.#unloadCallback);
    }
    handle(logRecord) {
        super.handle(logRecord);
        if (logRecord.level > LogLevels.ERROR) {
            this.flush();
        }
    }
    log(msg10) {
        if (this._encoder.encode(msg10).byteLength + 1 > this._buf.available()) {
            this.flush();
        }
        this._buf.writeSync(this._encoder.encode(msg10 + "\n"));
    }
    flush() {
        if (this._buf?.buffered() > 0) {
            this._buf.flush();
        }
    }
    destroy() {
        this.flush();
        this._file?.close();
        this._file = undefined;
        removeEventListener("unload", this.#unloadCallback);
        return Promise.resolve();
    }
}
class RotatingFileHandler extends FileHandler {
    #maxBytes;
    #maxBackupCount;
    #currentFileSize = 0;
    constructor(levelName, options){
        super(levelName, options);
        this.#maxBytes = options.maxBytes;
        this.#maxBackupCount = options.maxBackupCount;
    }
    async setup() {
        if (this.#maxBytes < 1) {
            this.destroy();
            throw new Error("maxBytes cannot be less than 1");
        }
        if (this.#maxBackupCount < 1) {
            this.destroy();
            throw new Error("maxBackupCount cannot be less than 1");
        }
        await super.setup();
        if (this._mode === "w") {
            for(let i3 = 1; i3 <= this.#maxBackupCount; i3++){
                if (await exists(this._filename + "." + i3)) {
                    await Deno.remove(this._filename + "." + i3);
                }
            }
        } else if (this._mode === "x") {
            for(let i4 = 1; i4 <= this.#maxBackupCount; i4++){
                if (await exists(this._filename + "." + i4)) {
                    this.destroy();
                    throw new Deno.errors.AlreadyExists("Backup log file " + this._filename + "." + i4 + " already exists");
                }
            }
        } else {
            this.#currentFileSize = (await Deno.stat(this._filename)).size;
        }
    }
    log(msg11) {
        const msgByteLength = this._encoder.encode(msg11).byteLength + 1;
        if (this.#currentFileSize + msgByteLength > this.#maxBytes) {
            this.rotateLogFiles();
            this.#currentFileSize = 0;
        }
        super.log(msg11);
        this.#currentFileSize += msgByteLength;
    }
    rotateLogFiles() {
        this._buf.flush();
        Deno.close(this._file.rid);
        for(let i5 = this.#maxBackupCount - 1; i5 >= 0; i5--){
            const source = this._filename + (i5 === 0 ? "" : "." + i5);
            const dest = this._filename + "." + (i5 + 1);
            if (existsSync(source)) {
                Deno.renameSync(source, dest);
            }
        }
        this._file = Deno.openSync(this._filename, this._openOptions);
        this._writer = this._file;
        this._buf = new BufWriterSync(this._file);
    }
}
class LoggerConfig {
    level;
    handlers;
}
const DEFAULT_LEVEL = "INFO";
const DEFAULT_CONFIG = {
    handlers: {
        default: new ConsoleHandler(DEFAULT_LEVEL)
    },
    loggers: {
        default: {
            level: DEFAULT_LEVEL,
            handlers: [
                "default"
            ]
        }
    }
};
const state = {
    handlers: new Map(),
    loggers: new Map(),
    config: DEFAULT_CONFIG
};
const handlers = {
    BaseHandler,
    ConsoleHandler,
    WriterHandler,
    FileHandler,
    RotatingFileHandler
};
function getLogger(name) {
    if (!name) {
        const d1 = state.loggers.get("default");
        assert(d1 != null, `"default" logger must be set for getting logger without name`);
        return d1;
    }
    const result = state.loggers.get(name);
    if (!result) {
        const logger = new Logger(name, "NOTSET", {
            handlers: []
        });
        state.loggers.set(name, logger);
        return logger;
    }
    return result;
}
function debug(msg12, ...args6) {
    if (msg12 instanceof Function) {
        return getLogger("default").debug(msg12, ...args6);
    }
    return getLogger("default").debug(msg12, ...args6);
}
function info(msg13, ...args7) {
    if (msg13 instanceof Function) {
        return getLogger("default").info(msg13, ...args7);
    }
    return getLogger("default").info(msg13, ...args7);
}
function warning(msg14, ...args8) {
    if (msg14 instanceof Function) {
        return getLogger("default").warning(msg14, ...args8);
    }
    return getLogger("default").warning(msg14, ...args8);
}
function error(msg15, ...args9) {
    if (msg15 instanceof Function) {
        return getLogger("default").error(msg15, ...args9);
    }
    return getLogger("default").error(msg15, ...args9);
}
function critical(msg16, ...args10) {
    if (msg16 instanceof Function) {
        return getLogger("default").critical(msg16, ...args10);
    }
    return getLogger("default").critical(msg16, ...args10);
}
async function setup(config) {
    state.config = {
        handlers: {
            ...DEFAULT_CONFIG.handlers,
            ...config.handlers
        },
        loggers: {
            ...DEFAULT_CONFIG.loggers,
            ...config.loggers
        }
    };
    state.handlers.forEach((handler)=>{
        handler.destroy();
    });
    state.handlers.clear();
    const handlers1 = state.config.handlers || {};
    for(const handlerName1 in handlers1){
        const handler = handlers1[handlerName1];
        await handler.setup();
        state.handlers.set(handlerName1, handler);
    }
    state.loggers.clear();
    const loggers = state.config.loggers || {};
    for(const loggerName in loggers){
        const loggerConfig = loggers[loggerName];
        const handlerNames = loggerConfig.handlers || [];
        const handlers2 = [];
        handlerNames.forEach((handlerName)=>{
            const handler = state.handlers.get(handlerName);
            if (handler) {
                handlers2.push(handler);
            }
        });
        const levelName = loggerConfig.level || DEFAULT_LEVEL;
        const logger = new Logger(loggerName, levelName, {
            handlers: handlers2
        });
        state.loggers.set(loggerName, logger);
    }
}
await setup(DEFAULT_CONFIG);
const mod = await async function() {
    return {
        LogLevels: LogLevels,
        Logger: Logger,
        LoggerConfig: LoggerConfig,
        handlers: handlers,
        getLogger: getLogger,
        debug: debug,
        info: info,
        warning: warning,
        error: error,
        critical: critical,
        setup: setup
    };
}();
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0;
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code2 = arg.charCodeAt(offset);
        if (code2 > 0x7F) break;
        mem[ptr + offset] = code2;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x1) {
    return x1 === undefined || x1 === null;
}
let cachedInt32Memory0;
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_3e250b41a8915757: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_facf0398a281c85b: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_a7ce447f15ff496f: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fw\
F/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRj\
ZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAh\
hfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3\
AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNW\
RmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1\
YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbm\
d0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0\
aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbW\
Vtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5\
NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAA\
MYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193\
YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPrgICAAGoJBwkHBxEFBwcFAw\
cHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBwcIFw0FBQkICA0HCQUJCQYGBQUFBQUFBwcHBwcABQII\
CgcHAgUDDgwLDAsLEhMJBQgIAwYGAgUAAAYDBgAABQUEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiY\
CAgAABfwFBgIDAAAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA1GF9fd2JnX2RpZ2VzdGNvbnRleHRf\
ZnJlZQBQEWRpZ2VzdGNvbnRleHRfbmV3ADwUZGlnZXN0Y29udGV4dF91cGRhdGUAVBRkaWdlc3Rjb2\
50ZXh0X2RpZ2VzdAA9HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAPxtkaWdlc3Rjb250ZXh0\
X2RpZ2VzdEFuZERyb3AAOBNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQ\
AaH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbBFfX3diaW5kZ2VuX21hbGxvYwBXEl9f\
d2JpbmRnZW5fcmVhbGxvYwBiD19fd2JpbmRnZW5fZnJlZQBoCZqAgIAAAQBBAQsUZWZtdGtZO1pbWG\
NgXF1eX3VBQnIK0smIgABqoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGB\
cWFRQTEhEQDw4NDAsKAAsgASgCBCEBQdABEBYiBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJq\
QTBqIAFBMGopAwA3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkB\
JqQRhqIAFBGGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQg\
ASkDADcDkBIgASkDQCEWIARBkBJqQcgAaiABQcgAahBDIAQgFjcD0BIgBSAEQZASakHQARA5GkEAIQ\
ZBACEBDB8LIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBq\
KQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQR\
hqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5AS\
IAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBASEBDBsLIAEoAg\
QhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJq\
QShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkB\
JqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZAS\
akHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBAiEBDBoLIAEoAgQhAUHwABAWIgVFDQ\
QgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3\
AwAgBCABKQMINwOYEiABKQMAIRYgBEGQEmpBKGogAUEoahA3IAQgFjcDkBIgBSAEQZASakHwABA5Gk\
EDIQEMGQsgASgCBCEBQfgOEBYiBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFB\
gAFqKQMANwMAIARBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQR\
hqIAFBGGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJq\
QThqIAFBOGopAwA3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDAC\
AEQZASakHQAGogAUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAA\
aikDADcDACAEIAEpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAG\
khCCABLQBoIQkCQCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARB\
EGoiDCAGQRBqKQAANwMAIARBCGoiDSAGQQhqKQAANwMAIAQgBikAADcDACABQdQBaiEGQQAgCkFgak\
EFdmshDiAEQcQTaiEBQQIhCgNAIAFBYGoiDyAEKQMANwAAIA9BGGogCykDADcAACAPQRBqIAwpAwA3\
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\
ASAEQZASaiABQcgBEDkaIARBkBJqQcgBaiABQcgBahBIIAUgBEGQEmpB4AIQORpBBSEBC0EAIQYMAg\
tB4AJBCEEAKAL41EAiBEEEIAQbEQUAAAsgBCAKNgKgEyAEIAc6APoSIAQgCDoA+RIgBCAJOgD4EiAE\
IBY3A5ASIAUgBEGQEmpB+A4QORpBBCEBQQEhBgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAC\
DgIBABELQSAhAiABDhgBDwIPEAMPBAUGBgcHCA8JCgsPDA0QEA4BCyABQQJ0QZTUwABqKAIAIQMMDw\
tBwAAhAgwNC0EwIQIMDAtBHCECDAsLQTAhAgwKC0HAACECDAkLQRAhAgwIC0EUIQIMBwtBHCECDAYL\
QTAhAgwFC0HAACECDAQLQRwhAgwDC0EwIQIMAgtBwAAhAgwBC0EYIQILIAIgA0YNACAAQa2BwAA2Ag\
QgAEEBNgIAIABBCGpBOTYCAAJAIAZFDQAgBSgCkAFFDQAgBUEANgKQAQsgBRAeDAELAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4YAAECAwQFBg\
cICQoLDA0ODxAREhMUFRYaAAsgBCAFQdABEDkiAUH4DmpBDGpCADcCACABQfgOakEUakIANwIAIAFB\
+A5qQRxqQgA3AgAgAUH4DmpBJGpCADcCACABQfgOakEsakIANwIAIAFB+A5qQTRqQgA3AgAgAUH4Dm\
pBPGpCADcCACABQgA3AvwOIAFBwAA2AvgOIAFBkBJqIAFB+A5qQcQAEDkaIAFBuCJqQThqIgogAUGQ\
EmpBPGopAgA3AwAgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQ\
IANwMAIAFBuCJqQSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACAB\
QbgiakEQaiINIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEj\
cDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFG\
DQAgAiAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAJCfxARIAFB+A5qQQhqIgYgAUGQEmpBCG\
opAwA3AwAgAUH4DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMA\
IAFB+A5qQSBqIgcgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIA\
FBkBJqQTBqKQMANwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMA\
NwMAIA0gAikDADcDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQ\
MANwMAIAEgASkD+A43A7giQcAAEBYiBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAg\
BkEwaiABQbgiakEwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AA\
AgBkEYaiABQbgiakEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3\
AABBwAAhAwwaCyAEIAVB0AEQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCAD\
cCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwg\
AUH4DmpBEGoiCikDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4Dm\
pBIGoiECgCADYCACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhq\
IgcgAUGQEmpBDGopAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZ\
ASaiABQdABEDkaIAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZq\
QQBBgAEgBmsQOhoLIAFBADoA2BMgAUGQEmogD0J/EBEgAyANKQMANwMAIAogDCkDADcDACACIAspAw\
A3AwAgECABKQOwEjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikD\
ADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANw\
MAIAggAikDADcDACABIAEpA/gONwO4IkEgEBYiBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGop\
AwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0A\
EQOSIBQfgOakEsakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIA\
IAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDAC\
ABQZASakEgaiABQfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZAS\
akEQaiIOIAFB+A5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQT\
BqIgggAUH4DmpBMGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMA\
IAFBuCJqQRhqIhIgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiak\
EIaiIUIAFBkBJqQQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIg\
AUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDC\
AGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAxCfxARIAsgBykDADcDACAPIA4pAwA3AwAgAyAQ\
KQMANwMAIAogASkDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDAD\
cDACABIAEpA5ASNwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSAC\
KQMANwMAIAEgASkD+A43A7giQTAQFiIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAAC\
AGQSBqIAFBuCJqQSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcA\
ACAGQQhqIAFBuCJqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOSIBQfgOakEcakIANwIAIAFB+A5qQR\
RqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikD\
ADcDACABQZASakEQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAU\
GQEmpBIGoiCyABQfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIA\
NwMAIAFB6CNqQQhqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIA\
EpApQSNwPoIyABQZASaiABQfAAEDkaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAg\
BkHAAEYNACACIAZqQQBBwAAgBmsQOhoLIAFBADoA+BIgAUGQEmogAkF/EBMgDyADKQMAIhY3AwAgDS\
AWNwMAIAwgCikDADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFiIGRQ0cIAYg\
ASkD6CM3AAAgBkEYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2\
pBCGopAwA3AABBICEDDBcLIAQgBUH4DhA5IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFiIGRQ0d\
IAZBfGotAABBA3FFDQAgBkEAIAMQOhoLIAFBkBJqIAFB+A4QORogAUH4DmogAUGQEmoQIyABQfgOai\
AGIAMQGAwWCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAg\
AUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOg\
AAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAg\
AUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkA\
FHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBq\
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\
KQKUEjcD6CMgAUGQEmogAUHgABA5GiABQZASaiABQagSaiABQegjahAuQRAQFiIGRQ0cIAYgASkD6C\
M3AAAgBkEIaiACKQMANwAADBALQRQhAyAEIAVB6AAQOSIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3\
AgAgAUEANgL4DiABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCG\
ogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJq\
QRRqKAIANgIAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQORogAUGQEmogAUGwEm\
ogAUHoI2oQLUEUEBYiBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtB\
FCEDIAQgBUHoABA5IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAU\
EUNgL4DiABQZASakEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegj\
akEIaiICIAFBkBJqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkB\
IgASABKQKUEjcD6CMgAUGQEmogAUHoABA5GiABQZASaiABQbASaiABQegjahAoQRQQFiIGRQ0cIAYg\
ASkD6CM3AAAgBkEQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOSIKQZASaiAKQeACED\
kaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6\
AOgUIAJBBjoAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAcz\
oAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oi\
AiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASak\
EYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3\
AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAi\
kDADcAACAGQQhqIA8pAwA3AAAMDQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0A\
ACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFG\
oiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAg\
AUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAH\
M6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpB\
EGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQS\
AhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMA\
NwAADAwLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQe\
gARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAAD\
QCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQ\
JqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcN\
AAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAw\
A3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB\
+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AA\
AgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGog\
DCkDADcAAAwLCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAk\
AgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFy\
OgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AA\
AgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB\
yABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQT\
BqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcD\
ACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4Dm\
pBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAA\
IAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIA\
wpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOSIBQZASaiABQfAAEDka\
QRwhAyABQegjakEcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBID\
YC6CMgAUH4DmpBGGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB\
+A5qQQhqIg8gAUHoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A\
4gAUG4ImpBEGoiBiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJq\
QRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQJyACIAwoAg\
A2AgAgCiAGKQMANwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBYiBkUNHCAGIAEpA/gONwAAIAZB\
GGogAigCADYAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA5IgFBkBJqIAFB8A\
AQORogAUHoI2pBHGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMg\
AUEgNgLoIyABQfgOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIA\
FB+A5qQRBqIgogAUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gj\
NwP4DiABQbgiakEYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAU\
G4ImpBCGoiDCABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAnIAIg\
BikDADcDACAKIAspAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFiIGRQ0cIAYgASkD+A43AA\
AgBkEYaiACKQMANwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDkiAUGQEmog\
AUHYARA5GiABQegjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkak\
IANwIAIAFB6CNqQSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHA\
ADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIA\
FB+A5qQTRqKQIANwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEk\
aikCADcDACABQbgiakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3Aw\
AgAUG4ImpBCGoiCyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAi\
IAFB+A5qQShqIgwgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIA\
FB+A5qQRBqIgogDykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAWIgZFDRwg\
BiABKQP4DjcAACAGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAw\
A3AAAgBkEIaiAPKQMANwAADAcLIAQgBUHYARA5IgFBkBJqIAFB2AEQORogAUHoI2pBDGpCADcCACAB\
QegjakEUakIANwIAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6C\
NqQTRqQgA3AgAgAUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pB\
xAAQORogAUG4ImpBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIA\
FBuCJqQShqIgogAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiDyABQfgOakEkaikCADcDACABQbgiakEY\
aiILIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgwgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDSABQf\
gOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAiIAFB+A5qQThqIhAgBikD\
ADcDACABQfgOakEwaiIOIAIpAwA3AwAgAUH4DmpBKGoiAiAKKQMANwMAIAFB+A5qQSBqIgogDykDAD\
cDACABQfgOakEYaiIPIAspAwA3AwAgAUH4DmpBEGoiCyAMKQMANwMAIAFB+A5qQQhqIgwgDSkDADcD\
ACABIAEpA7giNwP4DkHAABAWIgZFDRwgBiABKQP4DjcAACAGQThqIBApAwA3AAAgBkEwaiAOKQMANw\
AAIAZBKGogAikDADcAACAGQSBqIAopAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhq\
IAwpAwA3AAAMBgsgBEH4DmogBUH4AhA5GiADQQBIDQECQAJAIAMNAEEBIQYMAQsgAxAWIgZFDR0gBk\
F8ai0AAEEDcUUNACAGQQAgAxA6GgsgBEGQEmogBEH4DmpB+AIQORogBCAEQfgOakHIARA5Ig9ByAFq\
IA9BkBJqQcgBakGpARA5IQEgD0HoI2ogD0H4DmpByAEQORogD0GIIWogAUGpARA5GiAPQYghaiAPLQ\
CwIiIBaiEKAkAgAUGoAUYNACAKQQBBqAEgAWsQOhoLQQAhAiAPQQA6ALAiIApBHzoAACAPQa8iaiIB\
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\
BjcDKCAAIAc3AyAgACAINwMYIAAgCTcDECAAIAo3AwggACALNwMAIANBgAFqJAAL+FsCDH8FfiMAQY\
AGayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOAgABAgsgASgC\
ACICQQJ0QbTTwABqKAIAIQMMEQtBICEFIAEoAgAiAg4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQ\
sgASgCACECDA8LQcAAIQUMDQtBMCEFDAwLQRwhBQwLC0EwIQUMCgtBwAAhBQwJC0EQIQUMCAtBFCEF\
DAcLQRwhBQwGC0EwIQUMBQtBwAAhBQwEC0EcIQUMAwtBMCEFDAILQcAAIQUMAQtBGCEFCyAFIANGDQ\
BBASEBQTkhA0GtgcAAIQIMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkAgAg4YAAECAwQFBgcICQoLDA0ODxAREhMUFRYaAAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQ\
BGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEak\
E0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARB\
oANqQThqIgYgBEEoakE8aikCADcDACAEQaADakEwaiIHIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiCC\
AEQShqQSxqKQIANwMAIARBoANqQSBqIgkgBEEoakEkaikCADcDACAEQaADakEYaiIKIARBKGpBHGop\
AgA3AwAgBEGgA2pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIA\
QpAiw3A6ADIAIgAikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBB\
gAEgAWsQOhoLQQAhASADQQA6AAAgAiAFQn8QESAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEG\
ogAkEQaikDACIRNwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpB\
KGogAkEoaikDACIUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQ\
MANwMAIAYgAkE4aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQTyACIAVByAAQORogA0EA\
OgAAQcAAEBYiAkUNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwai\
kDADcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEY\
aikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKA\
IEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2\
AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoak\
EIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARB\
oANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDC\
AEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYC\
QCABQYABRg0AIAYgAWpBAEGAASABaxA6GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNw\
MAIAggAkEQaikDACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3\
AwAgCyAQNwMAIAogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQTyACIANByAAQOR\
ogBUEAOgAAQSAQFiICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANq\
QRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIA\
RB0ARqQSRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIA\
NwLUBCAEQTA2AtAEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAw\
A3AwAgBEEoakEYaiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShq\
QQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoA\
NqQSBqIgsgBEEoakEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAE\
QShqQRRqKQIANwMAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAg\
A3AwAgBCAEKQIsNwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAg\
BiABakEAQYABIAFrEDoaC0EAIQEgBUEAOgAAIAIgBkJ/EBEgAyACQQhqKQMAIhA3AwAgCiACQRBqKQ\
MAIhE3AwAgCSACQRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0g\
ETcDACAMIBI3AwAgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBPIAIgA0HIAB\
A5GiAFQQA6AABBMBAWIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGg\
A2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBE\
GgA2pBCGopAwA3AABBMCEDDDALIAEoAgQhAiAEQdAEakEcakIANwIAIARB0ARqQRRqQgA3AgAgBEHQ\
BGpBDGpCADcCACAEQgA3AtQEIARBIDYC0AQgBEEoakEYaiIHIARB0ARqQRhqKQMANwMAIARBKGpBEG\
oiCCAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEgaiIJIARB0ARq\
QSBqKAIANgIAIAQgBCkD0AQ3AyggBEGgA2pBEGoiCiAEQShqQRRqKQIANwMAIARBoANqQQhqIgsgBE\
EoakEMaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBCAEKQIsNwOgAyACIAIpAwAgAkHo\
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\
ECQgBEEoakE4aiIGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKG\
opAAA3AwAgBEEoakEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiIL\
IAVBEGopAAA3AwAgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQOkGQAm\
pBADoAAEHAACEDQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACAC\
QShqIAgpAwA3AAAgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQ\
MANwAADCoLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAE\
QdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCAD\
cDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC9BACEBIAJB2ABqQQA6AAAgAkEQ\
akL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoAM3AAAgAk\
EIaiAFKQMANwAADCkLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEo\
akEQaiAEQdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoak\
EMaikCADcDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC5BACEBIAJB2ABqQQA6\
AAAgAkEQakL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoA\
M3AAAgAkEIaiAFKQMANwAADCgLIAEoAgQhAkEUIQNBACEBIARB0ARqQRRqQQA2AgAgBEHQBGpBDGpC\
ADcCACAEQgA3AtQEIARBFDYC0AQgBEEoakEQaiAEQdAEakEQaikDADcDACAEQShqQQhqIARB0ARqQQ\
hqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEQaADakEQaiIGIARBKGpBFGooAgA2AgAg\
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\
BEEoakEUaikCADcDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBE\
GgA2oQJyAFIAEpAwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEg\
AkHoAGpBADoAACACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQ\
ApA4iOQDcDAEEgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhq\
IAcpAwA3AAAMIAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANw\
IAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAg\
BEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIARBKGpBPGopAgA3AwBBMC\
EDIARBoANqQTBqIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBq\
IgUgBEEoakEkaikCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQR\
RqKQIANwMAIARBoANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQ\
IiAEQShqQShqIgkgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQS\
hqQRBqIgYgBykDADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIA\
NwNAQQAhASACQThqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQ\
ApA5CPQDcDACACQRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQAp\
A/COQDcDACACQdABakEAOgAAQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQ\
MANwAAIAJBGGogBSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAE\
akEMakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQS\
xqQgA3AgAgBEHQBGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAE\
QShqIARB0ARqQcQAEDkaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNG\
opAgA3AwAgBEGgA2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAE\
QaADakEYaiIIIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIg\
ogBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQThqIgsgASkDADcD\
ACAEQShqQTBqIgwgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQS\
hqQRhqIgcgCCkDADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6AD\
NwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQS\
hqQQApA9iOQDcDACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACAC\
QQhqQQApA7iOQDcDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBYiAkUNGiACIAQpAyg3AAAgAk\
E4aiALKQMANwAAIAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykD\
ADcAACACQRBqIAgpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQ\
IMAQsgAxAWIgJFDRsgAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQfACaiIILQAAIgFqQcgBaiEG\
AkAgAUGoAUYNACAGQQBBqAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAX\
I6AAADQCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFB\
AmoiBiAGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw\
0ACyAHECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHwAmpBADoAACAEQQA2AqADIARBoANqQQRy\
QQBBqAEQOhogBEGoATYCoAMgBEHQBGogBEGgA2pBrAEQORogBEEoakHIAWogBEHQBGpBBHJBqAEQOR\
ogBEEoakHwAmpBADoAACAEQShqIAIgAxAxDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBpAAsg\
AxAWIgJFDRggAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQdACaiIILQAAIgFqQcgBaiEGAkAgAU\
GIAUYNACAGQQBBiAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdBzwJqIgEgAS0AAEGAAXI6AAAD\
QCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBi\
AGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQYgBRw0ACyAH\
ECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHQAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBiA\
EQOhogBEGIATYCoAMgBEHQBGogBEGgA2pBjAEQORogBEEoakHIAWogBEHQBGpBBHJBiAEQORogBEEo\
akHQAmpBADoAACAEQShqIAIgAxAyDBkLIAEoAgQhAiAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3Ag\
AgBEIANwLUBEEYIQMgBEEYNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpBCGogBEHQBGpB\
CGopAwA3AwAgBEEoakEYaiAEQdAEakEYaigCADYCACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBE\
GgA2pBEGoiBiAEQShqQRRqKQIANwMAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQ\
MCACQgA3AwBBACEBIAJB4ABqQQA6AAAgAkEAKQP4kUA3AwggAkEQakEAKQOAkkA3AwAgAkEYakEAKQ\
OIkkA3AwBBGBAWIgJFDRcgAiAEKQOgAzcAACACQRBqIAYpAwA3AAAgAkEIaiAFKQMANwAADBgLQcAA\
QQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQ\
QgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEB\
QQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIA\
QbEQUAAAtBwABBAUEAKAL41EAiBEEEIAQbEQUAAAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EQQQFB\
ACgC+NRAIgRBBCAEGxEFAAALQRRBAUEAKAL41EAiBEEEIAQbEQUAAAtBFEEBQQAoAvjUQCIEQQQgBB\
sRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAo\
AvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGx\
EFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAo\
AvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQ\
UAAAtBGEEBQQAoAvjUQCIEQQQgBBsRBQAACyAAIAI2AgQgACABNgIAIABBCGogAzYCACAEQYAGaiQA\
C5xWAhp/An4jAEGwAmsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4YAAECAw\
QFBgcICQoLDA0ODxAREhMUFRYXAAsgACgCBCIAQcgAaiEEAkBBgAEgAEHIAWotAAAiBWsiBiACTw0A\
AkAgBUUNACAEIAVqIAEgBhA5GiAAIAApA0BCgAF8NwNAIAAgBEIAEBEgASAGaiEBIAIgBmshAgsgAi\
ACQQd2IgYgAkEARyACQf8AcUVxIgdrIgVBB3QiCGshAiAFRQ1FIAhFDUUgBkEAIAdrakEHdCEGIAEh\
BQNAIAAgACkDQEKAAXw3A0AgACAFQgAQESAFQYABaiEFIAZBgH9qIgYNAAxGCwsgBCAFaiABIAIQOR\
ogBSACaiECDEULIAAoAgQiAEHIAGohBAJAQYABIABByAFqLQAAIgVrIgYgAk8NAAJAIAVFDQAgBCAF\
aiABIAYQORogACAAKQNAQoABfDcDQCAAIARCABARIAEgBmohASACIAZrIQILIAIgAkEHdiIGIAJBAE\
cgAkH/AHFFcSIHayIFQQd0IghrIQIgBUUNQSAIRQ1BIAZBACAHa2pBB3QhBiABIQUDQCAAIAApA0BC\
gAF8NwNAIAAgBUIAEBEgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDkaIAUgAmohAgxBCy\
AAKAIEIgBByABqIQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAg\
ACkDQEKAAXw3A0AgACAEQgAQESABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2\
siBUEHdCIIayECIAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVC\
ABARIAVBgAFqIQUgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA5GiAFIAJqIQIMPQsgACgCBCIAQShqIQ\
QCQEHAACAAQegAai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDAELAAHw3AwAg\
ACAEQQAQEyABIAZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBU\
UNOSAIRQ05IAZBACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBMgBUHAAGohBSAG\
QUBqIgYNAAw6CwsgBCAFaiABIAIQORogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAE\
UNNiAIIAEgAkGACCAAayIAIAAgAksbIgUQMxogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcD\
ACADQfgAakEYaiAIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMG\
opAwA3AwAgA0H4AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABq\
IAhByABqKQMANwMAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0\
H4AGpB4ABqIAhB4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGoh\
CSADIAgtAGgiCjoA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAg\
A3AwAgA0HoAWpBEGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFq\
IANB+ABqQShqIAogHSAHEBkgCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAv\
QBIQwgAygC7AEhDSADKALoASEOIAggCCkDABApIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBq\
IAo2AgAgAEEcaiAHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQ\
hqIA02AgAgAEEEaiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcD\
ACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaC\
AIQQhqIgAgCCkDcDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgB\
aikDADcDACAIIAgpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIg\
BrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFq\
LQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIA\
BBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCABIAhqIQELIAEgAkGQAW5B\
kAFsIgBqIQcgAiAAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgAS\
AFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoA\
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\
MGogGykDADcDACAKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3\
giHjcDCCADIA4gF0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcD\
ACADQegBakEIaiIGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBkgFygCACEOIAcoAg\
AhByAGKAIAIRcgAygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABAp\
IAgoApABIgZBN08NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBS\
AXNgIIIAUgGzYCBCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGoh\
ASACIABrIgJBgAhLDQALCyACRQ0TIAggASACEDMaIAggCCkDABApDBMLIAAgAkGghcAAEEkACyAFQc\
AAQeCEwAAQSQALIAZBwABB8ITAABBJAAsgBkEgQYCFwAAQSQALIANBkAJqQQhqIgEgGjYCACADQZAC\
akEQaiIAIBg2AgAgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpA\
IgA0GJAWoiASAAKQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiAD\
IAMpA5ACNwB5IANBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIA\
MgAykAeTcDCEGQksAAIANBCGpBgIbAAEH4hsAAEEAACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoi\
ACASNgIAIANBkAJqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQCIANBiQ\
FqIgEgACkDADcAACADIA82AqwCIANBkQFqIgAgBSkDADcAACADIBU2ApQCIAMgFjYCkAIgAyADKQOQ\
AjcAeSADQQhqQRhqIAApAAA3AwAgA0EIakEQaiABKQAANwMAIANBCGpBCGogBikAADcDACADIAMpAH\
k3AwhBkJLAACADQQhqQYCGwABB+IbAABBAAAsgA0GYAmoiASAXNgIAIANBoAJqIgAgBzYCACADQagC\
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\
NgIcIAMgAUEgaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiCzYCICADIAFBGG\
ooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgw2AhggAygCACENIAMoAgQhDiAD\
KAIIIQ8gAygCECEQIAMoAgwhESADKAIUIRIgAyABQSRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdk\
GA/gNxIAJBGHZyciITNgIkIAMgAUEoaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2\
cnIiFDYCKCADIAFBMGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhU2AjAgAy\
ABQSxqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIWNgIsIAMgAUE0aigAACIC\
QRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiAjYCNCADIAFBOGooAAAiF0EYdCAXQQh0QY\
CA/AdxciAXQQh2QYD+A3EgF0EYdnJyIhc2AjggAyABQTxqKAAAIhhBGHQgGEEIdEGAgPwHcXIgGEEI\
dkGA/gNxIBhBGHZyciIYNgI8IAggEyAKcyAYcyAMIBBzIBVzIBEgDnMgE3MgF3NBAXciGXNBAXciGn\
NBAXciGyAKIBJzIAJzIBAgD3MgFHMgGHNBAXciHHNBAXciHXMgGCACcyAdcyAVIBRzIBxzIBtzQQF3\
Ih5zQQF3Ih9zIBogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYgE3MgGXMgCyAMcyAXcyASIBFzIBZzIA\
8gDXMgC3MgAnNBAXciIHNBAXciIXNBAXciInNBAXciI3NBAXciJHNBAXciJXNBAXciJnNBAXciJyAd\
ICFzIAIgFnMgIXMgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAcICBzIChzIB9zQQF3IipzQQF3IitzIB\
8gKXMgK3MgHiAocyAqcyAnc0EBdyIsc0EBdyItcyAmICpzICxzICUgH3MgJ3MgJCAecyAmcyAjIBtz\
ICVzICIgGnMgJHMgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5zQQF3Ii9zQQF3IjBzQQF3IjFzQQF3Ij\
JzQQF3IjNzQQF3IjRzQQF3IjUgKyAvcyApICNzIC9zICggInMgLnMgK3NBAXciNnNBAXciN3MgKiAu\
cyA2cyAtc0EBdyI4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMgNXNBAXciOnNBAXciO3MgNCA4cyA6cy\
AzIC1zIDVzIDIgLHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJXMgMXMgLiAkcyAwcyA3c0EBdyI8c0EB\
dyI9c0EBdyI+c0EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EBdyJDIDkgPXMgNyAxcyA9cyA2IDBzID\
xzIDlzQQF3IkRzQQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAXciR3MgOyBFcyBHcyA6IERzIEZzIENz\
QQF3IkhzQQF3IklzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJzID8gNXMgQXMgPiA0cyBAcyA9IDNzID\
9zIDwgMnMgPnMgRXNBAXciSnNBAXciS3NBAXciTHNBAXciTXNBAXciTnNBAXciT3NBAXciUHNBAXdq\
IEYgSnMgRCA+cyBKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3MgS3MgUXNBAXciUyBMIEEgOiA5IDwgMS\
AmIB8gKCAhIBcgEyAQIAhBHnciVGogDiAFIAdBHnciECAGcyAIcSAGc2pqIA0gBCAIQQV3aiAGIAVz\
IAdxIAVzampBmfOJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgggDkEedyINcyAGIA9qIA4gVCAQc3EgEH\
NqIFVBBXdqQZnzidQFaiIOcSANc2ogECARaiBVIA0gVHNxIFRzaiAOQQV3akGZ84nUBWoiEEEFd2pB\
mfOJ1AVqIhFBHnciD2ogDCAIaiARIBBBHnciEyAOQR53IgxzcSAMc2ogEiANaiAMIAhzIBBxIAhzai\
ARQQV3akGZ84nUBWoiEUEFd2pBmfOJ1AVqIhJBHnciCCARQR53IhBzIAogDGogESAPIBNzcSATc2og\
EkEFd2pBmfOJ1AVqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3NqIApBBXdqQZnzidQFaiIMQQV3akGZ84\
nUBWoiD0EedyILaiAVIApBHnciF2ogCyAMQR53IhNzIBQgEGogDCAXIAhzcSAIc2ogD0EFd2pBmfOJ\
1AVqIhRxIBNzaiAWIAhqIA8gEyAXc3EgF3NqIBRBBXdqQZnzidQFaiIVQQV3akGZ84nUBWoiFiAVQR\
53IhcgFEEedyIIc3EgCHNqIAIgE2ogCCALcyAVcSALc2ogFkEFd2pBmfOJ1AVqIhRBBXdqQZnzidQF\
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\
ckEAQYABEDoaIAJBgAE2AgAgAkGwAWogAkGEARA5GiAEQdAAaiACQbABakEEckGAARA5GiAEQcgAak\
IANwMAIARCADcDQCAEQQA6ANABIARBACkDsI5ANwMAIARBCGpBACkDuI5ANwMAIARBEGpBACkDwI5A\
NwMAIARBGGpBACkDyI5ANwMAIARBIGpBACkD0I5ANwMAIARBKGpBACkD2I5ANwMAIARBMGpBACkD4I\
5ANwMAIARBOGpBACkD6I5ANwMAQRQhBQwjC0HwABAWIgRFDQwgAkGwAWpBCGoQVSAEQSBqIAJB2AFq\
KQMANwMAIARBGGogAkGwAWpBIGopAwA3AwAgBEEQaiACQbABakEYaikDADcDACAEQQhqIAJBsAFqQR\
BqKQMANwMAIAQgAikDuAE3AwAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIA\
IAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOR\
ogBEHgAGogAkGwAWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGop\
AgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABak\
EUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkAC\
QAJAIANBuoDAAEEKEFFFDQAgA0HEgMAAQQoQUUUNASADQc6AwABBChBRRQ0CIANB2IDAAEEKEFFFDQ\
MgA0HogMAAQQoQUQ0MQegAEBYiBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRq\
QgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAk\
HEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbAB\
akEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAk\
GwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAg\
BEEAKQPYjUA3AwggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBYiBEUNDy\
AEQQBByAEQOiEFIAJBADYCACACQQRyQQBBkAEQOhogAkGQATYCACACQbABaiACQZQBEDkaIAVByAFq\
IAJBsAFqQQRyQZABEDkaIAVBADoA2AJBBSEFDCQLQdgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCAC\
ACQQRyQQBBiAEQOhogAkGIATYCACACQbABaiACQYwBEDkaIAVByAFqIAJBsAFqQQRyQYgBEDkaIAVB\
ADoA0AJBBiEFDCMLQbgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBB6AAQOhogAkHoAD\
YCACACQbABaiACQewAEDkaIAVByAFqIAJBsAFqQQRyQegAEDkaIAVBADoAsAJBByEFDCILQZgCEBYi\
BEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBByAAQOhogAkHIADYCACACQbABaiACQcwAEDkaIA\
VByAFqIAJBsAFqQQRyQcgAEDkaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQUUUNACADQeWAwABB\
AxBRDQhB4AAQFiIERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQS\
xqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB\
0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANw\
AAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIA\
NwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8e\
rmbzcDCCAEQgA3AwAgBEEAOgBYQQohBQwhC0HgABAWIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACAC\
QRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQc\
AANgIAIAJBsAFqIAJBxAAQORogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3\
AAAgBEHAAGogAkGwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQ\
IANwAAIARBKGogAkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC\
/rnrxemOlZkQNwMQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAy\
kAAELTkIWa08WMmTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELT\
kIWa06XNmDJRDQMgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFiIERQ0eIA\
RBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWog\
AkGwAWpBBHJBiAEQORogBUEAOgDQAkEWIQUMIwtB4AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIA\
JBBHJBAEGQARA6GiACQZABNgIAIAJBsAFqIAJBlAEQORogBUHIAWogAkGwAWpBBHJBkAEQORogBUEA\
OgDYAkENIQUMIgtB2AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNg\
IAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEOIQUMIQtBuAIQFiIE\
RQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHoABA6GiACQegANgIAIAJBsAFqIAJB7AAQORogBU\
HIAWogAkGwAWpBBHJB6AAQORogBUEAOgCwAkEPIQUMIAtBmAIQFiIERQ0UIARBAEHIARA6IQUgAkEA\
NgIAIAJBBHJBAEHIABA6GiACQcgANgIAIAJBsAFqIAJBzAAQORogBUHIAWogAkGwAWpBBHJByAAQOR\
ogBUEAOgCQAkEQIQUMHwtB8AAQFiIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJB\
JGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABai\
ACQcQAEDkaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJB\
sAFqQSxqKQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOG\
ogAkGwAWpBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6\
AGggBEEAKQOQjkA3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3Aw\
BBESEFDB4LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAg\
AkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5Gi\
AEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikC\
ADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQR\
RqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD\
8I1ANwMIIARBEGpBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0\
HYARAWIgRFDRQgAkEANgIAIAJBBHJBAEGAARA6GiACQYABNgIAIAJBsAFqIAJBhAEQORogBEHQAGog\
AkGwAWpBBHJBgAEQORogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQ\
ApA/iOQDcDACAEQRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShq\
QQApA5iPQDcDACAEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFiIERQ0VIA\
RBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGoARA6GiACQagBNgIAIAJBsAFqIAJBrAEQORogBUHIAWog\
AkGwAWpBBHJBqAEQORogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQUUUNFyADQZOBwABBBRBRDQFB6A\
AQFiIERQ0WIARCADcDACAEQQApA/iRQDcDCCAEQRBqQQApA4CSQDcDACAEQRhqQQApA4iSQDcDACAC\
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\
QEEAQbTVwAA2ArzVQEEAQcTVwAA2AtDVQEEAQbzVwAA2AsTVQEEAQQA2ArjYQEEAQczVwAA2AtjVQE\
EAQcTVwAA2AszVQEEAQczVwAA2AtTVQEEAQdTVwAA2AuDVQEEAQdTVwAA2AtzVQEEAQdzVwAA2AujV\
QEEAQdzVwAA2AuTVQEEAQeTVwAA2AvDVQEEAQeTVwAA2AuzVQEEAQezVwAA2AvjVQEEAQezVwAA2Av\
TVQEEAQfTVwAA2AoDWQEEAQfTVwAA2AvzVQEEAQfzVwAA2AojWQEEAQfzVwAA2AoTWQEEAQYTWwAA2\
ApDWQEEAQYTWwAA2AozWQEEAQYzWwAA2ApjWQEEAQZTWwAA2AqDWQEEAQYzWwAA2ApTWQEEAQZzWwA\
A2AqjWQEEAQZTWwAA2ApzWQEEAQaTWwAA2ArDWQEEAQZzWwAA2AqTWQEEAQazWwAA2ArjWQEEAQaTW\
wAA2AqzWQEEAQbTWwAA2AsDWQEEAQazWwAA2ArTWQEEAQbzWwAA2AsjWQEEAQbTWwAA2ArzWQEEAQc\
TWwAA2AtDWQEEAQbzWwAA2AsTWQEEAQczWwAA2AtjWQEEAQcTWwAA2AszWQEEAQdTWwAA2AuDWQEEA\
QczWwAA2AtTWQEEAQdzWwAA2AujWQEEAQdTWwAA2AtzWQEEAQeTWwAA2AvDWQEEAQdzWwAA2AuTWQE\
EAQezWwAA2AvjWQEEAQeTWwAA2AuzWQEEAQfTWwAA2AoDXQEEAQezWwAA2AvTWQEEAQfzWwAA2AojX\
QEEAQfTWwAA2AvzWQEEAQYTXwAA2ApDXQEEAQfzWwAA2AoTXQEEAIAY2AqDYQEEAQYTXwAA2AozXQE\
EAIAhBWGoiADYCmNhAIAYgAEEBcjYCBCAIIAZqQVxqQSg2AgBBAEGAgIABNgK82EALQQAhAUEAKAKY\
2EAiACACTQ0AQQAgACACayIBNgKY2EBBAEEAKAKg2EAiACACaiIFNgKg2EAgBSABQQFyNgIEIAAgAk\
EDcjYCBCAAQQhqDwsgAQu5JQIDfx5+IwBBwABrIgNBOGpCADcDACADQTBqQgA3AwAgA0EoakIANwMA\
IANBIGpCADcDACADQRhqQgA3AwAgA0EQakIANwMAIANBCGpCADcDACADQgA3AwACQCACRQ0AIAEgAk\
EGdGohBCAAKQMQIQYgACkDCCEHIAApAwAhCANAIAMgAUEYaikAACIJIAEpAAAiCiABQThqKQAAIgtC\
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\
NwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANw\
MAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEMgASAP\
NwNIIAIgAUEIakHQARA5GkEAIQMMHwsgAigCBCEDQdABEBYiAkUNBiABQQhqQThqIANBOGopAwA3Aw\
AgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAg\
AUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgAS\
ADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBDIAEgDzcDSCACIAFBCGpB0AEQORpBASEDDB4L\
IAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQ\
hqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhq\
QRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAG\
ogA0HIAGoQQyABIA83A0ggAiABQQhqQdABEDkaQQIhAwwdCyACKAIEIQNB8AAQFiICRQ0GIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCD\
cDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkEDIQMMHAsgAigCBCED\
QfgOEBYiAkUNBiABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQf\
gAaiADQfgAaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwA\
BqIANBwABqKQMANwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFB\
CGpB2ABqIANB2ABqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3Ax\
AgASADKQMoNwMwIAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcM\
GwsgAUGAD2pBGGoiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPak\
EIaiILIAlBCGopAAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIh\
BwNAIANBYGoiDSABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAA\
JAAkAgDCAHaiIOQQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcD\
ACABIA0pAAA3A4APIAdBOEcNARBqAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIA\
NBEGogCikDADcAACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAg\
CyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQbgALEG8AC0\
HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjU\
QCIBQQQgARsRBQAAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQ\
AACyACKAIEIQMCQEHoABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcD\
ACABIAMpAwg3AxAgAykDACEPIAFBCGpBIGogA0EgahA3IAEgDzcDCCACIAFBCGpB6AAQORpBFyEDDB\
QLQegAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQORog\
AUEIakHIAWogA0HIAWoQRCACIAFBCGpB2AIQORpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAA\
ALIAIoAgQhAwJAQfgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB\
+AIQORpBFSEDDBILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBYiAkUNACABQQ\
hqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhq\
QSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQ\
hqIANBCGopAwA3AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEMg\
AUEIakHIAGogDzcDACABIBA3A0ggAiABQQhqQdgBEDkaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgAR\
sRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikD\
ADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDAD\
cDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikD\
ACEPIAMpA0AhECABQQhqQdAAaiADQdAAahBDIAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYAR\
A5GkETIQMMEAtB2AFBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFiICRQ0AIAFBCGpB\
IGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCD\
cDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkESIQMMDwtB8ABBCEEA\
KAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFiICRQ0AIAFBCGpBIGogA0EgaikDADcDACABQQ\
hqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEo\
aiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkERIQMMDgtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAA\
sgAigCBCEDAkBBmAIQFiICRQ0AIAFBCGogA0HIARA5GiABQQhqQcgBaiADQcgBahBGIAIgAUEIakGY\
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\
AgAiA0UNAiACQQF0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQ\
A2AgAgASADNgIMIAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAo\
AsTYQEF/aiIBNgLE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAk\
BBACgChNVAIgJBASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyAB\
NgIMIAEgADYCDCABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQ\
AgATYCxNhADwsLlQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhq\
IgdCADcDACACQSBqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQ\
hqIgwgASkACDcDACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3\
AwAgAiABKAAcIhA2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIh\
M2AgAgAiABKAA0Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4g\
BiAEIAUgBiADIAYgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3\
ciByABcWogBiAHQX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEg\
AWogByAJQX9zcWogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIai\
AJIAJBf3NxampBC3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAI\
cSACaiAHIAFBf3NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAIaiABIAdBf3NxampBE3\
ciCCAHcSABaiACIAhBf3NxampBA3ciASAUIAEgCiABIAhxIAJqIAcgAUF/c3FqakEHdyIJcSAHaiAI\
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\
aiACQRBqKQMANwMAIAMgAikDCDcDACADQegAakEAOgAADBQLIAMoAgQiA0IANwMAIAMgAykDcDcDCC\
ADQSBqIANBiAFqKQMANwMAIANBGGogA0GAAWopAwA3AwAgA0EQaiADQfgAaikDADcDACADQShqQQBB\
wgAQOhogAygCkAFFDRMgA0EANgKQAQwTCyADKAIEQQBByAEQOkHYAmpBADoAAAwSCyADKAIEQQBByA\
EQOkHQAmpBADoAAAwRCyADKAIEQQBByAEQOkGwAmpBADoAAAwQCyADKAIEQQBByAEQOkGQAmpBADoA\
AAwPCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQNw\
MADA4LIAMoAgQiA0KBxpS6lvHq5m83AwggA0IANwMAIANB2ABqQQA6AAAgA0EQakL+uevF6Y6VmRA3\
AwAMDQsgAygCBCIDQgA3AwAgA0HgAGpBADoAACADQQApA9iNQDcDCCADQRBqQQApA+CNQDcDACADQR\
hqQQAoAuiNQDYCAAwMCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAAIANBGGpB\
8MPLnnw2AgAgA0EQakL+uevF6Y6VmRA3AwAMCwsgAygCBEEAQcgBEDpB2AJqQQA6AAAMCgsgAygCBE\
EAQcgBEDpB0AJqQQA6AAAMCQsgAygCBEEAQcgBEDpBsAJqQQA6AAAMCAsgAygCBEEAQcgBEDpBkAJq\
QQA6AAAMBwsgAygCBCIDQgA3AwAgA0HoAGpBADoAACADQQApA5COQDcDCCADQRBqQQApA5iOQDcDAC\
ADQRhqQQApA6COQDcDACADQSBqQQApA6iOQDcDAAwGCyADKAIEIgNCADcDACADQegAakEAOgAAIANB\
ACkD8I1ANwMIIANBEGpBACkD+I1ANwMAIANBGGpBACkDgI5ANwMAIANBIGpBACkDiI5ANwMADAULIA\
MoAgQiA0IANwNAIANBACkD8I5ANwMAIANByABqQgA3AwAgA0E4akEAKQOoj0A3AwAgA0EwakEAKQOg\
j0A3AwAgA0EoakEAKQOYj0A3AwAgA0EgakEAKQOQj0A3AwAgA0EYakEAKQOIj0A3AwAgA0EQakEAKQ\
OAj0A3AwAgA0EIakEAKQP4jkA3AwAgA0HQAWpBADoAAAwECyADKAIEIgNCADcDQCADQQApA7COQDcD\
ACADQcgAakIANwMAIANBOGpBACkD6I5ANwMAIANBMGpBACkD4I5ANwMAIANBKGpBACkD2I5ANwMAIA\
NBIGpBACkD0I5ANwMAIANBGGpBACkDyI5ANwMAIANBEGpBACkDwI5ANwMAIANBCGpBACkDuI5ANwMA\
IANB0AFqQQA6AAAMAwsgAygCBEEAQcgBEDpB8AJqQQA6AAAMAgsgAygCBEEAQcgBEDpB0AJqQQA6AA\
AMAQsgAygCBCIDQgA3AwAgA0HgAGpBADoAACADQQApA/iRQDcDCCADQRBqQQApA4CSQDcDACADQRhq\
QQApA4iSQDcDAAsgAUEANgIAIABCADcDACACQdAAaiQADwsQbgALEG8AC5gKAgR/BH4jAEGQA2siAy\
QAIAEgAUGAAWotAAAiBGoiBUGAAToAACAAQcgAaikDAEIKhiAAKQNAIgdCNoiEIghCCIhCgICA+A+D\
IAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhIQhCSAIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhk\
KAgICAgOA/gyAIQgiGQoCAgIDwH4OEhCEKIAdCCoYgBK1CA4aEIghCCIhCgICA+A+DIAhCGIhCgID8\
B4OEIAhCKIhCgP4DgyAIQjiIhIQhByAIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKAgICAgOA/gy\
AIQgiGQoCAgIDwH4OEhCEIAkAgBEH/AHMiBkUNACAFQQFqQQAgBhA6GgsgCiAJhCEJIAggB4QhCAJA\
AkAgBEHwAHFB8ABGDQAgAUH4AGogCDcAACABQfAAaiAJNwAAIAAgAUEBEA0MAQsgACABQQEQDSADQQ\
A2AoABIANBgAFqQQRyQQBBgAEQOhogA0GAATYCgAEgA0GIAmogA0GAAWpBhAEQORogAyADQYgCakEE\
ckHwABA5IgRB+ABqIAg3AwAgBEHwAGogCTcDACAAIARBARANCyABQYABakEAOgAAIAIgACkDACIIQj\
iGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKAgICAgOA/gyAIQgiGQoCAgIDwH4OEhCAIQgiIQoCAgPgP\
gyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhDcAACACIAApAwgiCEI4hiAIQiiGQoCAgICAgM\
D/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4Qg\
CEIoiEKA/gODIAhCOIiEhIQ3AAggAiAAKQMQIghCOIYgCEIohkKAgICAgIDA/wCDhCAIQhiGQoCAgI\
CA4D+DIAhCCIZCgICAgPAfg4SEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiI\
hISENwAQIAIgACkDGCIIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKAgICAgOA/gyAIQgiGQoCAgI\
DwH4OEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhDcAGCACIAApAyAi\
CEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQgCEIIiEKAgI\
D4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQ3ACAgAiAAKQMoIghCOIYgCEIohkKAgICA\
gIDA/wCDhCAIQhiGQoCAgICA4D+DIAhCCIZCgICAgPAfg4SEIAhCCIhCgICA+A+DIAhCGIhCgID8B4\
OEIAhCKIhCgP4DgyAIQjiIhISENwAoIAIgACkDMCIIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKA\
gICAgOA/gyAIQgiGQoCAgIDwH4OEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCE\
I4iISEhDcAMCACIAApAzgiCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKA\
gICA8B+DhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQ3ADggA0GQA2\
okAAvvCQIQfwV+IwBBkAFrIgIkAAJAAkACQCABKAKQASIDRQ0AAkACQCABQekAai0AACIEQQZ0QQAg\
AS0AaCIFa0cNACADQX5qIQYgA0EBTQ0EIAJBEGogAUH4AGopAwA3AwAgAkEYaiABQYABaikDADcDAC\
ACQSBqIAFBiAFqKQMANwMAIAJBMGogAUGUAWoiByAGQQV0aiIEQQhqKQIANwMAIAJBOGogBEEQaikC\
ADcDAEHAACEFIAJBwABqIARBGGopAgA3AwAgAiABKQNwNwMIIAIgBCkCADcDKCADQQV0IAdqQWBqIg\
QpAgAhEiAEKQIIIRMgBCkCECEUIAEtAGohCCACQeAAaiAEKQIYNwMAIAJB2ABqIBQ3AwAgAkHQAGog\
EzcDACACQcgAaiASNwMAQgAhEiACQgA3AwAgCEEEciEJIAJBCGohBAwBCyACQRBqIAFBEGopAwA3Aw\
AgAkEYaiABQRhqKQMANwMAIAJBIGogAUEgaikDADcDACACQTBqIAFBMGopAwA3AwAgAkE4aiABQThq\
KQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABqIAFByABqKQMANwMAIAJB0ABqIAFB0ABqKQMANw\
MAIAJB2ABqIAFB2ABqKQMANwMAIAJB4ABqIAFB4ABqKQMANwMAIAIgASkDCDcDCCACIAEpAyg3Aygg\
AS0AaiEIIAIgASkDACISNwMAIAggBEVyQQJyIQkgAkEIaiEEIAMhBgsgAiAJOgBpIAIgBToAaAJAAk\
AgBkUNACABQfAAaiEKIAJBKGohB0EBIAZrIQsgCEEEciEIIAZBBXQgAWpB9ABqIQEgBkF/aiADTyEM\
A0AgDA0CIAJB8ABqQRhqIgYgBEEYaiINKQIANwMAIAJB8ABqQRBqIg4gBEEQaiIPKQIANwMAIAJB8A\
BqQQhqIhAgBEEIaiIRKQIANwMAIAIgBCkCADcDcCACQfAAaiAHIAUgEiAJEBkgECkDACETIA4pAwAh\
FCAGKQMAIRUgAikDcCEWIAdBGGogAUEYaikCADcCACAHQRBqIAFBEGopAgA3AgAgB0EIaiABQQhqKQ\
IANwIAIAcgASkCADcCACAEIAopAwA3AwAgESAKQQhqKQMANwMAIA8gCkEQaikDADcDACANIApBGGop\
AwA3AwBCACESIAJCADcDACACIBU3A2AgAiAUNwNYIAIgEzcDUCACIBY3A0ggAiAIOgBpQcAAIQUgAk\
HAADoAaCABQWBqIQEgCCEJIAtBAWoiC0EBRw0ACwsgACACQfAAEDkaDAILQQAgC2sgA0HQhcAAEE0A\
CyAAIAEpAwg3AwggACABKQMoNwMoIABBEGogAUEQaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEgai\
ABQSBqKQMANwMAIABBMGogAUEwaikDADcDACAAQThqIAFBOGopAwA3AwAgAEHAAGogAUHAAGopAwA3\
AwAgAEHIAGogAUHIAGopAwA3AwAgAEHQAGogAUHQAGopAwA3AwAgAEHYAGogAUHYAGopAwA3AwAgAE\
HgAGogAUHgAGopAwA3AwAgAUHpAGotAAAhBCABLQBqIQcgACABLQBoOgBoIAAgASkDADcDACAAIAcg\
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\
IAYoAgghBwsCQAJAAkACQCAJRQ0AIAdBBXQiAiAFSw0BIAUgAmsiAUEfTQ0CIAlBIEcNAyAEIAJqIg\
IgACAIaiIBKQAANwAAIAJBGGogAUEYaikAADcAACACQRBqIAFBEGopAAA3AAAgAkEIaiABQQhqKQAA\
NwAAIAdBAWohBwsgBkEwaiQAIAcPCyACIAVBsITAABBKAAtBICABQbCEwAAQSQALQSAgCUHki8AAEE\
wAC4EEAgN/An4jAEHwAWsiAyQAIAApAwAhBiABIAFBwABqLQAAIgRqIgVBgAE6AAAgA0EIakEQaiAA\
QRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiEGIAStQgOGIQcCQCAEQT9zIg\
BFDQAgBUEBakEAIAAQOhoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADQQhqIAEQEgwB\
CyADQQhqIAEQEiADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAak\
EkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAA\
NgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQ\
IANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEU\
aikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahASCy\
ACIAMoAgg2AAAgAiADKQIMNwAEIAIgAykCFDcADCABQcAAakEAOgAAIANB8AFqJAAL8AMCA38CfiMA\
QfABayIDJAAgAUHAAGotAAAhBCAAKQMAIQYgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCABIARqIg\
BBgAE6AAAgBkIJhiEGIAStQgOGIQcgAyADQQhqNgIcAkAgBEE/cyIFRQ0AIABBAWpBACAFEDoaCyAH\
IAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EcaiABEBwMAQsgA0EcaiABEBwgA0HgAGpBDG\
pCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIA\
NwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEAB\
A5GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEk\
aikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBak\
EMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQRxqIANBIGoQHAsgAUHAAGpBADoAACACIAMpAwg3\
AAAgAiADKQMQNwAIIANB8AFqJAAL2QMCA38CfiMAQeABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBG\
oiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIA\
RQ0AIAVBAWpBACAAEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgAyABEB8MAQsgAy\
ABEB8gA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcC\
ACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAWpCADcCACADQgA3AlQgA0HAADYCUCADQZ\
gBaiADQdAAakHEABA5GiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMAIANB\
MGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANwMAIA\
NBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEB8LIAIgAykDADcAACAC\
IAMpAwg3AAggAUHAAGpBADoAACADQeABaiQAC9QDAgR/An4jAEHQAWsiAyQAIAEgAUHAAGotAAAiBG\
oiBUEBOgAAIAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEDoaCyAHIAiEIQcC\
QAJAIARBOHFBOEYNACABQThqIAc3AAAgAEEIaiABQQEQFwwBCyAAQQhqIgQgAUEBEBcgA0HAAGpBDG\
pCADcCACADQcAAakEUakIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIA\
NwIAIANBwABqQTRqQgA3AgAgA0H8AGpCADcCACADQgA3AkQgA0HAADYCQCADQYgBaiADQcAAakHEAB\
A5GiADQTBqIANBiAFqQTRqKQIANwMAIANBKGogA0GIAWpBLGopAgA3AwAgA0EgaiADQYgBakEkaikC\
ADcDACADQRhqIANBiAFqQRxqKQIANwMAIANBEGogA0GIAWpBFGopAgA3AwAgA0EIaiADQYgBakEMai\
kCADcDACADIAMpAowBNwMAIAMgBzcDOCAEIANBARAXCyABQcAAakEAOgAAIAIgACkDCDcAACACIABB\
EGopAwA3AAggAiAAQRhqKQMANwAQIANB0AFqJAALlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAk\
ACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDkgBmohASACIAZrIQILIAIg\
AkGoAW4iBUGoAWwiB0kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQORogAB\
AkIAUgA0HgAmpBqAEQOUGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbAB\
akEEckEAQagBEDoaIANBqAE2ArABIANB4AJqIANBsAFqQawBEDkaIANBCGogA0HgAmpBBHJBqAEQOR\
ogA0HgAmogAEGoARA5GiAAECQgA0EIaiADQeACakGoARA5GiAGQakBTw0CIAEgB2ogA0EIaiAGEDka\
IAQgA0EIakGoARA5GgwDCyABIAQgBWogAhA5GiAFIAJqIQYMAgtBoY3AAEEjQcSNwAAQUwALIAZBqA\
FBxIzAABBJAAsgAEHwAmogBjoAACADQZAEaiQAC5cDAQV/IwBBsANrIgMkACAAQcgBaiEEAkACQAJA\
AkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhA5IAZqIQEgAiAGayECCyACIA\
JBiAFuIgVBiAFsIgdJDQEgAiAHayEGAkAgBUGIAWwiAkUNACABIQUDQCADQaACaiAAQYgBEDkaIAAQ\
JCAFIANBoAJqQYgBEDlBiAFqIQUgAkH4fmoiAg0ACwsCQCAGDQBBACEGDAQLIANBADYCkAEgA0GQAW\
pBBHJBAEGIARA6GiADQYgBNgKQASADQaACaiADQZABakGMARA5GiADQQhqIANBoAJqQQRyQYgBEDka\
IANBoAJqIABBiAEQORogABAkIANBCGogA0GgAmpBiAEQORogBkGJAU8NAiABIAdqIANBCGogBhA5Gi\
AEIANBCGpBiAEQORoMAwsgASAEIAVqIAIQORogBSACaiEGDAILQaGNwABBI0HEjcAAEFMACyAGQYgB\
QcSMwAAQSQALIABB0AJqIAY6AAAgA0GwA2okAAuCAwEDfwJAAkACQAJAIAAtAGgiA0UNAAJAIANBwQ\
BPDQAgACADakEoaiABIAJBwAAgA2siAyADIAJLGyIDEDkaIAAgAC0AaCADaiIEOgBoIAEgA2ohAQJA\
IAIgA2siAg0AQQAhAgwDCyAAQQhqIABBKGoiBEHAACAAKQMAIAAtAGogAEHpAGoiAy0AAEVyEBkgBE\
EAQcEAEDoaIAMgAy0AAEEBajoAAAwBCyADQcAAQZCEwAAQSgALAkAgAkHAAEsNACACQcAAIAJBwABJ\
GyECQQAhAwwCCyAAQQhqIQUgAEHpAGoiAy0AACEEA0AgBSABQcAAIAApAwAgAC0AaiAEQf8BcUVyEB\
kgAyADLQAAQQFqIgQ6AAAgAUHAAGohASACQUBqIgJBwABLDQALIAAtAGghBAsgBEH/AXEiA0HBAE8N\
ASACQcAAIANrIgQgBCACSxshAgsgACADakEoaiABIAIQORogACAALQBoIAJqOgBoIAAPCyADQcAAQZ\
CEwAAQSgAL0AICBX8BfiMAQTBrIgIkAEEnIQMCQAJAIABCkM4AWg0AIAAhBwwBC0EnIQMDQCACQQlq\
IANqIgRBfGogAEKQzgCAIgdC8LF/fiAAfKciBUH//wNxQeQAbiIGQQF0QamIwABqLwAAOwAAIARBfm\
ogBkGcf2wgBWpB//8DcUEBdEGpiMAAai8AADsAACADQXxqIQMgAEL/wdcvViEEIAchACAEDQALCwJA\
IAenIgRB4wBMDQAgAkEJaiADQX5qIgNqIAenIgVB//8DcUHkAG4iBEGcf2wgBWpB//8DcUEBdEGpiM\
AAai8AADsAAAsCQAJAIARBCkgNACACQQlqIANBfmoiA2ogBEEBdEGpiMAAai8AADsAAAwBCyACQQlq\
IANBf2oiA2ogBEEwajoAAAsgAUGgkcAAQQAgAkEJaiADakEnIANrECohAyACQTBqJAAgAwuhAgEBfy\
MAQTBrIgYkACAGIAI2AiggBiACNgIkIAYgATYCICAGQRBqIAZBIGoQFSAGKAIUIQICQAJAAkAgBigC\
EEEBRg0AIAYgAjYCCCAGIAZBEGpBCGooAgA2AgwgBkEIaiADEDYgBiAGKQMINwMQIAZBIGogBkEQai\
AEQQBHIAUQDiAGQSBqQQhqKAIAIQQgBigCJCECAkAgBigCICIFQQFHDQAgAiAEEAAhAgsCQCAGKAIQ\
QQRHDQAgBigCFCIDKAKQAUUNACADQQA2ApABCyAGKAIUEB5BACEDQQAhASAFDQEMAgsCQCADQSRJDQ\
AgAxABCwtBASEBIAIhAwsgACABNgIMIAAgAzYCCCAAIAQ2AgQgACACNgIAIAZBMGokAAvjAQEHfyMA\
QRBrIgIkACABEAIhAyABEAMhBCABEAQhBQJAAkAgA0GBgARJDQBBACEGIAMhBwNAIAIgBSAEIAZqIA\
dBgIAEIAdBgIAESRsQBSIIED4CQCAIQSRJDQAgCBABCyAAIAIoAgAiCCACKAIIEA8gBkGAgARqIQYC\
QCACKAIERQ0AIAgQHgsgB0GAgHxqIQcgAyAGSw0ADAILCyACIAEQPiAAIAIoAgAiBiACKAIIEA8gAi\
gCBEUNACAGEB4LAkAgBUEkSQ0AIAUQAQsCQCABQSRJDQAgARABCyACQRBqJAAL5QEBAn8jAEGQAWsi\
AiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EEaiIDQcAARw0ACyACQcAANgIAIA\
JByABqIAJBxAAQORogAEE4aiACQYQBaikCADcAACAAQTBqIAJB/ABqKQIANwAAIABBKGogAkH0AGop\
AgA3AAAgAEEgaiACQewAaikCADcAACAAQRhqIAJB5ABqKQIANwAAIABBEGogAkHcAGopAgA3AAAgAE\
EIaiACQdQAaikCADcAACAAIAIpAkw3AAAgACABLQBAOgBAIAJBkAFqJAALzwECA38BfiMAQSBrIgQk\
AAJAAkAgAUUNACABKAIADQFBACEFIAFBADYCACABKQIEIQcgARAeIAQgBzcDCCAEQRBqIARBCGogAk\
EARyADEA4gBEEYaigCACECIAQoAhQhAQJAIAQoAhAiA0EBRw0AIAEgAhAAIgUhAQsCQCAEKAIIQQRH\
DQAgBCgCDCIGKAKQAUUNACAGQQA2ApABCyAEKAIMEB4gACADNgIMIAAgBTYCCCAAIAI2AgQgACABNg\
IAIARBIGokAA8LEG4ACxBvAAu7AQEEfwJAIAJFDQAgAkEDcSEDQQAhBAJAIAJBf2pBA0kNACACQXxx\
IQVBACEEA0AgACAEaiICIAEgBGoiBi0AADoAACACQQFqIAZBAWotAAA6AAAgAkECaiAGQQJqLQAAOg\
AAIAJBA2ogBkEDai0AADoAACAFIARBBGoiBEcNAAsLIANFDQAgASAEaiECIAAgBGohBANAIAQgAi0A\
ADoAACACQQFqIQIgBEEBaiEEIANBf2oiAw0ACwsgAAu4AQEDfwJAIAJFDQAgAkEHcSEDQQAhBAJAIA\
JBf2pBB0kNACACQXhxIQVBACEEA0AgACAEaiICIAE6AAAgAkEHaiABOgAAIAJBBmogAToAACACQQVq\
IAE6AAAgAkEEaiABOgAAIAJBA2ogAToAACACQQJqIAE6AAAgAkEBaiABOgAAIAUgBEEIaiIERw0ACw\
sgA0UNACAAIARqIQIDQCACIAE6AAAgAkEBaiECIANBf2oiAw0ACwsgAAutAQEBfyMAQRBrIgYkAAJA\
AkAgAUUNACAGIAEgAyAEIAUgAigCEBELACAGKAIAIQMCQAJAIAYoAgQiBCAGKAIIIgFLDQAgAyECDA\
ELAkAgAUECdCIFDQBBBCECIARBAnRFDQEgAxAeDAELIAMgBRAmIgJFDQILIAAgATYCBCAAIAI2AgAg\
BkEQaiQADwtBsI/AAEEwEHAACyAFQQRBACgC+NRAIgZBBCAGGxEFAAALrgEBAn8jAEEgayIDJAAgAy\
ACNgIYIAMgAjYCFCADIAE2AhAgAyADQRBqEBVBASEEIAMoAgQhAQJAAkACQCADKAIAQQFHDQAMAQsg\
A0EIaigCACEEQQwQFiICRQ0BIAIgBDYCCCACIAE2AgRBACEBIAJBADYCAEEAIQQLIAAgBDYCCCAAIA\
E2AgQgACACNgIAIANBIGokAA8LQQxBBEEAKAL41EAiA0EEIAMbEQUAAAujAQEDfyMAQRBrIgQkAAJA\
AkAgAUUNACABKAIAIgVBf0YNASABIAVBAWo2AgBBACEFIAQgAUEEaiACQQBHIAMQDCAEQQhqKAIAIQ\
MgBCgCBCECAkAgBCgCACIGQQFHDQAgAiADEAAiBSECCyABIAEoAgBBf2o2AgAgACAGNgIMIAAgBTYC\
CCAAIAM2AgQgACACNgIAIARBEGokAA8LEG4ACxBvAAudAQEEfwJAAkACQAJAIAEQBiICQQBIDQAgAg\
0BQQEhAwwCCxBpAAsgAhAWIgNFDQELIAAgAjYCBCAAIAM2AgAQByIEEAgiBRAJIQICQCAFQSRJDQAg\
BRABCyACIAEgAxAKAkAgAkEkSQ0AIAIQAQsCQCAEQSRJDQAgBBABCyAAIAEQBjYCCA8LIAJBAUEAKA\
L41EAiAUEEIAEbEQUAAAuaAQEDfyMAQRBrIgQkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAIAQgAUEE\
aiACQQBHIAMQDiAEQQhqKAIAIQMgBCgCBCECAkACQCAEKAIAIgVBAUYNAEEAIQYMAQsgAiADEAAiBi\
ECCyABQQA2AgAgACAFNgIMIAAgBjYCCCAAIAM2AgQgACACNgIAIARBEGokAA8LEG4ACxBvAAt+AQF/\
IwBBwABrIgQkACAEQSs2AgwgBCAANgIIIAQgAjYCFCAEIAE2AhAgBEEsakECNgIAIARBPGpBATYCAC\
AEQgI3AhwgBEGYiMAANgIYIARBAjYCNCAEIARBMGo2AiggBCAEQRBqNgI4IAQgBEEIajYCMCAEQRhq\
IAMQVgALfgECfyMAQTBrIgIkACACQRRqQQI2AgAgAkG4h8AANgIQIAJBAjYCDCACQZiHwAA2AgggAU\
EcaigCACEDIAEoAhghASACQSxqQQI2AgAgAkICNwIcIAJBmIjAADYCGCACIAJBCGo2AiggASADIAJB\
GGoQKyEBIAJBMGokACABC34BAn8jAEEwayICJAAgAkEUakECNgIAIAJBuIfAADYCECACQQI2AgwgAk\
GYh8AANgIIIAFBHGooAgAhAyABKAIYIQEgAkEsakECNgIAIAJCAjcCHCACQZiIwAA2AhggAiACQQhq\
NgIoIAEgAyACQRhqECshASACQTBqJAAgAQt0AQJ/IwBBkAJrIgIkAEEAIQMgAkEANgIAA0AgAiADak\
EEaiABIANqKAAANgIAIANBBGoiA0GAAUcNAAsgAkGAATYCACACQYgBaiACQYQBEDkaIAAgAkGIAWpB\
BHJBgAEQOSABLQCAAToAgAEgAkGQAmokAAt0AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIAA0AgAiADak\
EEaiABIANqKAAANgIAIANBBGoiA0GIAUcNAAsgAkGIATYCACACQZABaiACQYwBEDkaIAAgAkGQAWpB\
BHJBiAEQOSABLQCIAToAiAEgAkGgAmokAAt0AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADak\
EEaiABIANqKAAANgIAIANBBGoiA0GoAUcNAAsgAkGoATYCACACQbABaiACQawBEDkaIAAgAkGwAWpB\
BHJBqAEQOSABLQCoAToAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADak\
EEaiABIANqKAAANgIAIANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDkaIAAgAkHQAGpB\
BHJByAAQOSABLQBIOgBIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBG\
ogASADaigAADYCACADQQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA5GiAAIAJB8ABqQQRy\
QegAEDkgAS0AaDoAaCACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIA\
EgA2ooAAA2AgAgA0EEaiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQORogACACQZgBakEEckGQ\
ARA5IAEtAJABOgCQASACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2Ag\
AgA0EsakEDNgIAIANCAjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyAD\
NgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAz\
YCACADQgI3AgwgA0GoisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhq\
IAIQVgALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNw\
IMIANB/IrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFYAC2wB\
AX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwA\
A2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBWAAtsAQF/IwBBMGsi\
AyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAz\
YCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQVgALdQECf0EBIQBBAEEAKAKA1UAi\
AUEBajYCgNVAAkACQEEAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2E\
ACQCABQQBIDQAgAEECSw0AQQAoAvzUQEF/TA0AIABBAUsNABBzAAsAC5oBACMAQTBrGiAAQgA3A0Ag\
AEE4akL5wvibkaOz8NsANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQt\
GFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcD\
CCAAIAGtQoiS95X/zPmE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgAC\
gCBCECIAAQHgJAIAJBBEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBuAAsQbwALSgEDf0EAIQMC\
QCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIA\
VrIQMLIAMLVAEBfwJAAkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAIN\
AUEAIQQLIAQPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIA\
NBoJHAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFYACzkAAkACQCABRQ0A\
IAEoAgANASABQX82AgAgAUEEaiACEDYgAUEANgIAIABCADcDAA8LEG4ACxBvAAtSACAAQsfMo9jW0O\
uzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhqQv+kuYjFkdqCm383AwAgAEEQakLy\
5rvjo6f9p6V/NwMACzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQcCHwAA2AgQgAkGgkcAANg\
IAIAIQZwALIwACQCAAQXxLDQACQCAADQBBBA8LIAAQFiIARQ0AIAAPCwALJQACQCAADQBBsI/AAEEw\
EHAACyAAIAIgAyAEIAUgASgCEBEMAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEKAA\
sjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAEGwj8AAQTAQcAALIAAg\
AiADIAQgASgCEBEKAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAE\
Gwj8AAQTAQcAALIAAgAiADIAQgASgCEBEJAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgC\
EBEVAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEWAAshAAJAIAANAEGwj8AAQTAQcA\
ALIAAgAiADIAEoAhARBwALHgAgAEEUaigCABoCQCAAQQRqKAIADgIAAAALEE4ACxwAAkACQCABQXxL\
DQAgACACECYiAQ0BCwALIAELHwACQCAADQBBsI/AAEEwEHAACyAAIAIgASgCEBEGAAsaAAJAIAANAE\
GgkcAAQStB6JHAABBTAAsgAAsUACAAKAIAIAEgACgCBCgCDBEGAAsQACABIAAoAgAgACgCBBAlCw4A\
IAAoAggQZCAAEHEACw4AAkAgAUUNACAAEB4LCxEAQYKCwABBEUGUgsAAEFMACxEAQaSCwABBL0Gkg8\
AAEFMACw0AIAAoAgAaA38MAAsLCwAgACMAaiQAIwALCwAgADUCACABEDQLDABByNLAAEEbEHAACw0A\
QePSwABBzwAQcAALCQAgACABEAsACwkAIAAgARBhAAsMAEKl8JbP5f/ppVYLAwAACwIACwIACwv+1I\
CAAAEAQYCAwAAL9FT0BRAAUAAAAJUAAAAJAAAAQkxBS0UyQkJMQUtFMkItMjU2QkxBS0UyQi0zODRC\
TEFLRTJTQkxBS0UzS0VDQ0FLLTIyNEtFQ0NBSy0yNTZLRUNDQUstMzg0S0VDQ0FLLTUxMk1ENE1ENV\
JJUEVNRC0xNjBTSEEtMVNIQS0yMjRTSEEtMjU2U0hBLTM4NFNIQS01MTJUSUdFUnVuc3VwcG9ydGVk\
IGFsZ29yaXRobW5vbi1kZWZhdWx0IGxlbmd0aCBzcGVjaWZpZWQgZm9yIG5vbi1leHRlbmRhYmxlIG\
FsZ29yaXRobWxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNjYXBhY2l0eSBvdmVyZmxvdwDmABAA\
HAAAADICAAAFAAAAQXJyYXlWZWM6IGNhcGFjaXR5IGV4Y2VlZGVkIGluIGV4dGVuZC9mcm9tX2l0ZX\
J+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2FycmF5dmVj\
LTAuNy4yL3NyYy9hcnJheXZlYy5ycwBTARAAUAAAAAEEAAAFAAAAVAYQAE0AAAABBgAACQAAAH4vLm\
NhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYmxha2UzLTEuMy4w\
L3NyYy9saWIucnMAAADEARAASQAAALkBAAAJAAAAxAEQAEkAAABfAgAACgAAAMQBEABJAAAAjQIAAA\
kAAADEARAASQAAAN0CAAAKAAAAxAEQAEkAAADWAgAACQAAAMQBEABJAAAAAQMAABkAAADEARAASQAA\
AAMDAAAJAAAAxAEQAEkAAAADAwAAOAAAAMQBEABJAAAA+AMAADIAAADEARAASQAAAKoEAAAWAAAAxA\
EQAEkAAAC8BAAAFgAAAMQBEABJAAAA7QQAABIAAADEARAASQAAAPcEAAASAAAAxAEQAEkAAABpBQAA\
IQAAABEAAAAEAAAABAAAABIAAAARAAAAIAAAAAEAAAATAAAAEQAAAAQAAAAEAAAAEgAAAH4vLmNhcm\
dvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2ZWMtMC43LjIv\
c3JjL2FycmF5dmVjX2ltcGwucnMAAAAgAxAAVQAAACcAAAAgAAAAQ2FwYWNpdHlFcnJvcgAAAIgDEA\
ANAAAAaW5zdWZmaWNpZW50IGNhcGFjaXR5AAAAoAMQABUAAAARAAAAAAAAAAEAAAAUAAAAaW5kZXgg\
b3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAANADEAAgAAAA8AMQAB\
IAAAA6IAAAoAgQAAAAAAAUBBAAAgAAACkwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2\
MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NT\
Q2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3\
NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OXJhbmdlIHN0YX\
J0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCAAAADxBBAAEgAAAAMFEAAi\
AAAAcmFuZ2UgZW5kIGluZGV4IDgFEAAQAAAAAwUQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIG\
J1dCBlbmRzIGF0IABYBRAAFgAAAG4FEAANAAAAc291cmNlIHNsaWNlIGxlbmd0aCAoKSBkb2VzIG5v\
dCBtYXRjaCBkZXN0aW5hdGlvbiBzbGljZSBsZW5ndGggKIwFEAAVAAAAoQUQACsAAAAoBBAAAQAAAF\
QGEABNAAAAEAwAAA0AAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRi\
OWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjEwLjAvc3JjL2xpYi5yc/QFEABQAAAA/AAAACcAAAAvcnVzdG\
MvZjFlZGQwNDI5NTgyZGQyOWNjY2FjYWY1MGZkMTM0YjA1NTkzYmQ5Yy9saWJyYXJ5L2NvcmUvc3Jj\
L3NsaWNlL21vZC5yc2Fzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpVAYQAE0AAAAfBg\
AACQAAAAAAAAABI0VniavN7/7cuph2VDIQ8OHSwwAAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur\
2YMfGc3gW9ieBcEH1Xw2F91wMDlZDvcxC8D/ERVYaKeP+WSkT/q+CMm882fmCWo7p8qEha5nuyv4lP\
5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gW9ieBcFdnbvLB9V8Niop\
mmIX3XAwWgFZkTlZDvfY7C8VMQvA/2cmM2cRFVhoh0q0jqeP+WQNLgzbpE/6vh1ItUdjbG9zdXJlIG\
ludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHkBAAAAAAAAAIKAAAAAAAAAioAA\
AAAAAIAAgACAAAAAgIuAAAAAAAAAAQAAgAAAAACBgACAAAAAgAmAAAAAAACAigAAAAAAAACIAAAAAA\
AAAAmAAIAAAAAACgAAgAAAAACLgACAAAAAAIsAAAAAAACAiYAAAAAAAIADgAAAAAAAgAKAAAAAAACA\
gAAAAAAAAIAKgAAAAAAAAAoAAIAAAACAgYAAgAAAAICAgAAAAAAAgAEAAIAAAAAACIAAgAAAAIBjYW\
xsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbGlicmFyeS9zdGQvc3JjL3Bh\
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\
AAAAHAAAACAAAAAwAAAAQAAAABAAAAAQAAAAFAAAABQAAAAcAAAAIAAAADAAAABAAAAAHAAAACAAAA\
AwAAAAQAAAACAAAABAAAAAGAAAAEAAAAAgAAAAMAAAACAAAAAgAAAAHAAAACAAAAAwAAAAQAAAABAA\
AAAQAAAAFAAAABQAAAAcAAAAIAAAADAAAABAAAAAHAAAACAAAAAwAAAAQAAAACAAAABAAAAAGAAAAA\
Cnt4CAAARuYW1lAZy3gIAAdgBFanNfc3lzOjpUeXBlRXJyb3I6Om5ldzo6X193YmdfbmV3X2E0YjYx\
YTBmNTQ4MjRjZmQ6OmgzNzE2N2VmMDcyNjZmMmQ1ATt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fb2\
JqZWN0X2Ryb3BfcmVmOjpoNzkzYmExMTZkNzVlMjJhMAJVanNfc3lzOjpVaW50OEFycmF5OjpieXRl\
X2xlbmd0aDo6X193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3OjpoMTNkMDIzOGI2ODlhOT\
YwYwNVanNfc3lzOjpVaW50OEFycmF5OjpieXRlX29mZnNldDo6X193YmdfYnl0ZU9mZnNldF80MjA0\
ZWNiMjRhNmU1ZGY5OjpoOGY0YmM4MWQ5MGE4MjMzZQRManNfc3lzOjpVaW50OEFycmF5OjpidWZmZX\
I6Ol9fd2JnX2J1ZmZlcl9mYWNmMDM5OGEyODFjODViOjpoMGZiNjA5YTUxNjQ3NmU5MgV5anNfc3lz\
OjpVaW50OEFycmF5OjpuZXdfd2l0aF9ieXRlX29mZnNldF9hbmRfbGVuZ3RoOjpfX3diZ19uZXd3aX\
RoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmOjpoYzI4MjE3ODU0OTVlMmE2MgZM\
anNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Ol9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiOj\
poNzNkYzkyYWJjODFkM2ZhNwcyd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX21lbW9yeTo6aDRjOWRj\
YzlmYzQzMmZlMmMIVWpzX3N5czo6V2ViQXNzZW1ibHk6Ok1lbW9yeTo6YnVmZmVyOjpfX3diZ19idW\
ZmZXJfMzk3ZWFhNGQ3MmVlOTRkZDo6aDM5ZDIzMjAwNzgzMjBiYzAJRmpzX3N5czo6VWludDhBcnJh\
eTo6bmV3OjpfX3diZ19uZXdfYTdjZTQ0N2YxNWZmNDk2Zjo6aDZjZjg5NDdiODY4ZmRlZWYKRmpzX3\
N5czo6VWludDhBcnJheTo6c2V0OjpfX3diZ19zZXRfOTY5YWQwYTYwZTUxZDMyMDo6aDUxN2Q1OGEy\
M2QyYjc4MTkLMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDY5MTE5ZDhjZWJhYTQ0M2\
YMQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdDo6aDgyOGE3MDEx\
NDE1ZjA1MjANLHNoYTI6OnNoYTUxMjo6Y29tcHJlc3M1MTI6Omg2YjEwYzMzYWQwNWMzNWY2DkpkZW\
5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3RfYW5kX3Jlc2V0OjpoZjlk\
NDIwYzUyNDhhOTJmNg9AZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBkYX\
RlOjpoMWFhNzQ2YmE5ZTJlMTdhNRAsc2hhMjo6c2hhMjU2Ojpjb21wcmVzczI1Njo6aGU4NzgwMjlj\
Y2ZkZDNkZjQRM2JsYWtlMjo6Qmxha2UyYlZhckNvcmU6OmNvbXByZXNzOjpoOWY4N2E3NmE4ZmJlZT\
IyYhIpcmlwZW1kOjpjMTYwOjpjb21wcmVzczo6aDE4OWM0NzlmYmQ2N2FmYWQTM2JsYWtlMjo6Qmxh\
a2Uyc1ZhckNvcmU6OmNvbXByZXNzOjpoOWRkYTljMmEyYjYxNzY4ORQrc2hhMTo6Y29tcHJlc3M6Om\
NvbXByZXNzOjpoNTBlNWQ4M2U5MWQ2NTRhYRU7ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENv\
bnRleHQ6Om5ldzo6aGY0NjA2NTg2NmYzZDY2NjAWOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2\
M8QT46Om1hbGxvYzo6aDJhMjcyMDdlZTlhZjdmZTkXLHRpZ2VyOjpjb21wcmVzczo6Y29tcHJlc3M6\
Omg2ZDI1OGZiZjc1NDhiZmUxGC1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aGE5YzI3MGM5Yj\
dmZjQxZWUZNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoYzRhZDc0NzdjYmY1\
MmYwZRoTZGlnZXN0Y29udGV4dF9jbG9uZRtlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcm\
VXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGU3N2Fm\
YjMxMmY4OGY0MzccaDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdX\
RDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06Omg3OThjNzA3YzdjZGEzNTky\
HTBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aDk5NWY5MmEwOTlkOTg2MzQeOGRsbWFsbG\
9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhjYjc5NDdhOWE3ZTI4MmNhHyBtZDQ6OmNv\
bXByZXNzOjpoOTBkNTQwMzZjYTYzM2UzYyBBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPj\
o6ZGlzcG9zZV9jaHVuazo6aDJmOTBiZGRmYWI5ZmRhZjkhE2RpZ2VzdGNvbnRleHRfcmVzZXQicjxz\
aGEyOjpjb3JlX2FwaTo6U2hhNTEyVmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU\
91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoOWVhNGEyMTU4ZTA3MDMzYiMvYmxh\
a2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aGI4ODNlNmM1YzRlNWQ0MGIkIGtlY2Nhazo6ZjE2MD\
A6OmhhODI1NzkwY2YyNWE1ZjVlJSxjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkOjpoNDlkMmNmY2Nh\
ZmJiZGU0ZCYOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcy\
BkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9j\
b3JlOjpoMDNhOTMwYjhjNzRjOWVkNShdPHNoYTE6OlNoYTFDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcG\
k6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiNWQ5ZWM3MDI0OGUxODIw\
KTFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg0N2I2ZTI0ZTY3ZTIxNjViKjVjb3JlOj\
pmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoYzY2OTQ3YjFkZWQ1NzhhYSsjY29yZTo6Zm10\
Ojp3cml0ZTo6aGJiYWYzOWYwOWJmNDllZmIsNGJsYWtlMzo6Y29tcHJlc3NfcGFyZW50c19wYXJhbG\
xlbDo6aGEwNzMyZmFjYjEyNzY5YmItZDxyaXBlbWQ6OlJpcGVtZDE2MENvcmUgYXMgZGlnZXN0Ojpj\
b3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGRlOGZjMmFmNz\
ExZjE4NWYuWzxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3Jl\
Pjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDBiMzAwM2U0ODQyOWFjM2QvWzxtZDQ6Ok1kNENvcmUgYX\
MgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6\
aDNlMmIzMDA3MzBhYThhZjAwXzx0aWdlcjo6VGlnZXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6Ok\
ZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg0NTczYTQwZWJjNTRjYTUzMWU8\
ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZG\
lnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoZTUwZWUyZjliMmYyYmQ0YTJlPGRpZ2VzdDo6Y29yZV9h\
cGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZG\
VyPjo6cmVhZDo6aDZkN2E3MzhlNTE0MWViZTAzLWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpo\
YzU4OGE4Y2Q3YzI2Y2VmNTQvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3Mj\
I3ZTg1NTM1BmRpZ2VzdDY+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0\
ZTo6aDEzYWE5MGI2YzVlZGM0ODY3WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZS\
xLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDU2ZDNhMWQ5YzZmOTE3YmU4G2Rp\
Z2VzdGNvbnRleHRfZGlnZXN0QW5kRHJvcDkGbWVtY3B5OgZtZW1zZXQ7P3dhc21fYmluZGdlbjo6Y2\
9udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDk2N2Y0MzRjNzJmNGU0MjwRZGlnZXN0Y29u\
dGV4dF9uZXc9FGRpZ2VzdGNvbnRleHRfZGlnZXN0Pi1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYz\
o6aDYzOWJmOTBlOTEwZTgxZDQ/HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXRALmNvcmU6OnJl\
c3VsdDo6dW53cmFwX2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZBUDxhcnJheXZlYzo6ZXJyb3JzOj\
pDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMy\
MjI5QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYn\
VnPjo6Zm10OjpoYWJkMmI2NDNkZDBlY2QyY0NbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8Qmxv\
Y2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMDhkN2U1MzhlNjI5MD\
QzOERbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNs\
b25lOjpDbG9uZT46OmNsb25lOjpoODc3ODZlMzY2MmMyNmQ2NEVbPGJsb2NrX2J1ZmZlcjo6QmxvY2\
tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNWEx\
YTExYjkwNmU5M2QwM0ZbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IG\
FzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNDUyMGIyMWMwYzI5ODk4Y0dbPGJsb2NrX2J1\
ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46Om\
Nsb25lOjpoYzQ4ZjUyNTk0NDZjMmVlY0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tT\
aXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMWM0ZTBjNjhlY2Q2NmI1NE\
k/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4\
NjZlMWJlSkFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNm\
MxMDlhYzg1ODdmMjkxMUs9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWls\
OjpoZDI3ZGMzODVhN2VjMTNjMUxOY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbG\
ljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTTZjb3JlOjpwYW5pY2tpbmc6\
OnBhbmljX2JvdW5kc19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhON3N0ZDo6cGFuaWNraW5nOjpydX\
N0X3BhbmljX3dpdGhfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThPOmJsYWtlMjo6Qmxha2UyYlZhckNv\
cmU6Om5ld193aXRoX3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRQGF9fd2JnX2RpZ2VzdGNvbnRleH\
RfZnJlZVEGbWVtY21wUkNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9w\
cmVmaXg6OmhhYTBhZGYwMGNiNjdkZWQ3Uyljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNT\
diZDBiYWYwYlQUZGlnZXN0Y29udGV4dF91cGRhdGVVOmJsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6Om5l\
d193aXRoX3BhcmFtczo6aDVmZjQ1OWYyMzFhYjhkNjhWLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm\
10OjpoNjMxNGI1YzkxYWJlNzM0OVcRX193YmluZGdlbl9tYWxsb2NYP3dhc21fYmluZGdlbjo6Y29u\
dmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoMDhiMDAxNWQ0NTZmMjBjN1k/d2FzbV9iaW5kZ2\
VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYWI0ZThkMTgzNDk0OWU4Wj93YXNt\
X2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDBlZmUyNDJjN2Q3ZmU2MG\
VbP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYzRhYTBlM2Vm\
MWQ2ZDdhMVw/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3OT\
lhYmFiYmRjZDEyZmEzXT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211\
dDo6aGE5NDFjMTBjNDA4ODhjNTBeP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm\
9rZTNfbXV0OjpoMTE4OWQ1YjVlY2U4MjQxYV8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJl\
czo6aW52b2tlM19tdXQ6OmhiZGM0ZjBhM2ViZGQ5MDg2YD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6Om\
Nsb3N1cmVzOjppbnZva2UyX211dDo6aGE2NDc2YjFhNTZlZDFhYjZhQ3N0ZDo6cGFuaWNraW5nOjpi\
ZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFiEl9fd2Jpbm\
RnZW5fcmVhbGxvY2M/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6\
OmgwNzE4MzRjY2I3MGRmNzI1ZDJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZG\
Y5MWI1ZDYwOTBjYmUwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFh\
MWVmZjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGcRcn\
VzdF9iZWdpbl91bndpbmRoD19fd2JpbmRnZW5fZnJlZWk0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5\
X292ZXJmbG93OjpoNGI0OTAxNDgzMGNhZmU2M2ozYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcG\
FuaWM6OmgzN2Q1OThkNzVkMGQyZTZmazljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxf\
b25jZTo6aDJhYjg2NzY3ZWMxN2M1MGRsH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJtTm\
NvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10\
OjpoMDQ2ZWNjNWVhYWIzNGNkNW4xd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoM2Q3Yj\
Q3NDgzNGRkZjJkOW8yd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aGU1Njk3Y2E4ZTIx\
ZWQ1YTVwKndhc21fYmluZGdlbjo6dGhyb3dfc3RyOjpoNWViNDYxODBmZTVlMWQxYXFJc3RkOjpzeX\
NfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAy\
YThiNzBmZHIxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYTBjNDQ5MjIxNmQ0ZDJlN3\
MKcnVzdF9wYW5pY3Q3c3RkOjphbGxvYzo6ZGVmYXVsdF9hbGxvY19lcnJvcl9ob29rOjpoZjljMzkz\
YmEzY2QyODdlMXVvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVycz\
o6Y29waWVkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46Omg2M2MyZTE0OTdi\
NTJmM2Q3AO+AgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdG\
MdMS41Ny4wIChmMWVkZDA0MjkgMjAyMS0xMS0yOSkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4G\
MC4yLjgx\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i6 = 0; i6 < size; i6++){
        bytes[i6] = binString.charCodeAt(i6);
    }
    return bytes;
}
const digestAlgorithms = [
    "BLAKE2B-256",
    "BLAKE2B-384",
    "BLAKE2B",
    "BLAKE2S",
    "BLAKE3",
    "KECCAK-224",
    "KECCAK-256",
    "KECCAK-384",
    "KECCAK-512",
    "SHA-384",
    "SHA3-224",
    "SHA3-256",
    "SHA3-384",
    "SHA3-512",
    "SHAKE128",
    "SHAKE256",
    "TIGER",
    "RIPEMD-160",
    "SHA-224",
    "SHA-256",
    "SHA-512",
    "MD4",
    "MD5",
    "SHA-1", 
];
var DiffType;
(function(DiffType2) {
    DiffType2["removed"] = "removed";
    DiffType2["common"] = "common";
    DiffType2["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert1(expr, msg17 = "") {
    if (!expr) {
        throw new AssertionError(msg17);
    }
}
function timingSafeEqual(a1, b1) {
    if (a1.byteLength !== b1.byteLength) {
        return false;
    }
    if (!(a1 instanceof DataView)) {
        a1 = new DataView(ArrayBuffer.isView(a1) ? a1.buffer : a1);
    }
    if (!(b1 instanceof DataView)) {
        b1 = new DataView(ArrayBuffer.isView(b1) ? b1.buffer : b1);
    }
    assert1(a1 instanceof DataView);
    assert1(b1 instanceof DataView);
    const length = a1.byteLength;
    let out = 0;
    let i7 = -1;
    while(++i7 < length){
        out |= a1.getUint8(i7) ^ b1.getUint8(i7);
    }
    return out === 0;
}
function swap32(val) {
    return (val & 0xff) << 24 | (val & 0xff00) << 8 | val >> 8 & 0xff00 | val >> 24 & 0xff;
}
function n16(n1) {
    return n1 & 0xffff;
}
function n32(n2) {
    return n2 >>> 0;
}
function add32WithCarry(a2, b2) {
    const added = n32(a2) + n32(b2);
    return [
        n32(added),
        added > 0xffffffff ? 1 : 0
    ];
}
function mul32WithCarry(a3, b3) {
    const al = n16(a3);
    const ah = n16(a3 >>> 16);
    const bl = n16(b3);
    const bh = n16(b3 >>> 16);
    const [t1, tc] = add32WithCarry(al * bh, ah * bl);
    const [n3, nc] = add32WithCarry(al * bl, n32(t1 << 16));
    const carry = nc + (tc << 16) + n16(t1 >>> 16) + ah * bh;
    return [
        n3,
        carry
    ];
}
function mul32(a4, b4) {
    const al = n16(a4);
    const ah = a4 - al;
    return n32(n32(ah * b4) + al * b4);
}
function mul64([ah, al], [bh, bl]) {
    const [n4, c2] = mul32WithCarry(al, bl);
    return [
        n32(mul32(al, bh) + mul32(ah, bl) + c2),
        n4
    ];
}
const prime32 = 16777619;
const fnv32 = (data)=>{
    let hash = 2166136261;
    data.forEach((c3)=>{
        hash = mul32(hash, prime32);
        hash ^= c3;
    });
    return Uint32Array.from([
        swap32(hash)
    ]).buffer;
};
const fnv32a = (data)=>{
    let hash = 2166136261;
    data.forEach((c4)=>{
        hash ^= c4;
        hash = mul32(hash, prime32);
    });
    return Uint32Array.from([
        swap32(hash)
    ]).buffer;
};
const prime64Lo = 435;
const prime64Hi = 256;
const fnv64 = (data)=>{
    let hashLo = 2216829733;
    let hashHi = 3421674724;
    data.forEach((c5)=>{
        [hashHi, hashLo] = mul64([
            hashHi,
            hashLo
        ], [
            prime64Hi,
            prime64Lo
        ]);
        hashLo ^= c5;
    });
    return new Uint32Array([
        swap32(hashHi >>> 0),
        swap32(hashLo >>> 0)
    ]).buffer;
};
const fnv64a = (data)=>{
    let hashLo = 2216829733;
    let hashHi = 3421674724;
    data.forEach((c6)=>{
        hashLo ^= c6;
        [hashHi, hashLo] = mul64([
            hashHi,
            hashLo
        ], [
            prime64Hi,
            prime64Lo
        ]);
    });
    return new Uint32Array([
        swap32(hashHi >>> 0),
        swap32(hashLo >>> 0)
    ]).buffer;
};
const fnv = (name, buf)=>{
    if (!buf) {
        throw new TypeError("no data provided for hashing");
    }
    switch(name){
        case "FNV32":
            return fnv32(buf);
        case "FNV64":
            return fnv64(buf);
        case "FNV32A":
            return fnv32a(buf);
        case "FNV64A":
            return fnv64a(buf);
        default:
            throw new TypeError(`unsupported fnv digest: ${name}`);
    }
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i8;
    const l1 = uint8.length;
    for(i8 = 2; i8 < l1; i8 += 3){
        result += base64abc[uint8[i8 - 2] >> 2];
        result += base64abc[(uint8[i8 - 2] & 0x03) << 4 | uint8[i8 - 1] >> 4];
        result += base64abc[(uint8[i8 - 1] & 0x0f) << 2 | uint8[i8] >> 6];
        result += base64abc[uint8[i8] & 0x3f];
    }
    if (i8 === l1 + 1) {
        result += base64abc[uint8[i8 - 2] >> 2];
        result += base64abc[(uint8[i8 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i8 === l1) {
        result += base64abc[uint8[i8 - 2] >> 2];
        result += base64abc[(uint8[i8 - 2] & 0x03) << 4 | uint8[i8 - 1] >> 4];
        result += base64abc[(uint8[i8 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i9 = 0; i9 < size; i9++){
        bytes[i9] = binString.charCodeAt(i9);
    }
    return bytes;
}
const mod1 = {
    encode: encode,
    decode: decode
};
new TextEncoder();
const webCrypto = ((crypto)=>({
        getRandomValues: crypto.getRandomValues?.bind(crypto),
        randomUUID: crypto.randomUUID?.bind(crypto),
        subtle: {
            decrypt: crypto.subtle?.decrypt?.bind(crypto.subtle),
            deriveBits: crypto.subtle?.deriveBits?.bind(crypto.subtle),
            deriveKey: crypto.subtle?.deriveKey?.bind(crypto.subtle),
            digest: crypto.subtle?.digest?.bind(crypto.subtle),
            encrypt: crypto.subtle?.encrypt?.bind(crypto.subtle),
            exportKey: crypto.subtle?.exportKey?.bind(crypto.subtle),
            generateKey: crypto.subtle?.generateKey?.bind(crypto.subtle),
            importKey: crypto.subtle?.importKey?.bind(crypto.subtle),
            sign: crypto.subtle?.sign?.bind(crypto.subtle),
            unwrapKey: crypto.subtle?.unwrapKey?.bind(crypto.subtle),
            verify: crypto.subtle?.verify?.bind(crypto.subtle),
            wrapKey: crypto.subtle?.wrapKey?.bind(crypto.subtle)
        }
    }))(globalThis.crypto);
const bufferSourceBytes = (data)=>{
    let bytes;
    if (data instanceof Uint8Array) {
        bytes = data;
    } else if (ArrayBuffer.isView(data)) {
        bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        bytes = new Uint8Array(data);
    }
    return bytes;
};
const stdCrypto = ((x2)=>x2)({
    ...webCrypto,
    subtle: {
        ...webCrypto.subtle,
        async digest (algorithm, data) {
            const { name , length  } = normalizeAlgorithm(algorithm);
            const bytes = bufferSourceBytes(data);
            if (FNVAlgorithms.includes(name)) {
                return fnv(name, bytes);
            }
            if (webCryptoDigestAlgorithms.includes(name) && bytes) {
                return webCrypto.subtle.digest(algorithm, bytes);
            } else if (digestAlgorithms.includes(name)) {
                if (bytes) {
                    return stdCrypto.subtle.digestSync(algorithm, bytes);
                } else if (data[Symbol.iterator]) {
                    return stdCrypto.subtle.digestSync(algorithm, data);
                } else if (data[Symbol.asyncIterator]) {
                    const wasmCrypto = instantiate();
                    const context = new wasmCrypto.DigestContext(name);
                    for await (const chunk of data){
                        const chunkBytes = bufferSourceBytes(chunk);
                        if (!chunkBytes) {
                            throw new TypeError("data contained chunk of the wrong type");
                        }
                        context.update(chunkBytes);
                    }
                    return context.digestAndDrop(length).buffer;
                } else {
                    throw new TypeError("data must be a BufferSource or [Async]Iterable<BufferSource>");
                }
            } else if (webCrypto.subtle?.digest) {
                return webCrypto.subtle.digest(algorithm, data);
            } else {
                throw new TypeError(`unsupported digest algorithm: ${algorithm}`);
            }
        },
        digestSync (algorithm, data) {
            algorithm = normalizeAlgorithm(algorithm);
            const bytes = bufferSourceBytes(data);
            if (FNVAlgorithms.includes(algorithm.name)) {
                return fnv(algorithm.name, bytes);
            }
            const wasmCrypto = instantiate();
            if (bytes) {
                return wasmCrypto.digest(algorithm.name, bytes, algorithm.length).buffer;
            } else if (data[Symbol.iterator]) {
                const context = new wasmCrypto.DigestContext(algorithm.name);
                for (const chunk of data){
                    const chunkBytes = bufferSourceBytes(chunk);
                    if (!chunkBytes) {
                        throw new TypeError("data contained chunk of the wrong type");
                    }
                    context.update(chunkBytes);
                }
                return context.digestAndDrop(algorithm.length).buffer;
            } else {
                throw new TypeError("data must be a BufferSource or Iterable<BufferSource>");
            }
        },
        timingSafeEqual
    }
});
const FNVAlgorithms = [
    "FNV32",
    "FNV32A",
    "FNV64",
    "FNV64A"
];
const webCryptoDigestAlgorithms = [
    "SHA-384",
    "SHA-256",
    "SHA-512",
    "SHA-1", 
];
const normalizeAlgorithm = (algorithm)=>typeof algorithm === "string" ? {
        name: algorithm.toUpperCase()
    } : {
        ...algorithm,
        name: algorithm.name.toUpperCase()
    };
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path4) {
    if (typeof path4 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path4)}`);
    }
}
function isPosixPathSeparator(code3) {
    return code3 === 47;
}
function isPathSeparator(code4) {
    return isPosixPathSeparator(code4) || code4 === 92;
}
function isWindowsDeviceRoot(code5) {
    return code5 >= 97 && code5 <= 122 || code5 >= 65 && code5 <= 90;
}
function normalizeString(path5, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code6;
    for(let i10 = 0, len = path5.length; i10 <= len; ++i10){
        if (i10 < len) code6 = path5.charCodeAt(i10);
        else if (isPathSeparator1(code6)) break;
        else code6 = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code6)) {
            if (lastSlash === i10 - 1 || dots === 1) {} else if (lastSlash !== i10 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i10;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i10;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path5.slice(lastSlash + 1, i10);
                else res = path5.slice(lastSlash + 1, i10);
                lastSegmentLength = i10 - lastSlash - 1;
            }
            lastSlash = i10;
            dots = 0;
        } else if (code6 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep6, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep6 + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c7)=>{
        return WHITESPACE_ENCODINGS[c7] ?? c7;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i11 = pathSegments.length - 1; i11 >= -1; i11--){
        let path6;
        const { Deno  } = globalThis;
        if (i11 >= 0) {
            path6 = pathSegments[i11];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path6 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path6 = Deno.cwd();
            if (path6 === undefined || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path6 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path6);
        const len = path6.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code7 = path6.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code7)) {
                isAbsolute1 = true;
                if (isPathSeparator(path6.charCodeAt(1))) {
                    let j1 = 2;
                    let last = j1;
                    for(; j1 < len; ++j1){
                        if (isPathSeparator(path6.charCodeAt(j1))) break;
                    }
                    if (j1 < len && j1 !== last) {
                        const firstPart = path6.slice(last, j1);
                        last = j1;
                        for(; j1 < len; ++j1){
                            if (!isPathSeparator(path6.charCodeAt(j1))) break;
                        }
                        if (j1 < len && j1 !== last) {
                            last = j1;
                            for(; j1 < len; ++j1){
                                if (isPathSeparator(path6.charCodeAt(j1))) break;
                            }
                            if (j1 === len) {
                                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                                rootEnd = j1;
                            } else if (j1 !== last) {
                                device = `\\\\${firstPart}\\${path6.slice(last, j1)}`;
                                rootEnd = j1;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code7)) {
                if (path6.charCodeAt(1) === 58) {
                    device = path6.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path6.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code7)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path7) {
    assertPath(path7);
    const len = path7.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code8 = path7.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code8)) {
            isAbsolute2 = true;
            if (isPathSeparator(path7.charCodeAt(1))) {
                let j2 = 2;
                let last = j2;
                for(; j2 < len; ++j2){
                    if (isPathSeparator(path7.charCodeAt(j2))) break;
                }
                if (j2 < len && j2 !== last) {
                    const firstPart = path7.slice(last, j2);
                    last = j2;
                    for(; j2 < len; ++j2){
                        if (!isPathSeparator(path7.charCodeAt(j2))) break;
                    }
                    if (j2 < len && j2 !== last) {
                        last = j2;
                        for(; j2 < len; ++j2){
                            if (isPathSeparator(path7.charCodeAt(j2))) break;
                        }
                        if (j2 === len) {
                            return `\\\\${firstPart}\\${path7.slice(last)}\\`;
                        } else if (j2 !== last) {
                            device = `\\\\${firstPart}\\${path7.slice(last, j2)}`;
                            rootEnd = j2;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code8)) {
            if (path7.charCodeAt(1) === 58) {
                device = path7.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path7.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code8)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path7.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path7.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path8) {
    assertPath(path8);
    const len = path8.length;
    if (len === 0) return false;
    const code9 = path8.charCodeAt(0);
    if (isPathSeparator(code9)) {
        return true;
    } else if (isWindowsDeviceRoot(code9)) {
        if (len > 2 && path8.charCodeAt(1) === 58) {
            if (isPathSeparator(path8.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i12 = 0; i12 < pathsCount; ++i12){
        const path9 = paths[i12];
        assertPath(path9);
        if (path9.length > 0) {
            if (joined === undefined) joined = firstPart = path9;
            else joined += `\\${path9}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i13 = 0;
    for(; i13 <= length; ++i13){
        if (i13 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i13) === 92) {
                    return toOrig.slice(toStart + i13 + 1);
                } else if (i13 === 2) {
                    return toOrig.slice(toStart + i13);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i13) === 92) {
                    lastCommonSep = i13;
                } else if (i13 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i13);
        const toCode = to.charCodeAt(toStart + i13);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i13;
    }
    if (i13 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i13 = fromStart + lastCommonSep + 1; i13 <= fromEnd; ++i13){
        if (i13 === fromEnd || from.charCodeAt(i13) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path10) {
    if (typeof path10 !== "string") return path10;
    if (path10.length === 0) return "";
    const resolvedPath = resolve(path10);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code10 = resolvedPath.charCodeAt(2);
                if (code10 !== 63 && code10 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path10;
}
function dirname(path11) {
    assertPath(path11);
    const len = path11.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code11 = path11.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code11)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path11.charCodeAt(1))) {
                let j3 = 2;
                let last = j3;
                for(; j3 < len; ++j3){
                    if (isPathSeparator(path11.charCodeAt(j3))) break;
                }
                if (j3 < len && j3 !== last) {
                    last = j3;
                    for(; j3 < len; ++j3){
                        if (!isPathSeparator(path11.charCodeAt(j3))) break;
                    }
                    if (j3 < len && j3 !== last) {
                        last = j3;
                        for(; j3 < len; ++j3){
                            if (isPathSeparator(path11.charCodeAt(j3))) break;
                        }
                        if (j3 === len) {
                            return path11;
                        }
                        if (j3 !== last) {
                            rootEnd = offset = j3 + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code11)) {
            if (path11.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path11.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code11)) {
        return path11;
    }
    for(let i14 = len - 1; i14 >= offset; --i14){
        if (isPathSeparator(path11.charCodeAt(i14))) {
            if (!matchedSlash) {
                end = i14;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path11.slice(0, end);
}
function basename(path12, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path12);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i15;
    if (path12.length >= 2) {
        const drive = path12.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path12.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path12.length) {
        if (ext.length === path12.length && ext === path12) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i15 = path12.length - 1; i15 >= start; --i15){
            const code12 = path12.charCodeAt(i15);
            if (isPathSeparator(code12)) {
                if (!matchedSlash) {
                    start = i15 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i15 + 1;
                }
                if (extIdx >= 0) {
                    if (code12 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i15;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path12.length;
        return path12.slice(start, end);
    } else {
        for(i15 = path12.length - 1; i15 >= start; --i15){
            if (isPathSeparator(path12.charCodeAt(i15))) {
                if (!matchedSlash) {
                    start = i15 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i15 + 1;
            }
        }
        if (end === -1) return "";
        return path12.slice(start, end);
    }
}
function extname(path13) {
    assertPath(path13);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path13.length >= 2 && path13.charCodeAt(1) === 58 && isWindowsDeviceRoot(path13.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i16 = path13.length - 1; i16 >= start; --i16){
        const code13 = path13.charCodeAt(i16);
        if (isPathSeparator(code13)) {
            if (!matchedSlash) {
                startPart = i16 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i16 + 1;
        }
        if (code13 === 46) {
            if (startDot === -1) startDot = i16;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path13.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path14) {
    assertPath(path14);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path14.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code14 = path14.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code14)) {
            rootEnd = 1;
            if (isPathSeparator(path14.charCodeAt(1))) {
                let j4 = 2;
                let last = j4;
                for(; j4 < len; ++j4){
                    if (isPathSeparator(path14.charCodeAt(j4))) break;
                }
                if (j4 < len && j4 !== last) {
                    last = j4;
                    for(; j4 < len; ++j4){
                        if (!isPathSeparator(path14.charCodeAt(j4))) break;
                    }
                    if (j4 < len && j4 !== last) {
                        last = j4;
                        for(; j4 < len; ++j4){
                            if (isPathSeparator(path14.charCodeAt(j4))) break;
                        }
                        if (j4 === len) {
                            rootEnd = j4;
                        } else if (j4 !== last) {
                            rootEnd = j4 + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code14)) {
            if (path14.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path14.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path14;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path14;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code14)) {
        ret.root = ret.dir = path14;
        return ret;
    }
    if (rootEnd > 0) ret.root = path14.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i17 = path14.length - 1;
    let preDotState = 0;
    for(; i17 >= rootEnd; --i17){
        code14 = path14.charCodeAt(i17);
        if (isPathSeparator(code14)) {
            if (!matchedSlash) {
                startPart = i17 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i17 + 1;
        }
        if (code14 === 46) {
            if (startDot === -1) startDot = i17;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path14.slice(startPart, end);
        }
    } else {
        ret.name = path14.slice(startPart, startDot);
        ret.base = path14.slice(startPart, end);
        ret.ext = path14.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path14.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path15 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path15 = `\\\\${url.hostname}${path15}`;
    }
    return path15;
}
function toFileUrl(path16) {
    if (!isAbsolute(path16)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname1, pathname] = path16.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname1 != null && hostname1 != "localhost") {
        url.hostname = hostname1;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i18 = pathSegments.length - 1; i18 >= -1 && !resolvedAbsolute; i18--){
        let path17;
        if (i18 >= 0) path17 = pathSegments[i18];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path17 = Deno.cwd();
        }
        assertPath(path17);
        if (path17.length === 0) {
            continue;
        }
        resolvedPath = `${path17}/${resolvedPath}`;
        resolvedAbsolute = path17.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path18) {
    assertPath(path18);
    if (path18.length === 0) return ".";
    const isAbsolute1 = path18.charCodeAt(0) === 47;
    const trailingSeparator = path18.charCodeAt(path18.length - 1) === 47;
    path18 = normalizeString(path18, !isAbsolute1, "/", isPosixPathSeparator);
    if (path18.length === 0 && !isAbsolute1) path18 = ".";
    if (path18.length > 0 && trailingSeparator) path18 += "/";
    if (isAbsolute1) return `/${path18}`;
    return path18;
}
function isAbsolute1(path19) {
    assertPath(path19);
    return path19.length > 0 && path19.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i19 = 0, len = paths.length; i19 < len; ++i19){
        const path20 = paths[i19];
        assertPath(path20);
        if (path20.length > 0) {
            if (!joined) joined = path20;
            else joined += `/${path20}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i20 = 0;
    for(; i20 <= length; ++i20){
        if (i20 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i20) === 47) {
                    return to.slice(toStart + i20 + 1);
                } else if (i20 === 0) {
                    return to.slice(toStart + i20);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i20) === 47) {
                    lastCommonSep = i20;
                } else if (i20 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i20);
        const toCode = to.charCodeAt(toStart + i20);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i20;
    }
    let out = "";
    for(i20 = fromStart + lastCommonSep + 1; i20 <= fromEnd; ++i20){
        if (i20 === fromEnd || from.charCodeAt(i20) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path21) {
    return path21;
}
function dirname1(path22) {
    assertPath(path22);
    if (path22.length === 0) return ".";
    const hasRoot = path22.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i21 = path22.length - 1; i21 >= 1; --i21){
        if (path22.charCodeAt(i21) === 47) {
            if (!matchedSlash) {
                end = i21;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path22.slice(0, end);
}
function basename1(path23, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path23);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i22;
    if (ext !== undefined && ext.length > 0 && ext.length <= path23.length) {
        if (ext.length === path23.length && ext === path23) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i22 = path23.length - 1; i22 >= 0; --i22){
            const code15 = path23.charCodeAt(i22);
            if (code15 === 47) {
                if (!matchedSlash) {
                    start = i22 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i22 + 1;
                }
                if (extIdx >= 0) {
                    if (code15 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i22;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path23.length;
        return path23.slice(start, end);
    } else {
        for(i22 = path23.length - 1; i22 >= 0; --i22){
            if (path23.charCodeAt(i22) === 47) {
                if (!matchedSlash) {
                    start = i22 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i22 + 1;
            }
        }
        if (end === -1) return "";
        return path23.slice(start, end);
    }
}
function extname1(path24) {
    assertPath(path24);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i23 = path24.length - 1; i23 >= 0; --i23){
        const code16 = path24.charCodeAt(i23);
        if (code16 === 47) {
            if (!matchedSlash) {
                startPart = i23 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i23 + 1;
        }
        if (code16 === 46) {
            if (startDot === -1) startDot = i23;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path24.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path25) {
    assertPath(path25);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path25.length === 0) return ret;
    const isAbsolute2 = path25.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i24 = path25.length - 1;
    let preDotState = 0;
    for(; i24 >= start; --i24){
        const code17 = path25.charCodeAt(i24);
        if (code17 === 47) {
            if (!matchedSlash) {
                startPart = i24 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i24 + 1;
        }
        if (code17 === 46) {
            if (startDot === -1) startDot = i24;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path25.slice(1, end);
            } else {
                ret.base = ret.name = path25.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path25.slice(1, startDot);
            ret.base = path25.slice(1, end);
        } else {
            ret.name = path25.slice(startPart, startDot);
            ret.base = path25.slice(startPart, end);
        }
        ret.ext = path25.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path25.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path26) {
    if (!isAbsolute1(path26)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path26.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const SEP = isWindows ? "\\" : "/";
const SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
const path = isWindows ? mod2 : mod3;
const { join: join2 , normalize: normalize2  } = path;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|", 
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os =osType , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep7 = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j5 = 0; j5 < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i25 = j5;
        for(; i25 < glob.length && !seps.includes(glob[i25]); i25++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i25]) ? `\\${glob[i25]}` : glob[i25];
                continue;
            }
            if (glob[i25] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i25] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i25 + 1] == "!") {
                        i25++;
                        segment += "^";
                    } else if (glob[i25 + 1] == "^") {
                        i25++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i25 + 1] == ":") {
                    let k1 = i25 + 1;
                    let value2 = "";
                    while(glob[k1 + 1] != null && glob[k1 + 1] != ":"){
                        value2 += glob[k1 + 1];
                        k1++;
                    }
                    if (glob[k1 + 1] == ":" && glob[k1 + 2] == "]") {
                        i25 = k1 + 2;
                        if (value2 == "alnum") segment += "\\dA-Za-z";
                        else if (value2 == "alpha") segment += "A-Za-z";
                        else if (value2 == "ascii") segment += "\x00-\x7F";
                        else if (value2 == "blank") segment += "\t ";
                        else if (value2 == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value2 == "digit") segment += "\\d";
                        else if (value2 == "graph") segment += "\x21-\x7E";
                        else if (value2 == "lower") segment += "a-z";
                        else if (value2 == "print") segment += "\x20-\x7E";
                        else if (value2 == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value2 == "space") segment += "\\s\v";
                        else if (value2 == "upper") segment += "A-Z";
                        else if (value2 == "word") segment += "\\w";
                        else if (value2 == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i25] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i25] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i25];
                }
                continue;
            }
            if (glob[i25] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i25] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i25] == "+" && extended && glob[i25 + 1] == "(") {
                i25++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i25] == "@" && extended && glob[i25 + 1] == "(") {
                i25++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i25] == "?") {
                if (extended && glob[i25 + 1] == "(") {
                    i25++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i25] == "!" && extended && glob[i25 + 1] == "(") {
                i25++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i25] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i25] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i25] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i25] == "*") {
                if (extended && glob[i25 + 1] == "(") {
                    i25++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i25 - 1];
                    let numStars = 1;
                    while(glob[i25 + 1] == "*"){
                        i25++;
                        numStars++;
                    }
                    const nextChar = glob[i25 + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i25]) ? `\\${glob[i25]}` : glob[i25];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c8 of glob.slice(j5, i25)){
                segment += regExpEscapeChars.includes(c8) ? `\\${c8}` : c8;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i25 < glob.length ? sep7 : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i25]))i25++;
        if (!(i25 > j5)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j5 = i25;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str6) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str6 === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str6)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n5 = str6.indexOf(close, idx);
            if (n5 !== -1) {
                idx = n5 + 1;
            }
        }
        str6 = str6.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize2(glob);
    }
    const s2 = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s2}|^)\\*\\*${s2})\\.\\.(?=${s2}|$)`, "g");
    return normalize2(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join2(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path1 = glob;
        if (path1.length > 0) {
            if (!joined) joined = path1;
            else joined += `${SEP}${path1}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path1 = isWindows ? mod2 : mod3;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function isSubdir(src, dest, sep8 = sep2) {
    if (src === dest) {
        return false;
    }
    src = toPathString(src);
    const srcArray = src.split(sep8);
    dest = toPathString(dest);
    const destArray = dest.split(sep8);
    return srcArray.every((current, i26)=>destArray[i26] === current);
}
function getFileInfoType(fileInfo) {
    return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : undefined;
}
function createWalkEntrySync(path110) {
    path110 = toPathString(path110);
    path110 = normalize3(path110);
    const name = basename2(path110);
    const info1 = Deno.statSync(path110);
    return {
        path: path110,
        name,
        isFile: info1.isFile,
        isDirectory: info1.isDirectory,
        isSymlink: info1.isSymlink
    };
}
async function createWalkEntry(path2) {
    path2 = toPathString(path2);
    path2 = normalize3(path2);
    const name = basename2(path2);
    const info2 = await Deno.stat(path2);
    return {
        path: path2,
        name,
        isFile: info2.isFile,
        isDirectory: info2.isDirectory,
        isSymlink: info2.isSymlink
    };
}
function toPathString(path3) {
    return path3 instanceof URL ? fromFileUrl2(path3) : path3;
}
async function emptyDir(dir) {
    try {
        const items = [];
        for await (const dirEntry of Deno.readDir(dir)){
            items.push(dirEntry);
        }
        while(items.length){
            const item = items.shift();
            if (item && item.name) {
                const filepath = join3(toPathString(dir), item.name);
                await Deno.remove(filepath, {
                    recursive: true
                });
            }
        }
    } catch (err) {
        if (!(err instanceof Deno.errors.NotFound)) {
            throw err;
        }
        await Deno.mkdir(dir, {
            recursive: true
        });
    }
}
function emptyDirSync(dir) {
    try {
        const items = [
            ...Deno.readDirSync(dir)
        ];
        while(items.length){
            const item = items.shift();
            if (item && item.name) {
                const filepath = join3(toPathString(dir), item.name);
                Deno.removeSync(filepath, {
                    recursive: true
                });
            }
        }
    } catch (err) {
        if (!(err instanceof Deno.errors.NotFound)) {
            throw err;
        }
        Deno.mkdirSync(dir, {
            recursive: true
        });
        return;
    }
}
async function ensureDir(dir) {
    try {
        const fileInfo = await Deno.lstat(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await Deno.mkdir(dir, {
                recursive: true
            });
            return;
        }
        throw err;
    }
}
function ensureDirSync(dir) {
    try {
        const fileInfo = Deno.lstatSync(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            Deno.mkdirSync(dir, {
                recursive: true
            });
            return;
        }
        throw err;
    }
}
async function ensureFile(filePath) {
    try {
        const stat = await Deno.lstat(filePath);
        if (!stat.isFile) {
            throw new Error(`Ensure path exists, expected 'file', got '${getFileInfoType(stat)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await ensureDir(dirname2(toPathString(filePath)));
            await Deno.writeFile(filePath, new Uint8Array());
            return;
        }
        throw err;
    }
}
function ensureFileSync(filePath) {
    try {
        const stat = Deno.lstatSync(filePath);
        if (!stat.isFile) {
            throw new Error(`Ensure path exists, expected 'file', got '${getFileInfoType(stat)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            ensureDirSync(dirname2(toPathString(filePath)));
            Deno.writeFileSync(filePath, new Uint8Array());
            return;
        }
        throw err;
    }
}
async function ensureLink(src, dest) {
    dest = toPathString(dest);
    await ensureDir(dirname2(dest));
    await Deno.link(toPathString(src), dest);
}
function ensureLinkSync(src, dest) {
    dest = toPathString(dest);
    ensureDirSync(dirname2(dest));
    Deno.linkSync(toPathString(src), dest);
}
async function ensureSymlink(src, dest) {
    const srcStatInfo = await Deno.lstat(src);
    const srcFilePathType = getFileInfoType(srcStatInfo);
    await ensureDir(dirname2(toPathString(dest)));
    const options = isWindows ? {
        type: srcFilePathType === "dir" ? "dir" : "file"
    } : undefined;
    await Deno.symlink(src, dest, options);
}
function ensureSymlinkSync(src, dest) {
    const srcStatInfo = Deno.lstatSync(src);
    const srcFilePathType = getFileInfoType(srcStatInfo);
    ensureDirSync(dirname2(toPathString(dest)));
    const options = isWindows ? {
        type: srcFilePathType === "dir" ? "dir" : "file"
    } : undefined;
    Deno.symlinkSync(src, dest, options);
}
function include(path27, exts, match, skip) {
    if (exts && !exts.some((ext)=>path27.endsWith(ext))) {
        return false;
    }
    if (match && !match.some((pattern)=>!!path27.match(pattern))) {
        return false;
    }
    if (skip && skip.some((pattern)=>!!path27.match(pattern))) {
        return false;
    }
    return true;
}
function wrapErrorWithRootPath(err, root) {
    if (err instanceof Error && "root" in err) return err;
    const e8 = new Error();
    e8.root = root;
    e8.message = err instanceof Error ? `${err.message} for path "${root}"` : `[non-error thrown] for path "${root}"`;
    e8.stack = err instanceof Error ? err.stack : undefined;
    e8.cause = err instanceof Error ? err.cause : undefined;
    return e8;
}
async function* walk(root, { maxDepth =Infinity , includeFiles =true , includeDirs =true , followSymlinks =false , exts =undefined , match =undefined , skip =undefined  } = {}) {
    if (maxDepth < 0) {
        return;
    }
    root = toPathString(root);
    if (includeDirs && include(root, exts, match, skip)) {
        yield await createWalkEntry(root);
    }
    if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
        return;
    }
    try {
        for await (const entry of Deno.readDir(root)){
            assert(entry.name != null);
            let path28 = join3(root, entry.name);
            let { isSymlink , isDirectory  } = entry;
            if (isSymlink) {
                if (!followSymlinks) continue;
                path28 = await Deno.realPath(path28);
                ({ isSymlink , isDirectory  } = await Deno.lstat(path28));
            }
            if (isSymlink || isDirectory) {
                yield* walk(path28, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip
                });
            } else if (includeFiles && include(path28, exts, match, skip)) {
                yield {
                    path: path28,
                    ...entry
                };
            }
        }
    } catch (err) {
        throw wrapErrorWithRootPath(err, normalize3(root));
    }
}
function* walkSync(root, { maxDepth =Infinity , includeFiles =true , includeDirs =true , followSymlinks =false , exts =undefined , match =undefined , skip =undefined  } = {}) {
    root = toPathString(root);
    if (maxDepth < 0) {
        return;
    }
    if (includeDirs && include(root, exts, match, skip)) {
        yield createWalkEntrySync(root);
    }
    if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
        return;
    }
    let entries;
    try {
        entries = Deno.readDirSync(root);
    } catch (err) {
        throw wrapErrorWithRootPath(err, normalize3(root));
    }
    for (const entry of entries){
        assert(entry.name != null);
        let path29 = join3(root, entry.name);
        let { isSymlink , isDirectory  } = entry;
        if (isSymlink) {
            if (!followSymlinks) continue;
            path29 = Deno.realPathSync(path29);
            ({ isSymlink , isDirectory  } = Deno.lstatSync(path29));
        }
        if (isSymlink || isDirectory) {
            yield* walkSync(path29, {
                maxDepth: maxDepth - 1,
                includeFiles,
                includeDirs,
                followSymlinks,
                exts,
                match,
                skip
            });
        } else if (includeFiles && include(path29, exts, match, skip)) {
            yield {
                path: path29,
                ...entry
            };
        }
    }
}
function split(path30) {
    const s3 = SEP_PATTERN.source;
    const segments = path30.replace(new RegExp(`^${s3}|${s3}$`, "g"), "").split(SEP_PATTERN);
    const isAbsolute_ = isAbsolute2(path30);
    return {
        segments,
        isAbsolute: isAbsolute_,
        hasTrailingSep: !!path30.match(new RegExp(`${s3}$`)),
        winRoot: isWindows && isAbsolute_ ? segments.shift() : undefined
    };
}
function throwUnlessNotFound(error1) {
    if (!(error1 instanceof Deno.errors.NotFound)) {
        throw error1;
    }
}
function comparePath(a5, b5) {
    if (a5.path < b5.path) return -1;
    if (a5.path > b5.path) return 1;
    return 0;
}
async function* expandGlob(glob, { root =Deno.cwd() , exclude =[] , includeDirs =true , extended =true , globstar =false , caseInsensitive  } = {}) {
    const globOptions = {
        extended,
        globstar,
        caseInsensitive
    };
    const absRoot = resolve2(root);
    const resolveFromRoot = (path31)=>resolve2(absRoot, path31);
    const excludePatterns = exclude.map(resolveFromRoot).map((s4)=>globToRegExp(s4, globOptions));
    const shouldInclude = (path32)=>!excludePatterns.some((p5)=>!!path32.match(p5));
    const { segments , isAbsolute: isGlobAbsolute , hasTrailingSep , winRoot  } = split(toPathString(glob));
    let fixedRoot = isGlobAbsolute ? winRoot != undefined ? winRoot : "/" : absRoot;
    while(segments.length > 0 && !isGlob(segments[0])){
        const seg = segments.shift();
        assert(seg != null);
        fixedRoot = joinGlobs([
            fixedRoot,
            seg
        ], globOptions);
    }
    let fixedRootInfo;
    try {
        fixedRootInfo = await createWalkEntry(fixedRoot);
    } catch (error1) {
        return throwUnlessNotFound(error1);
    }
    async function* advanceMatch(walkInfo, globSegment) {
        if (!walkInfo.isDirectory) {
            return;
        } else if (globSegment == "..") {
            const parentPath = joinGlobs([
                walkInfo.path,
                ".."
            ], globOptions);
            try {
                if (shouldInclude(parentPath)) {
                    return yield await createWalkEntry(parentPath);
                }
            } catch (error2) {
                throwUnlessNotFound(error2);
            }
            return;
        } else if (globSegment == "**") {
            return yield* walk(walkInfo.path, {
                skip: excludePatterns
            });
        }
        const globPattern = globToRegExp(globSegment, globOptions);
        for await (const walkEntry of walk(walkInfo.path, {
            maxDepth: 1,
            skip: excludePatterns
        })){
            if (walkEntry.path != walkInfo.path && walkEntry.name.match(globPattern)) {
                yield walkEntry;
            }
        }
    }
    let currentMatches = [
        fixedRootInfo
    ];
    for (const segment of segments){
        const nextMatchMap = new Map();
        await Promise.all(currentMatches.map(async (currentMatch)=>{
            for await (const nextMatch of advanceMatch(currentMatch, segment)){
                nextMatchMap.set(nextMatch.path, nextMatch);
            }
        }));
        currentMatches = [
            ...nextMatchMap.values()
        ].sort(comparePath);
    }
    if (hasTrailingSep) {
        currentMatches = currentMatches.filter((entry)=>entry.isDirectory);
    }
    if (!includeDirs) {
        currentMatches = currentMatches.filter((entry)=>!entry.isDirectory);
    }
    yield* currentMatches;
}
function* expandGlobSync(glob, { root =Deno.cwd() , exclude =[] , includeDirs =true , extended =true , globstar =false , caseInsensitive  } = {}) {
    const globOptions = {
        extended,
        globstar,
        caseInsensitive
    };
    const absRoot = resolve2(root);
    const resolveFromRoot = (path33)=>resolve2(absRoot, path33);
    const excludePatterns = exclude.map(resolveFromRoot).map((s5)=>globToRegExp(s5, globOptions));
    const shouldInclude = (path34)=>!excludePatterns.some((p6)=>!!path34.match(p6));
    const { segments , isAbsolute: isGlobAbsolute , hasTrailingSep , winRoot  } = split(toPathString(glob));
    let fixedRoot = isGlobAbsolute ? winRoot != undefined ? winRoot : "/" : absRoot;
    while(segments.length > 0 && !isGlob(segments[0])){
        const seg = segments.shift();
        assert(seg != null);
        fixedRoot = joinGlobs([
            fixedRoot,
            seg
        ], globOptions);
    }
    let fixedRootInfo;
    try {
        fixedRootInfo = createWalkEntrySync(fixedRoot);
    } catch (error2) {
        return throwUnlessNotFound(error2);
    }
    function* advanceMatch(walkInfo, globSegment) {
        if (!walkInfo.isDirectory) {
            return;
        } else if (globSegment == "..") {
            const parentPath = joinGlobs([
                walkInfo.path,
                ".."
            ], globOptions);
            try {
                if (shouldInclude(parentPath)) {
                    return yield createWalkEntrySync(parentPath);
                }
            } catch (error3) {
                throwUnlessNotFound(error3);
            }
            return;
        } else if (globSegment == "**") {
            return yield* walkSync(walkInfo.path, {
                skip: excludePatterns
            });
        }
        const globPattern = globToRegExp(globSegment, globOptions);
        for (const walkEntry of walkSync(walkInfo.path, {
            maxDepth: 1,
            skip: excludePatterns
        })){
            if (walkEntry.path != walkInfo.path && walkEntry.name.match(globPattern)) {
                yield walkEntry;
            }
        }
    }
    let currentMatches = [
        fixedRootInfo
    ];
    for (const segment of segments){
        const nextMatchMap = new Map();
        for (const currentMatch of currentMatches){
            for (const nextMatch of advanceMatch(currentMatch, segment)){
                nextMatchMap.set(nextMatch.path, nextMatch);
            }
        }
        currentMatches = [
            ...nextMatchMap.values()
        ].sort(comparePath);
    }
    if (hasTrailingSep) {
        currentMatches = currentMatches.filter((entry)=>entry.isDirectory);
    }
    if (!includeDirs) {
        currentMatches = currentMatches.filter((entry)=>!entry.isDirectory);
    }
    yield* currentMatches;
}
const EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");
async function move(src, dest, { overwrite =false  } = {}) {
    const srcStat = await Deno.stat(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (overwrite) {
        try {
            await Deno.remove(dest, {
                recursive: true
            });
        } catch (error4) {
            if (!(error4 instanceof Deno.errors.NotFound)) {
                throw error4;
            }
        }
    } else {
        try {
            await Deno.lstat(dest);
            return Promise.reject(EXISTS_ERROR);
        } catch  {}
    }
    await Deno.rename(src, dest);
    return;
}
function moveSync(src, dest, { overwrite =false  } = {}) {
    const srcStat = Deno.statSync(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (overwrite) {
        try {
            Deno.removeSync(dest, {
                recursive: true
            });
        } catch (error5) {
            if (!(error5 instanceof Deno.errors.NotFound)) {
                throw error5;
            }
        }
    } else {
        try {
            Deno.lstatSync(dest);
            throw EXISTS_ERROR;
        } catch (error6) {
            if (error6 === EXISTS_ERROR) {
                throw error6;
            }
        }
    }
    Deno.renameSync(src, dest);
}
function utime(...args11) {
    if (typeof Deno.utime == "function") {
        return Deno.utime(...args11);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
function utimeSync(...args12) {
    if (typeof Deno.utimeSync == "function") {
        return Deno.utimeSync(...args12);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
async function ensureValidCopy(src, dest, options) {
    let destStat;
    try {
        destStat = await Deno.lstat(dest);
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return;
        }
        throw err;
    }
    if (options.isFolder && !destStat.isDirectory) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!options.overwrite) {
        throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
    }
    return destStat;
}
function ensureValidCopySync(src, dest, options) {
    let destStat;
    try {
        destStat = Deno.lstatSync(dest);
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return;
        }
        throw err;
    }
    if (options.isFolder && !destStat.isDirectory) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!options.overwrite) {
        throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
    }
    return destStat;
}
async function copyFile(src, dest, options) {
    await ensureValidCopy(src, dest, options);
    await Deno.copyFile(src, dest);
    if (options.preserveTimestamps) {
        const statInfo = await Deno.stat(src);
        assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await utime(dest, statInfo.atime, statInfo.mtime);
    }
}
function copyFileSync(src, dest, options) {
    ensureValidCopySync(src, dest, options);
    Deno.copyFileSync(src, dest);
    if (options.preserveTimestamps) {
        const statInfo = Deno.statSync(src);
        assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        utimeSync(dest, statInfo.atime, statInfo.mtime);
    }
}
async function copySymLink(src, dest, options) {
    await ensureValidCopy(src, dest, options);
    const originSrcFilePath = await Deno.readLink(src);
    const type = getFileInfoType(await Deno.lstat(src));
    if (isWindows) {
        await Deno.symlink(originSrcFilePath, dest, {
            type: type === "dir" ? "dir" : "file"
        });
    } else {
        await Deno.symlink(originSrcFilePath, dest);
    }
    if (options.preserveTimestamps) {
        const statInfo = await Deno.lstat(src);
        assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await utime(dest, statInfo.atime, statInfo.mtime);
    }
}
function copySymlinkSync(src, dest, options) {
    ensureValidCopySync(src, dest, options);
    const originSrcFilePath = Deno.readLinkSync(src);
    const type = getFileInfoType(Deno.lstatSync(src));
    if (isWindows) {
        Deno.symlinkSync(originSrcFilePath, dest, {
            type: type === "dir" ? "dir" : "file"
        });
    } else {
        Deno.symlinkSync(originSrcFilePath, dest);
    }
    if (options.preserveTimestamps) {
        const statInfo = Deno.lstatSync(src);
        assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        utimeSync(dest, statInfo.atime, statInfo.mtime);
    }
}
async function copyDir(src, dest, options) {
    const destStat = await ensureValidCopy(src, dest, {
        ...options,
        isFolder: true
    });
    if (!destStat) {
        await ensureDir(dest);
    }
    if (options.preserveTimestamps) {
        const srcStatInfo = await Deno.stat(src);
        assert(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
    }
    src = toPathString(src);
    dest = toPathString(dest);
    for await (const entry of Deno.readDir(src)){
        const srcPath = join3(src, entry.name);
        const destPath = join3(dest, basename2(srcPath));
        if (entry.isSymlink) {
            await copySymLink(srcPath, destPath, options);
        } else if (entry.isDirectory) {
            await copyDir(srcPath, destPath, options);
        } else if (entry.isFile) {
            await copyFile(srcPath, destPath, options);
        }
    }
}
function copyDirSync(src, dest, options) {
    const destStat = ensureValidCopySync(src, dest, {
        ...options,
        isFolder: true
    });
    if (!destStat) {
        ensureDirSync(dest);
    }
    if (options.preserveTimestamps) {
        const srcStatInfo = Deno.statSync(src);
        assert(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
    }
    src = toPathString(src);
    dest = toPathString(dest);
    for (const entry of Deno.readDirSync(src)){
        assert(entry.name != null, "file.name must be set");
        const srcPath = join3(src, entry.name);
        const destPath = join3(dest, basename2(srcPath));
        if (entry.isSymlink) {
            copySymlinkSync(srcPath, destPath, options);
        } else if (entry.isDirectory) {
            copyDirSync(srcPath, destPath, options);
        } else if (entry.isFile) {
            copyFileSync(srcPath, destPath, options);
        }
    }
}
async function copy1(src, dest, options = {}) {
    src = resolve2(toPathString(src));
    dest = resolve2(toPathString(dest));
    if (src === dest) {
        throw new Error("Source and destination cannot be the same.");
    }
    const srcStat = await Deno.lstat(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (srcStat.isSymlink) {
        await copySymLink(src, dest, options);
    } else if (srcStat.isDirectory) {
        await copyDir(src, dest, options);
    } else if (srcStat.isFile) {
        await copyFile(src, dest, options);
    }
}
function copySync(src, dest, options = {}) {
    src = resolve2(toPathString(src));
    dest = resolve2(toPathString(dest));
    if (src === dest) {
        throw new Error("Source and destination cannot be the same.");
    }
    const srcStat = Deno.lstatSync(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (srcStat.isSymlink) {
        copySymlinkSync(src, dest, options);
    } else if (srcStat.isDirectory) {
        copyDirSync(src, dest, options);
    } else if (srcStat.isFile) {
        copyFileSync(src, dest, options);
    }
}
var EOL;
(function(EOL1) {
    EOL1["LF"] = "\n";
    EOL1["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const regDetect = /(?:\r?\n)/g;
function detect(content) {
    const d2 = content.match(regDetect);
    if (!d2 || d2.length === 0) {
        return null;
    }
    const hasCRLF = d2.some((x3)=>x3 === EOL.CRLF);
    return hasCRLF ? EOL.CRLF : EOL.LF;
}
function format3(content, eol) {
    return content.replace(regDetect, eol);
}
const mod4 = {
    exists,
    existsSync,
    emptyDir,
    emptyDirSync,
    ensureDir,
    ensureDirSync,
    ensureFile,
    ensureFileSync,
    ensureLink,
    ensureLinkSync,
    ensureSymlink,
    ensureSymlinkSync,
    expandGlob,
    expandGlobSync,
    walk,
    walkSync,
    move,
    moveSync,
    copy: copy1,
    copySync,
    EOL,
    detect,
    format: format3
};
const { hasOwn  } = Object;
function get(obj, key2) {
    if (hasOwn(obj, key2)) {
        return obj[key2];
    }
}
function getForce(obj, key3) {
    const v2 = get(obj, key3);
    assert(v2 != null);
    return v2;
}
function isNumber(x4) {
    if (typeof x4 === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x4))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x4));
}
function hasKey(obj, keys) {
    let o1 = obj;
    keys.slice(0, -1).forEach((key4)=>{
        o1 = get(o1, key4) ?? {};
    });
    const key1 = keys[keys.length - 1];
    return hasOwn(o1, key1);
}
function parse3(args13, { "--": doubleDash = false , alias: alias3 = {} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect: collect1 = [] , negatable =[] , unknown =(i27)=>i27  } = {}) {
    const flags1 = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags1.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key5 of booleanArgs.filter(Boolean)){
                flags1.bools[key5] = true;
            }
        }
    }
    const aliases = {};
    if (alias3 !== undefined) {
        for(const key6 in alias3){
            const val = getForce(alias3, key6);
            if (typeof val === "string") {
                aliases[key6] = [
                    val
                ];
            } else {
                aliases[key6] = val;
            }
            for (const alias1 of getForce(aliases, key6)){
                aliases[alias1] = [
                    key6
                ].concat(aliases[key6].filter((y1)=>alias1 !== y1));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key7 of stringArgs.filter(Boolean)){
            flags1.strings[key7] = true;
            const alias = get(aliases, key7);
            if (alias) {
                for (const al of alias){
                    flags1.strings[al] = true;
                }
            }
        }
    }
    if (collect1 !== undefined) {
        const collectArgs = typeof collect1 === "string" ? [
            collect1
        ] : collect1;
        for (const key8 of collectArgs.filter(Boolean)){
            flags1.collect[key8] = true;
            const alias = get(aliases, key8);
            if (alias) {
                for (const al of alias){
                    flags1.collect[al] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key9 of negatableArgs.filter(Boolean)){
            flags1.negatable[key9] = true;
            const alias = get(aliases, key9);
            if (alias) {
                for (const al of alias){
                    flags1.negatable[al] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key10, arg) {
        return flags1.allBools && /^--[^=]+$/.test(arg) || get(flags1.bools, key10) || !!get(flags1.strings, key10) || !!get(aliases, key10);
    }
    function setKey(obj, name, value3, collect = true) {
        let o2 = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key11) {
            if (get(o2, key11) === undefined) {
                o2[key11] = {};
            }
            o2 = get(o2, key11);
        });
        const key5 = keys[keys.length - 1];
        const collectable = collect && !!get(flags1.collect, name);
        if (!collectable) {
            o2[key5] = value3;
        } else if (get(o2, key5) === undefined) {
            o2[key5] = [
                value3
            ];
        } else if (Array.isArray(get(o2, key5))) {
            o2[key5].push(value3);
        } else {
            o2[key5] = [
                get(o2, key5),
                value3
            ];
        }
    }
    function setArg(key12, val, arg = undefined, collect) {
        if (arg && flags1.unknownFn && !argDefined(key12, arg)) {
            if (flags1.unknownFn(arg, key12, val) === false) return;
        }
        const value4 = !get(flags1.strings, key12) && isNumber(val) ? Number(val) : val;
        setKey(argv, key12, value4, collect);
        const alias = get(aliases, key12);
        if (alias) {
            for (const x5 of alias){
                setKey(argv, x5, value4, collect);
            }
        }
    }
    function aliasIsBoolean(key13) {
        return getForce(aliases, key13).some((x6)=>typeof get(flags1.bools, x6) === "boolean");
    }
    let notFlags = [];
    if (args13.includes("--")) {
        notFlags = args13.slice(args13.indexOf("--") + 1);
        args13 = args13.slice(0, args13.indexOf("--"));
    }
    for(let i28 = 0; i28 < args13.length; i28++){
        const arg = args13[i28];
        if (/^--.+=/.test(arg)) {
            const m1 = arg.match(/^--([^=]+)=(.*)$/s);
            assert(m1 != null);
            const [, key14, value5] = m1;
            if (flags1.bools[key14]) {
                const booleanValue = value5 !== "false";
                setArg(key14, booleanValue, arg);
            } else {
                setArg(key14, value5, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags1.negatable, arg.replace(/^--no-/, ""))) {
            const m2 = arg.match(/^--no-(.+)/);
            assert(m2 != null);
            setArg(m2[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m3 = arg.match(/^--(.+)/);
            assert(m3 != null);
            const [, key15] = m3;
            const next = args13[i28 + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags1.bools, key15) && !flags1.allBools && (get(aliases, key15) ? !aliasIsBoolean(key15) : true)) {
                setArg(key15, next, arg);
                i28++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key15, next === "true", arg);
                i28++;
            } else {
                setArg(key15, get(flags1.strings, key15) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j6 = 0; j6 < letters.length; j6++){
                const next = arg.slice(j6 + 2);
                if (next === "-") {
                    setArg(letters[j6], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j6]) && /=/.test(next)) {
                    setArg(letters[j6], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j6]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j6], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j6 + 1] && letters[j6 + 1].match(/\W/)) {
                    setArg(letters[j6], arg.slice(j6 + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j6], get(flags1.strings, letters[j6]) ? "" : true, arg);
                }
            }
            const [key16] = arg.slice(-1);
            if (!broken && key16 !== "-") {
                if (args13[i28 + 1] && !/^(-|--)[^-]/.test(args13[i28 + 1]) && !get(flags1.bools, key16) && (get(aliases, key16) ? !aliasIsBoolean(key16) : true)) {
                    setArg(key16, args13[i28 + 1], arg);
                    i28++;
                } else if (args13[i28 + 1] && /^(true|false)$/.test(args13[i28 + 1])) {
                    setArg(key16, args13[i28 + 1] === "true", arg);
                    i28++;
                } else {
                    setArg(key16, get(flags1.strings, key16) ? "" : true, arg);
                }
            }
        } else {
            if (!flags1.unknownFn || flags1.unknownFn(arg) !== false) {
                argv._.push(flags1.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args13.slice(i28 + 1));
                break;
            }
        }
    }
    for (const [key4, value1] of Object.entries(defaults)){
        if (!hasKey(argv, key4.split("."))) {
            setKey(argv, key4, value1);
            if (aliases[key4]) {
                for (const x7 of aliases[key4]){
                    setKey(argv, x7, value1);
                }
            }
        }
    }
    for (const key2 of Object.keys(flags1.bools)){
        if (!hasKey(argv, key2.split("."))) {
            const value6 = get(flags1.collect, key2) ? [] : false;
            setKey(argv, key2, value6, false);
        }
    }
    for (const key3 of Object.keys(flags1.strings)){
        if (!hasKey(argv, key3.split(".")) && get(flags1.collect, key3)) {
            setKey(argv, key3, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key17 of notFlags){
            argv["--"].push(key17);
        }
    } else {
        for (const key18 of notFlags){
            argv._.push(key18);
        }
    }
    return argv;
}
const mod5 = {
    parse: parse3
};
const matchCache = {};
const FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
const SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
function getPattern(name) {
    if (name in matchCache) {
        return matchCache[name];
    }
    return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
}
function pushCookie(headers, cookie) {
    if (cookie.overwrite) {
        for(let i29 = headers.length - 1; i29 >= 0; i29--){
            if (headers[i29].indexOf(`${cookie.name}=`) === 0) {
                headers.splice(i29, 1);
            }
        }
    }
    headers.push(cookie.toHeader());
}
function validateCookieProperty(key19, value7) {
    if (value7 && !FIELD_CONTENT_REGEXP.test(value7)) {
        throw new TypeError(`The ${key19} of the cookie (${value7}) is invalid.`);
    }
}
class Cookie {
    domain;
    expires;
    httpOnly = true;
    maxAge;
    name;
    overwrite = false;
    path = "/";
    sameSite = false;
    secure = false;
    signed;
    value;
    constructor(name, value8, attributes){
        validateCookieProperty("name", name);
        validateCookieProperty("value", value8);
        this.name = name;
        this.value = value8 ?? "";
        Object.assign(this, attributes);
        if (!this.value) {
            this.expires = new Date(0);
            this.maxAge = undefined;
        }
        validateCookieProperty("path", this.path);
        validateCookieProperty("domain", this.domain);
        if (this.sameSite && typeof this.sameSite === "string" && !SAME_SITE_REGEXP.test(this.sameSite)) {
            throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
        }
    }
    toHeader() {
        let header = this.toString();
        if (this.maxAge) {
            this.expires = new Date(Date.now() + this.maxAge * 1000);
        }
        if (this.path) {
            header += `; path=${this.path}`;
        }
        if (this.expires) {
            header += `; expires=${this.expires.toUTCString()}`;
        }
        if (this.domain) {
            header += `; domain=${this.domain}`;
        }
        if (this.sameSite) {
            header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
        }
        if (this.secure) {
            header += "; secure";
        }
        if (this.httpOnly) {
            header += "; httponly";
        }
        return header;
    }
    toString() {
        return `${this.name}=${this.value}`;
    }
}
class Cookies {
    #cookieKeys;
    #keys;
    #request;
    #response;
    #secure;
     #requestKeys() {
        if (this.#cookieKeys) {
            return this.#cookieKeys;
        }
        const result = this.#cookieKeys = [];
        const header = this.#request.headers.get("cookie");
        if (!header) {
            return result;
        }
        let matches;
        while(matches = KEY_REGEXP.exec(header)){
            const [, key] = matches;
            result.push(key);
        }
        return result;
    }
    constructor(request, response, options = {}){
        const { keys , secure  } = options;
        this.#keys = keys;
        this.#request = request;
        this.#response = response;
        this.#secure = secure;
    }
    delete(name, options = {}) {
        this.set(name, null, options);
        return true;
    }
    async *entries() {
        const keys = this.#requestKeys();
        for (const key20 of keys){
            const value9 = await this.get(key20);
            if (value9) {
                yield [
                    key20,
                    value9
                ];
            }
        }
    }
    async forEach(callback, thisArg = null) {
        const keys = this.#requestKeys();
        for (const key21 of keys){
            const value10 = await this.get(key21);
            if (value10) {
                callback.call(thisArg, key21, value10, this);
            }
        }
    }
    async get(name, options = {}) {
        const signed = options.signed ?? !!this.#keys;
        const nameSig = `${name}.sig`;
        const header = this.#request.headers.get("cookie");
        if (!header) {
            return;
        }
        const match = header.match(getPattern(name));
        if (!match) {
            return;
        }
        const [, value11] = match;
        if (!signed) {
            return value11;
        }
        const digest1 = await this.get(nameSig, {
            signed: false
        });
        if (!digest1) {
            return;
        }
        const data = `${name}=${value11}`;
        if (!this.#keys) {
            throw new TypeError("keys required for signed cookies");
        }
        const index = await this.#keys.indexOf(data, digest1);
        if (index < 0) {
            this.delete(nameSig, {
                path: "/",
                signed: false
            });
        } else {
            if (index) {
                this.set(nameSig, await this.#keys.sign(data), {
                    signed: false
                });
            }
            return value11;
        }
    }
    async *keys() {
        const keys = this.#requestKeys();
        for (const key22 of keys){
            const value12 = await this.get(key22);
            if (value12) {
                yield key22;
            }
        }
    }
    async set(name, value13, options = {}) {
        const request = this.#request;
        const response = this.#response;
        const headers = [];
        for (const [key23, value1] of response.headers.entries()){
            if (key23 === "set-cookie") {
                headers.push(value1);
            }
        }
        const secure = this.#secure !== undefined ? this.#secure : request.secure;
        const signed = options.signed ?? !!this.#keys;
        if (!secure && options.secure && !options.ignoreInsecure) {
            throw new TypeError("Cannot send secure cookie over unencrypted connection.");
        }
        const cookie = new Cookie(name, value13, options);
        cookie.secure = options.secure ?? secure;
        pushCookie(headers, cookie);
        if (signed) {
            if (!this.#keys) {
                throw new TypeError(".keys required for signed cookies.");
            }
            cookie.value = await this.#keys.sign(cookie.toString());
            cookie.name += ".sig";
            pushCookie(headers, cookie);
        }
        response.headers.delete("Set-Cookie");
        for (const header of headers){
            response.headers.append("Set-Cookie", header);
        }
        return this;
    }
    async *values() {
        const keys = this.#requestKeys();
        for (const key24 of keys){
            const value14 = await this.get(key24);
            if (value14) {
                yield value14;
            }
        }
    }
    async *[Symbol.asyncIterator]() {
        const keys = this.#requestKeys();
        for (const key25 of keys){
            const value15 = await this.get(key25);
            if (value15) {
                yield [
                    key25,
                    value15
                ];
            }
        }
    }
    [Symbol.for("Deno.customInspect")]() {
        return `${this.constructor.name} []`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect([], newOptions)}`;
    }
}
function deferred() {
    let methods;
    let state1 = "pending";
    const promise = new Promise((resolve6, reject)=>{
        methods = {
            async resolve (value16) {
                await value16;
                state1 = "fulfilled";
                resolve6(value16);
            },
            reject (reason) {
                state1 = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state1
    });
    return Object.assign(promise, methods);
}
function equalsNaive(a6, b6) {
    if (a6.length !== b6.length) return false;
    for(let i30 = 0; i30 < b6.length; i30++){
        if (a6[i30] !== b6[i30]) return false;
    }
    return true;
}
function equals32Bit(a7, b7) {
    if (a7.length !== b7.length) return false;
    const len = a7.length;
    const compressable = Math.floor(len / 4);
    const compressedA = new Uint32Array(a7.buffer, 0, compressable);
    const compressedB = new Uint32Array(b7.buffer, 0, compressable);
    for(let i31 = compressable * 4; i31 < len; i31++){
        if (a7[i31] !== b7[i31]) return false;
    }
    for(let i1 = 0; i1 < compressedA.length; i1++){
        if (compressedA[i1] !== compressedB[i1]) return false;
    }
    return true;
}
function equals(a8, b8) {
    if (a8.length < 1000) return equalsNaive(a8, b8);
    return equals32Bit(a8, b8);
}
function concat(...buf) {
    let length = 0;
    for (const b9 of buf){
        length += b9.length;
    }
    const output = new Uint8Array(length);
    let index = 0;
    for (const b1 of buf){
        output.set(b1, index);
        index += b1.length;
    }
    return output;
}
function copy2(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const { Deno: Deno1  } = globalThis;
typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType1;
(function(DiffType3) {
    DiffType3["removed"] = "removed";
    DiffType3["common"] = "common";
    DiffType3["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
class AssertionError1 extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert2(expr, msg18 = "") {
    if (!expr) {
        throw new AssertionError1(msg18);
    }
}
function timingSafeEqual1(a9, b10) {
    if (a9.byteLength !== b10.byteLength) {
        return false;
    }
    if (!(a9 instanceof DataView)) {
        a9 = new DataView(ArrayBuffer.isView(a9) ? a9.buffer : a9);
    }
    if (!(b10 instanceof DataView)) {
        b10 = new DataView(ArrayBuffer.isView(b10) ? b10.buffer : b10);
    }
    assert2(a9 instanceof DataView);
    assert2(b10 instanceof DataView);
    const length = a9.byteLength;
    let out = 0;
    let i32 = -1;
    while(++i32 < length){
        out |= a9.getUint8(i32) ^ b10.getUint8(i32);
    }
    return out === 0;
}
const base64abc1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode1(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i33;
    const l2 = uint8.length;
    for(i33 = 2; i33 < l2; i33 += 3){
        result += base64abc1[uint8[i33 - 2] >> 2];
        result += base64abc1[(uint8[i33 - 2] & 0x03) << 4 | uint8[i33 - 1] >> 4];
        result += base64abc1[(uint8[i33 - 1] & 0x0f) << 2 | uint8[i33] >> 6];
        result += base64abc1[uint8[i33] & 0x3f];
    }
    if (i33 === l2 + 1) {
        result += base64abc1[uint8[i33 - 2] >> 2];
        result += base64abc1[(uint8[i33 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i33 === l2) {
        result += base64abc1[uint8[i33 - 2] >> 2];
        result += base64abc1[(uint8[i33 - 2] & 0x03) << 4 | uint8[i33 - 1] >> 4];
        result += base64abc1[(uint8[i33 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode1(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i34 = 0; i34 < size; i34++){
        bytes[i34] = binString.charCodeAt(i34);
    }
    return bytes;
}
const mod6 = {
    encode: encode1,
    decode: decode1
};
var Status;
(function(Status1) {
    Status1[Status1["Continue"] = 100] = "Continue";
    Status1[Status1["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status1[Status1["Processing"] = 102] = "Processing";
    Status1[Status1["EarlyHints"] = 103] = "EarlyHints";
    Status1[Status1["OK"] = 200] = "OK";
    Status1[Status1["Created"] = 201] = "Created";
    Status1[Status1["Accepted"] = 202] = "Accepted";
    Status1[Status1["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status1[Status1["NoContent"] = 204] = "NoContent";
    Status1[Status1["ResetContent"] = 205] = "ResetContent";
    Status1[Status1["PartialContent"] = 206] = "PartialContent";
    Status1[Status1["MultiStatus"] = 207] = "MultiStatus";
    Status1[Status1["AlreadyReported"] = 208] = "AlreadyReported";
    Status1[Status1["IMUsed"] = 226] = "IMUsed";
    Status1[Status1["MultipleChoices"] = 300] = "MultipleChoices";
    Status1[Status1["MovedPermanently"] = 301] = "MovedPermanently";
    Status1[Status1["Found"] = 302] = "Found";
    Status1[Status1["SeeOther"] = 303] = "SeeOther";
    Status1[Status1["NotModified"] = 304] = "NotModified";
    Status1[Status1["UseProxy"] = 305] = "UseProxy";
    Status1[Status1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status1[Status1["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status1[Status1["BadRequest"] = 400] = "BadRequest";
    Status1[Status1["Unauthorized"] = 401] = "Unauthorized";
    Status1[Status1["PaymentRequired"] = 402] = "PaymentRequired";
    Status1[Status1["Forbidden"] = 403] = "Forbidden";
    Status1[Status1["NotFound"] = 404] = "NotFound";
    Status1[Status1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status1[Status1["NotAcceptable"] = 406] = "NotAcceptable";
    Status1[Status1["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status1[Status1["RequestTimeout"] = 408] = "RequestTimeout";
    Status1[Status1["Conflict"] = 409] = "Conflict";
    Status1[Status1["Gone"] = 410] = "Gone";
    Status1[Status1["LengthRequired"] = 411] = "LengthRequired";
    Status1[Status1["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status1[Status1["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status1[Status1["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status1[Status1["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status1[Status1["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status1[Status1["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status1[Status1["Teapot"] = 418] = "Teapot";
    Status1[Status1["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status1[Status1["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status1[Status1["Locked"] = 423] = "Locked";
    Status1[Status1["FailedDependency"] = 424] = "FailedDependency";
    Status1[Status1["TooEarly"] = 425] = "TooEarly";
    Status1[Status1["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status1[Status1["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status1[Status1["TooManyRequests"] = 429] = "TooManyRequests";
    Status1[Status1["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status1[Status1["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status1[Status1["InternalServerError"] = 500] = "InternalServerError";
    Status1[Status1["NotImplemented"] = 501] = "NotImplemented";
    Status1[Status1["BadGateway"] = 502] = "BadGateway";
    Status1[Status1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status1[Status1["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status1[Status1["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status1[Status1["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status1[Status1["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status1[Status1["LoopDetected"] = 508] = "LoopDetected";
    Status1[Status1["NotExtended"] = 510] = "NotExtended";
    Status1[Status1["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status || (Status = {}));
const STATUS_TEXT = {
    [Status.Accepted]: "Accepted",
    [Status.AlreadyReported]: "Already Reported",
    [Status.BadGateway]: "Bad Gateway",
    [Status.BadRequest]: "Bad Request",
    [Status.Conflict]: "Conflict",
    [Status.Continue]: "Continue",
    [Status.Created]: "Created",
    [Status.EarlyHints]: "Early Hints",
    [Status.ExpectationFailed]: "Expectation Failed",
    [Status.FailedDependency]: "Failed Dependency",
    [Status.Forbidden]: "Forbidden",
    [Status.Found]: "Found",
    [Status.GatewayTimeout]: "Gateway Timeout",
    [Status.Gone]: "Gone",
    [Status.HTTPVersionNotSupported]: "HTTP Version Not Supported",
    [Status.IMUsed]: "IM Used",
    [Status.InsufficientStorage]: "Insufficient Storage",
    [Status.InternalServerError]: "Internal Server Error",
    [Status.LengthRequired]: "Length Required",
    [Status.Locked]: "Locked",
    [Status.LoopDetected]: "Loop Detected",
    [Status.MethodNotAllowed]: "Method Not Allowed",
    [Status.MisdirectedRequest]: "Misdirected Request",
    [Status.MovedPermanently]: "Moved Permanently",
    [Status.MultiStatus]: "Multi Status",
    [Status.MultipleChoices]: "Multiple Choices",
    [Status.NetworkAuthenticationRequired]: "Network Authentication Required",
    [Status.NoContent]: "No Content",
    [Status.NonAuthoritativeInfo]: "Non Authoritative Info",
    [Status.NotAcceptable]: "Not Acceptable",
    [Status.NotExtended]: "Not Extended",
    [Status.NotFound]: "Not Found",
    [Status.NotImplemented]: "Not Implemented",
    [Status.NotModified]: "Not Modified",
    [Status.OK]: "OK",
    [Status.PartialContent]: "Partial Content",
    [Status.PaymentRequired]: "Payment Required",
    [Status.PermanentRedirect]: "Permanent Redirect",
    [Status.PreconditionFailed]: "Precondition Failed",
    [Status.PreconditionRequired]: "Precondition Required",
    [Status.Processing]: "Processing",
    [Status.ProxyAuthRequired]: "Proxy Auth Required",
    [Status.RequestEntityTooLarge]: "Request Entity Too Large",
    [Status.RequestHeaderFieldsTooLarge]: "Request Header Fields Too Large",
    [Status.RequestTimeout]: "Request Timeout",
    [Status.RequestURITooLong]: "Request URI Too Long",
    [Status.RequestedRangeNotSatisfiable]: "Requested Range Not Satisfiable",
    [Status.ResetContent]: "Reset Content",
    [Status.SeeOther]: "See Other",
    [Status.ServiceUnavailable]: "Service Unavailable",
    [Status.SwitchingProtocols]: "Switching Protocols",
    [Status.Teapot]: "I'm a teapot",
    [Status.TemporaryRedirect]: "Temporary Redirect",
    [Status.TooEarly]: "Too Early",
    [Status.TooManyRequests]: "Too Many Requests",
    [Status.Unauthorized]: "Unauthorized",
    [Status.UnavailableForLegalReasons]: "Unavailable For Legal Reasons",
    [Status.UnprocessableEntity]: "Unprocessable Entity",
    [Status.UnsupportedMediaType]: "Unsupported Media Type",
    [Status.UpgradeRequired]: "Upgrade Required",
    [Status.UseProxy]: "Use Proxy",
    [Status.VariantAlsoNegotiates]: "Variant Also Negotiates"
};
function isClientErrorStatus(status) {
    return status >= 400 && status < 500;
}
const ERROR_STATUS_MAP = {
    "BadRequest": 400,
    "Unauthorized": 401,
    "PaymentRequired": 402,
    "Forbidden": 403,
    "NotFound": 404,
    "MethodNotAllowed": 405,
    "NotAcceptable": 406,
    "ProxyAuthRequired": 407,
    "RequestTimeout": 408,
    "Conflict": 409,
    "Gone": 410,
    "LengthRequired": 411,
    "PreconditionFailed": 412,
    "RequestEntityTooLarge": 413,
    "RequestURITooLong": 414,
    "UnsupportedMediaType": 415,
    "RequestedRangeNotSatisfiable": 416,
    "ExpectationFailed": 417,
    "Teapot": 418,
    "MisdirectedRequest": 421,
    "UnprocessableEntity": 422,
    "Locked": 423,
    "FailedDependency": 424,
    "UpgradeRequired": 426,
    "PreconditionRequired": 428,
    "TooManyRequests": 429,
    "RequestHeaderFieldsTooLarge": 431,
    "UnavailableForLegalReasons": 451,
    "InternalServerError": 500,
    "NotImplemented": 501,
    "BadGateway": 502,
    "ServiceUnavailable": 503,
    "GatewayTimeout": 504,
    "HTTPVersionNotSupported": 505,
    "VariantAlsoNegotiates": 506,
    "InsufficientStorage": 507,
    "LoopDetected": 508,
    "NotExtended": 510,
    "NetworkAuthenticationRequired": 511
};
class HttpError extends Error {
    #status = Status.InternalServerError;
    #expose;
    #headers;
    constructor(message = "Http Error", options){
        super(message, options);
        this.#expose = options?.expose === undefined ? isClientErrorStatus(this.status) : options.expose;
        if (options?.headers) {
            this.#headers = new Headers(options.headers);
        }
    }
    get expose() {
        return this.#expose;
    }
    get headers() {
        return this.#headers;
    }
    get status() {
        return this.#status;
    }
}
function createHttpErrorConstructor(status) {
    const name = `${Status[status]}Error`;
    const ErrorCtor = class extends HttpError {
        constructor(message = STATUS_TEXT[status], options){
            super(message, options);
            Object.defineProperty(this, "name", {
                configurable: true,
                enumerable: false,
                value: name,
                writable: true
            });
        }
        get status() {
            return status;
        }
    };
    return ErrorCtor;
}
const errors = {};
for (const [key, value] of Object.entries(ERROR_STATUS_MAP)){
    errors[key] = createHttpErrorConstructor(value);
}
function createHttpError(status = Status.InternalServerError, message, options) {
    return new errors[Status[status]](message, options);
}
function isHttpError(value1) {
    return value1 instanceof HttpError;
}
function compareSpecs(a10, b11) {
    return b11.q - a10.q || (b11.s ?? 0) - (a10.s ?? 0) || (a10.o ?? 0) - (b11.o ?? 0) || a10.i - b11.i || 0;
}
function isQuality(spec) {
    return spec.q > 0;
}
const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseEncoding(str7, i35) {
    const match = simpleEncodingRegExp.exec(str7);
    if (!match) {
        return undefined;
    }
    const encoding = match[1];
    let q1 = 1;
    if (match[2]) {
        const params = match[2].split(";");
        for (const param of params){
            const p7 = param.trim().split("=");
            if (p7[0] === "q") {
                q1 = parseFloat(p7[1]);
                break;
            }
        }
    }
    return {
        encoding,
        q: q1,
        i: i35
    };
}
function specify(encoding, spec, i36 = -1) {
    if (!spec.encoding) {
        return;
    }
    let s6 = 0;
    if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
        s6 = 1;
    } else if (spec.encoding !== "*") {
        return;
    }
    return {
        i: i36,
        o: spec.i,
        q: spec.q,
        s: s6
    };
}
function parseAcceptEncoding(accept) {
    const accepts1 = accept.split(",");
    const parsedAccepts = [];
    let hasIdentity = false;
    let minQuality = 1;
    for(let i37 = 0; i37 < accepts1.length; i37++){
        const encoding = parseEncoding(accepts1[i37].trim(), i37);
        if (encoding) {
            parsedAccepts.push(encoding);
            hasIdentity = hasIdentity || !!specify("identity", encoding);
            minQuality = Math.min(minQuality, encoding.q || 1);
        }
    }
    if (!hasIdentity) {
        parsedAccepts.push({
            encoding: "identity",
            q: minQuality,
            i: accepts1.length - 1
        });
    }
    return parsedAccepts;
}
function getEncodingPriority(encoding, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0,
        i: 0
    };
    for (const s7 of accepted){
        const spec = specify(encoding, s7, index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function preferredEncodings(accept, provided) {
    const accepts2 = parseAcceptEncoding(accept);
    if (!provided) {
        return accepts2.filter(isQuality).sort(compareSpecs).map((spec)=>spec.encoding);
    }
    const priorities = provided.map((type, index)=>getEncodingPriority(type, accepts2, index));
    return priorities.filter(isQuality).sort(compareSpecs).map((priority)=>provided[priorities.indexOf(priority)]);
}
const SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseLanguage(str8, i38) {
    const match = SIMPLE_LANGUAGE_REGEXP.exec(str8);
    if (!match) {
        return undefined;
    }
    const [, prefix, suffix] = match;
    const full = suffix ? `${prefix}-${suffix}` : prefix;
    let q2 = 1;
    if (match[3]) {
        const params = match[3].split(";");
        for (const param of params){
            const [key26, value17] = param.trim().split("=");
            if (key26 === "q") {
                q2 = parseFloat(value17);
                break;
            }
        }
    }
    return {
        prefix,
        suffix,
        full,
        q: q2,
        i: i38
    };
}
function parseAcceptLanguage(accept) {
    const accepts3 = accept.split(",");
    const result = [];
    for(let i39 = 0; i39 < accepts3.length; i39++){
        const language = parseLanguage(accepts3[i39].trim(), i39);
        if (language) {
            result.push(language);
        }
    }
    return result;
}
function specify1(language, spec, i40) {
    const p8 = parseLanguage(language, i40);
    if (!p8) {
        return undefined;
    }
    let s8 = 0;
    if (spec.full.toLowerCase() === p8.full.toLowerCase()) {
        s8 |= 4;
    } else if (spec.prefix.toLowerCase() === p8.prefix.toLowerCase()) {
        s8 |= 2;
    } else if (spec.full.toLowerCase() === p8.prefix.toLowerCase()) {
        s8 |= 1;
    } else if (spec.full !== "*") {
        return;
    }
    return {
        i: i40,
        o: spec.i,
        q: spec.q,
        s: s8
    };
}
function getLanguagePriority(language, accepted, index) {
    let priority = {
        i: -1,
        o: -1,
        q: 0,
        s: 0
    };
    for (const accepts4 of accepted){
        const spec = specify1(language, accepts4, index);
        if (spec && ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q || (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function preferredLanguages(accept = "*", provided) {
    const accepts5 = parseAcceptLanguage(accept);
    if (!provided) {
        return accepts5.filter(isQuality).sort(compareSpecs).map((spec)=>spec.full);
    }
    const priorities = provided.map((type, index)=>getLanguagePriority(type, accepts5, index));
    return priorities.filter(isQuality).sort(compareSpecs).map((priority)=>provided[priorities.indexOf(priority)]);
}
const simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function quoteCount(str9) {
    let count = 0;
    let index = 0;
    while((index = str9.indexOf(`"`, index)) !== -1){
        count++;
        index++;
    }
    return count;
}
function splitMediaTypes(accept) {
    const accepts6 = accept.split(",");
    let j7 = 0;
    for(let i41 = 1; i41 < accepts6.length; i41++){
        if (quoteCount(accepts6[j7]) % 2 === 0) {
            accepts6[++j7] = accepts6[i41];
        } else {
            accepts6[j7] += `,${accepts6[i41]}`;
        }
    }
    accepts6.length = j7 + 1;
    return accepts6;
}
function splitParameters(str10) {
    const parameters = str10.split(";");
    let j8 = 0;
    for(let i42 = 1; i42 < parameters.length; i42++){
        if (quoteCount(parameters[j8]) % 2 === 0) {
            parameters[++j8] = parameters[i42];
        } else {
            parameters[j8] += `;${parameters[i42]}`;
        }
    }
    parameters.length = j8 + 1;
    return parameters.map((p9)=>p9.trim());
}
function splitKeyValuePair(str11) {
    const [key27, value18] = str11.split("=");
    return [
        key27.toLowerCase(),
        value18
    ];
}
function parseMediaType(str12, i43) {
    const match = simpleMediaTypeRegExp.exec(str12);
    if (!match) {
        return;
    }
    const params = Object.create(null);
    let q3 = 1;
    const [, type, subtype, parameters] = match;
    if (parameters) {
        const kvps = splitParameters(parameters).map(splitKeyValuePair);
        for (const [key28, val] of kvps){
            const value19 = val && val[0] === `"` && val[val.length - 1] === `"` ? val.substr(1, val.length - 2) : val;
            if (key28 === "q" && value19) {
                q3 = parseFloat(value19);
                break;
            }
            params[key28] = value19;
        }
    }
    return {
        type,
        subtype,
        params,
        q: q3,
        i: i43
    };
}
function parseAccept(accept) {
    const accepts7 = splitMediaTypes(accept);
    const mediaTypes = [];
    for(let i44 = 0; i44 < accepts7.length; i44++){
        const mediaType = parseMediaType(accepts7[i44].trim(), i44);
        if (mediaType) {
            mediaTypes.push(mediaType);
        }
    }
    return mediaTypes;
}
function getFullType(spec) {
    return `${spec.type}/${spec.subtype}`;
}
function specify2(type, spec, index) {
    const p10 = parseMediaType(type, index);
    if (!p10) {
        return;
    }
    let s9 = 0;
    if (spec.type.toLowerCase() === p10.type.toLowerCase()) {
        s9 |= 4;
    } else if (spec.type !== "*") {
        return;
    }
    if (spec.subtype.toLowerCase() === p10.subtype.toLowerCase()) {
        s9 |= 2;
    } else if (spec.subtype !== "*") {
        return;
    }
    const keys = Object.keys(spec.params);
    if (keys.length) {
        if (keys.every((key29)=>(spec.params[key29] || "").toLowerCase() === (p10.params[key29] || "").toLowerCase())) {
            s9 |= 1;
        } else {
            return;
        }
    }
    return {
        i: index,
        o: spec.o,
        q: spec.q,
        s: s9
    };
}
function getMediaTypePriority(type, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0,
        i: index
    };
    for (const accepts8 of accepted){
        const spec = specify2(type, accepts8, index);
        if (spec && ((priority.s || 0) - (spec.s || 0) || (priority.q || 0) - (spec.q || 0) || (priority.o || 0) - (spec.o || 0)) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function preferredMediaTypes(accept, provided) {
    const accepts9 = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
        return accepts9.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    const priorities = provided.map((type, index)=>{
        return getMediaTypePriority(type, accepts9, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map((priority)=>provided[priorities.indexOf(priority)]);
}
function accepts(request, ...types1) {
    const accept = request.headers.get("accept");
    return types1.length ? accept ? preferredMediaTypes(accept, types1)[0] : types1[0] : accept ? preferredMediaTypes(accept) : [
        "*/*"
    ];
}
function acceptsEncodings(request, ...encodings) {
    const acceptEncoding = request.headers.get("accept-encoding");
    return encodings.length ? acceptEncoding ? preferredEncodings(acceptEncoding, encodings)[0] : encodings[0] : acceptEncoding ? preferredEncodings(acceptEncoding) : [
        "*"
    ];
}
function acceptsLanguages(request, ...langs) {
    const acceptLanguage = request.headers.get("accept-language");
    return langs.length ? acceptLanguage ? preferredLanguages(acceptLanguage, langs)[0] : langs[0] : acceptLanguage ? preferredLanguages(acceptLanguage) : [
        "*"
    ];
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg19 = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg19);
    }
}
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n7) {
        if (n7 === 0) {
            this.reset();
            return;
        }
        if (n7 < 0 || n7 > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n7);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
     #tryGrowByReslice(n8) {
        const l = this.#buf.byteLength;
        if (n8 <= this.capacity - l) {
            this.#reslice(l + n8);
            return l;
        }
        return -1;
    }
     #reslice(len) {
        assert3(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    readSync(p11) {
        if (this.empty()) {
            this.reset();
            if (p11.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy2(this.#buf.subarray(this.#off), p11);
        this.#off += nread;
        return nread;
    }
    read(p12) {
        const rr = this.readSync(p12);
        return Promise.resolve(rr);
    }
    writeSync(p13) {
        const m4 = this.#grow(p13.byteLength);
        return copy2(p13, this.#buf, m4);
    }
    write(p14) {
        const n1 = this.writeSync(p14);
        return Promise.resolve(n1);
    }
     #grow(n2) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n2);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n2 <= Math.floor(c / 2) - m) {
            copy2(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n2 > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n2, MAX_SIZE));
            copy2(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n2, MAX_SIZE));
        return m;
    }
    grow(n3) {
        if (n3 < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m5 = this.#grow(n3);
        this.#reslice(m5);
    }
    async readFrom(r4) {
        let n4 = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r4.read(buf);
            if (nread === null) {
                return n4;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n4 += nread;
        }
    }
    readFromSync(r5) {
        let n5 = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r5.readSync(buf);
            if (nread === null) {
                return n5;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n5 += nread;
        }
    }
}
const MIN_BUF_SIZE1 = 16;
const CR1 = "\r".charCodeAt(0);
const LF1 = "\n".charCodeAt(0);
class BufferFullError1 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError1 extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader1 {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r6, size = 4096) {
        return r6 instanceof BufReader1 ? r6 : new BufReader1(r6, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE1;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i45 = 100; i45 > 0; i45--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert3(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r7) {
        this.#reset(this.#buf, r7);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p15) {
        let rr = p15.byteLength;
        if (p15.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p15.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p15);
                const nread = rr ?? 0;
                assert3(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert3(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy2(this.#buf.subarray(this.#r, this.#w), p15, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p16) {
        let bytesRead = 0;
        while(bytesRead < p16.length){
            try {
                const rr = await this.read(p16.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError1();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = p16.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e9 = new PartialReadError1();
                    e9.partial = p16.subarray(0, bytesRead);
                    e9.stack = err.stack;
                    e9.message = err.message;
                    e9.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p16;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c9 = this.#buf[this.#r];
        this.#r++;
        return c9;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF1);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError1) {
                partial = err.partial;
                assert3(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError1)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR1) {
                assert3(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF1) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR1) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s10 = 0;
        let slice;
        while(true){
            let i46 = this.#buf.subarray(this.#r + s10, this.#w).indexOf(delim);
            if (i46 >= 0) {
                i46 += s10;
                slice = this.#buf.subarray(this.#r, this.#r + i46 + 1);
                this.#r += i46 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError1(oldbuf);
            }
            s10 = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e10 = new PartialReadError1();
                    e10.partial = slice;
                    e10.stack = err.stack;
                    e10.message = err.message;
                    e10.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e11 = new PartialReadError1();
                    e11.partial = this.#buf.subarray(this.#r, this.#w);
                    e11.stack = err.stack;
                    e11.message = err.message;
                    e11.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError1(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase1 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter1 extends AbstractBufBase1 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter1 ? writer : new BufWriter1(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w3) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w3;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p17 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p17.length){
                nwritten += await this.#writer.write(p17.subarray(nwritten));
            }
        } catch (e12) {
            if (e12 instanceof Error) {
                this.err = e12;
            }
            throw e12;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e13) {
                    if (e13 instanceof Error) {
                        this.err = e13;
                    }
                    throw e13;
                }
            } else {
                numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync1 extends AbstractBufBase1 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync1 ? writer : new BufWriterSync1(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w4) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w4;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p18 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p18.length){
                nwritten += this.#writer.writeSync(p18.subarray(nwritten));
            }
        } catch (e14) {
            if (e14 instanceof Error) {
                this.err = e14;
            }
            throw e14;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e15) {
                    if (e15 instanceof Error) {
                        this.err = e15;
                    }
                    throw e15;
                }
            } else {
                numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class LimitedReader {
    constructor(reader, limit){
        this.reader = reader;
        this.limit = limit;
    }
    async read(p19) {
        if (this.limit <= 0) {
            return null;
        }
        if (p19.length > this.limit) {
            p19 = p19.subarray(0, this.limit);
        }
        const n9 = await this.reader.read(p19);
        if (n9 == null) {
            return null;
        }
        this.limit -= n9;
        return n9;
    }
    reader;
    limit;
}
const __default = {
    "application/1d-interleaved-parityfec": {
        "source": "iana"
    },
    "application/3gpdash-qoe-report+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/3gpp-ims+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/3gpphal+json": {
        "source": "iana",
        "compressible": true
    },
    "application/3gpphalforms+json": {
        "source": "iana",
        "compressible": true
    },
    "application/a2l": {
        "source": "iana"
    },
    "application/ace+cbor": {
        "source": "iana"
    },
    "application/activemessage": {
        "source": "iana"
    },
    "application/activity+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-costmap+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-costmapfilter+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-directory+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-endpointcost+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-endpointcostparams+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-endpointprop+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-endpointpropparams+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-error+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-networkmap+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-networkmapfilter+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-updatestreamcontrol+json": {
        "source": "iana",
        "compressible": true
    },
    "application/alto-updatestreamparams+json": {
        "source": "iana",
        "compressible": true
    },
    "application/aml": {
        "source": "iana"
    },
    "application/andrew-inset": {
        "source": "iana",
        "extensions": [
            "ez"
        ]
    },
    "application/applefile": {
        "source": "iana"
    },
    "application/applixware": {
        "source": "apache",
        "extensions": [
            "aw"
        ]
    },
    "application/at+jwt": {
        "source": "iana"
    },
    "application/atf": {
        "source": "iana"
    },
    "application/atfx": {
        "source": "iana"
    },
    "application/atom+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "atom"
        ]
    },
    "application/atomcat+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "atomcat"
        ]
    },
    "application/atomdeleted+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "atomdeleted"
        ]
    },
    "application/atomicmail": {
        "source": "iana"
    },
    "application/atomsvc+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "atomsvc"
        ]
    },
    "application/atsc-dwd+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "dwd"
        ]
    },
    "application/atsc-dynamic-event-message": {
        "source": "iana"
    },
    "application/atsc-held+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "held"
        ]
    },
    "application/atsc-rdt+json": {
        "source": "iana",
        "compressible": true
    },
    "application/atsc-rsat+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rsat"
        ]
    },
    "application/atxml": {
        "source": "iana"
    },
    "application/auth-policy+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/bacnet-xdd+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/batch-smtp": {
        "source": "iana"
    },
    "application/bdoc": {
        "compressible": false,
        "extensions": [
            "bdoc"
        ]
    },
    "application/beep+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/calendar+json": {
        "source": "iana",
        "compressible": true
    },
    "application/calendar+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xcs"
        ]
    },
    "application/call-completion": {
        "source": "iana"
    },
    "application/cals-1840": {
        "source": "iana"
    },
    "application/captive+json": {
        "source": "iana",
        "compressible": true
    },
    "application/cbor": {
        "source": "iana"
    },
    "application/cbor-seq": {
        "source": "iana"
    },
    "application/cccex": {
        "source": "iana"
    },
    "application/ccmp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/ccxml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ccxml"
        ]
    },
    "application/cdfx+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "cdfx"
        ]
    },
    "application/cdmi-capability": {
        "source": "iana",
        "extensions": [
            "cdmia"
        ]
    },
    "application/cdmi-container": {
        "source": "iana",
        "extensions": [
            "cdmic"
        ]
    },
    "application/cdmi-domain": {
        "source": "iana",
        "extensions": [
            "cdmid"
        ]
    },
    "application/cdmi-object": {
        "source": "iana",
        "extensions": [
            "cdmio"
        ]
    },
    "application/cdmi-queue": {
        "source": "iana",
        "extensions": [
            "cdmiq"
        ]
    },
    "application/cdni": {
        "source": "iana"
    },
    "application/cea": {
        "source": "iana"
    },
    "application/cea-2018+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/cellml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/cfw": {
        "source": "iana"
    },
    "application/city+json": {
        "source": "iana",
        "compressible": true
    },
    "application/clr": {
        "source": "iana"
    },
    "application/clue+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/clue_info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/cms": {
        "source": "iana"
    },
    "application/cnrp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/coap-group+json": {
        "source": "iana",
        "compressible": true
    },
    "application/coap-payload": {
        "source": "iana"
    },
    "application/commonground": {
        "source": "iana"
    },
    "application/conference-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/cose": {
        "source": "iana"
    },
    "application/cose-key": {
        "source": "iana"
    },
    "application/cose-key-set": {
        "source": "iana"
    },
    "application/cpl+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "cpl"
        ]
    },
    "application/csrattrs": {
        "source": "iana"
    },
    "application/csta+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/cstadata+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/csvm+json": {
        "source": "iana",
        "compressible": true
    },
    "application/cu-seeme": {
        "source": "apache",
        "extensions": [
            "cu"
        ]
    },
    "application/cwt": {
        "source": "iana"
    },
    "application/cybercash": {
        "source": "iana"
    },
    "application/dart": {
        "compressible": true
    },
    "application/dash+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mpd"
        ]
    },
    "application/dash-patch+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mpp"
        ]
    },
    "application/dashdelta": {
        "source": "iana"
    },
    "application/davmount+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "davmount"
        ]
    },
    "application/dca-rft": {
        "source": "iana"
    },
    "application/dcd": {
        "source": "iana"
    },
    "application/dec-dx": {
        "source": "iana"
    },
    "application/dialog-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/dicom": {
        "source": "iana"
    },
    "application/dicom+json": {
        "source": "iana",
        "compressible": true
    },
    "application/dicom+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/dii": {
        "source": "iana"
    },
    "application/dit": {
        "source": "iana"
    },
    "application/dns": {
        "source": "iana"
    },
    "application/dns+json": {
        "source": "iana",
        "compressible": true
    },
    "application/dns-message": {
        "source": "iana"
    },
    "application/docbook+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "dbk"
        ]
    },
    "application/dots+cbor": {
        "source": "iana"
    },
    "application/dskpp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/dssc+der": {
        "source": "iana",
        "extensions": [
            "dssc"
        ]
    },
    "application/dssc+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xdssc"
        ]
    },
    "application/dvcs": {
        "source": "iana"
    },
    "application/ecmascript": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "es",
            "ecma"
        ]
    },
    "application/edi-consent": {
        "source": "iana"
    },
    "application/edi-x12": {
        "source": "iana",
        "compressible": false
    },
    "application/edifact": {
        "source": "iana",
        "compressible": false
    },
    "application/efi": {
        "source": "iana"
    },
    "application/elm+json": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/elm+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.cap+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/emergencycalldata.comment+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.control+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.deviceinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.ecall.msd": {
        "source": "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.serviceinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emergencycalldata.veds+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/emma+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "emma"
        ]
    },
    "application/emotionml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "emotionml"
        ]
    },
    "application/encaprtp": {
        "source": "iana"
    },
    "application/epp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/epub+zip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "epub"
        ]
    },
    "application/eshop": {
        "source": "iana"
    },
    "application/exi": {
        "source": "iana",
        "extensions": [
            "exi"
        ]
    },
    "application/expect-ct-report+json": {
        "source": "iana",
        "compressible": true
    },
    "application/express": {
        "source": "iana",
        "extensions": [
            "exp"
        ]
    },
    "application/fastinfoset": {
        "source": "iana"
    },
    "application/fastsoap": {
        "source": "iana"
    },
    "application/fdt+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "fdt"
        ]
    },
    "application/fhir+json": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/fhir+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/fido.trusted-apps+json": {
        "compressible": true
    },
    "application/fits": {
        "source": "iana"
    },
    "application/flexfec": {
        "source": "iana"
    },
    "application/font-sfnt": {
        "source": "iana"
    },
    "application/font-tdpfr": {
        "source": "iana",
        "extensions": [
            "pfr"
        ]
    },
    "application/font-woff": {
        "source": "iana",
        "compressible": false
    },
    "application/framework-attributes+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/geo+json": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "geojson"
        ]
    },
    "application/geo+json-seq": {
        "source": "iana"
    },
    "application/geopackage+sqlite3": {
        "source": "iana"
    },
    "application/geoxacml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/gltf-buffer": {
        "source": "iana"
    },
    "application/gml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "gml"
        ]
    },
    "application/gpx+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "gpx"
        ]
    },
    "application/gxf": {
        "source": "apache",
        "extensions": [
            "gxf"
        ]
    },
    "application/gzip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "gz"
        ]
    },
    "application/h224": {
        "source": "iana"
    },
    "application/held+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/hjson": {
        "extensions": [
            "hjson"
        ]
    },
    "application/http": {
        "source": "iana"
    },
    "application/hyperstudio": {
        "source": "iana",
        "extensions": [
            "stk"
        ]
    },
    "application/ibe-key-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/ibe-pkg-reply+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/ibe-pp-data": {
        "source": "iana"
    },
    "application/iges": {
        "source": "iana"
    },
    "application/im-iscomposing+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/index": {
        "source": "iana"
    },
    "application/index.cmd": {
        "source": "iana"
    },
    "application/index.obj": {
        "source": "iana"
    },
    "application/index.response": {
        "source": "iana"
    },
    "application/index.vnd": {
        "source": "iana"
    },
    "application/inkml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ink",
            "inkml"
        ]
    },
    "application/iotp": {
        "source": "iana"
    },
    "application/ipfix": {
        "source": "iana",
        "extensions": [
            "ipfix"
        ]
    },
    "application/ipp": {
        "source": "iana"
    },
    "application/isup": {
        "source": "iana"
    },
    "application/its+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "its"
        ]
    },
    "application/java-archive": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "jar",
            "war",
            "ear"
        ]
    },
    "application/java-serialized-object": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "ser"
        ]
    },
    "application/java-vm": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "class"
        ]
    },
    "application/javascript": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "js",
            "mjs"
        ]
    },
    "application/jf2feed+json": {
        "source": "iana",
        "compressible": true
    },
    "application/jose": {
        "source": "iana"
    },
    "application/jose+json": {
        "source": "iana",
        "compressible": true
    },
    "application/jrd+json": {
        "source": "iana",
        "compressible": true
    },
    "application/jscalendar+json": {
        "source": "iana",
        "compressible": true
    },
    "application/json": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "json",
            "map"
        ]
    },
    "application/json-patch+json": {
        "source": "iana",
        "compressible": true
    },
    "application/json-seq": {
        "source": "iana"
    },
    "application/json5": {
        "extensions": [
            "json5"
        ]
    },
    "application/jsonml+json": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "jsonml"
        ]
    },
    "application/jwk+json": {
        "source": "iana",
        "compressible": true
    },
    "application/jwk-set+json": {
        "source": "iana",
        "compressible": true
    },
    "application/jwt": {
        "source": "iana"
    },
    "application/kpml-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/kpml-response+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/ld+json": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "jsonld"
        ]
    },
    "application/lgr+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "lgr"
        ]
    },
    "application/link-format": {
        "source": "iana"
    },
    "application/load-control+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/lost+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "lostxml"
        ]
    },
    "application/lostsync+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/lpf+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/lxf": {
        "source": "iana"
    },
    "application/mac-binhex40": {
        "source": "iana",
        "extensions": [
            "hqx"
        ]
    },
    "application/mac-compactpro": {
        "source": "apache",
        "extensions": [
            "cpt"
        ]
    },
    "application/macwriteii": {
        "source": "iana"
    },
    "application/mads+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mads"
        ]
    },
    "application/manifest+json": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "webmanifest"
        ]
    },
    "application/marc": {
        "source": "iana",
        "extensions": [
            "mrc"
        ]
    },
    "application/marcxml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mrcx"
        ]
    },
    "application/mathematica": {
        "source": "iana",
        "extensions": [
            "ma",
            "nb",
            "mb"
        ]
    },
    "application/mathml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mathml"
        ]
    },
    "application/mathml-content+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mathml-presentation+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-associated-procedure-description+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-deregister+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-envelope+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-msk+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-msk-response+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-protection-description+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-reception-report+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-register+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-register-response+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-schedule+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbms-user-service-description+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mbox": {
        "source": "iana",
        "extensions": [
            "mbox"
        ]
    },
    "application/media-policy-dataset+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mpf"
        ]
    },
    "application/media_control+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mediaservercontrol+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mscml"
        ]
    },
    "application/merge-patch+json": {
        "source": "iana",
        "compressible": true
    },
    "application/metalink+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "metalink"
        ]
    },
    "application/metalink4+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "meta4"
        ]
    },
    "application/mets+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mets"
        ]
    },
    "application/mf4": {
        "source": "iana"
    },
    "application/mikey": {
        "source": "iana"
    },
    "application/mipc": {
        "source": "iana"
    },
    "application/missing-blocks+cbor-seq": {
        "source": "iana"
    },
    "application/mmt-aei+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "maei"
        ]
    },
    "application/mmt-usd+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "musd"
        ]
    },
    "application/mods+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mods"
        ]
    },
    "application/moss-keys": {
        "source": "iana"
    },
    "application/moss-signature": {
        "source": "iana"
    },
    "application/mosskey-data": {
        "source": "iana"
    },
    "application/mosskey-request": {
        "source": "iana"
    },
    "application/mp21": {
        "source": "iana",
        "extensions": [
            "m21",
            "mp21"
        ]
    },
    "application/mp4": {
        "source": "iana",
        "extensions": [
            "mp4s",
            "m4p"
        ]
    },
    "application/mpeg4-generic": {
        "source": "iana"
    },
    "application/mpeg4-iod": {
        "source": "iana"
    },
    "application/mpeg4-iod-xmt": {
        "source": "iana"
    },
    "application/mrb-consumer+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/mrb-publish+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/msc-ivr+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/msc-mixer+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/msword": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "doc",
            "dot"
        ]
    },
    "application/mud+json": {
        "source": "iana",
        "compressible": true
    },
    "application/multipart-core": {
        "source": "iana"
    },
    "application/mxf": {
        "source": "iana",
        "extensions": [
            "mxf"
        ]
    },
    "application/n-quads": {
        "source": "iana",
        "extensions": [
            "nq"
        ]
    },
    "application/n-triples": {
        "source": "iana",
        "extensions": [
            "nt"
        ]
    },
    "application/nasdata": {
        "source": "iana"
    },
    "application/news-checkgroups": {
        "source": "iana",
        "charset": "US-ASCII"
    },
    "application/news-groupinfo": {
        "source": "iana",
        "charset": "US-ASCII"
    },
    "application/news-transmission": {
        "source": "iana"
    },
    "application/nlsml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/node": {
        "source": "iana",
        "extensions": [
            "cjs"
        ]
    },
    "application/nss": {
        "source": "iana"
    },
    "application/oauth-authz-req+jwt": {
        "source": "iana"
    },
    "application/oblivious-dns-message": {
        "source": "iana"
    },
    "application/ocsp-request": {
        "source": "iana"
    },
    "application/ocsp-response": {
        "source": "iana"
    },
    "application/octet-stream": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "bin",
            "dms",
            "lrf",
            "mar",
            "so",
            "dist",
            "distz",
            "pkg",
            "bpk",
            "dump",
            "elc",
            "deploy",
            "exe",
            "dll",
            "deb",
            "dmg",
            "iso",
            "img",
            "msi",
            "msp",
            "msm",
            "buffer"
        ]
    },
    "application/oda": {
        "source": "iana",
        "extensions": [
            "oda"
        ]
    },
    "application/odm+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/odx": {
        "source": "iana"
    },
    "application/oebps-package+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "opf"
        ]
    },
    "application/ogg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "ogx"
        ]
    },
    "application/omdoc+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "omdoc"
        ]
    },
    "application/onenote": {
        "source": "apache",
        "extensions": [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ]
    },
    "application/opc-nodeset+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/oscore": {
        "source": "iana"
    },
    "application/oxps": {
        "source": "iana",
        "extensions": [
            "oxps"
        ]
    },
    "application/p21": {
        "source": "iana"
    },
    "application/p21+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/p2p-overlay+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "relo"
        ]
    },
    "application/parityfec": {
        "source": "iana"
    },
    "application/passport": {
        "source": "iana"
    },
    "application/patch-ops-error+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xer"
        ]
    },
    "application/pdf": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "pdf"
        ]
    },
    "application/pdx": {
        "source": "iana"
    },
    "application/pem-certificate-chain": {
        "source": "iana"
    },
    "application/pgp-encrypted": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "pgp"
        ]
    },
    "application/pgp-keys": {
        "source": "iana",
        "extensions": [
            "asc"
        ]
    },
    "application/pgp-signature": {
        "source": "iana",
        "extensions": [
            "asc",
            "sig"
        ]
    },
    "application/pics-rules": {
        "source": "apache",
        "extensions": [
            "prf"
        ]
    },
    "application/pidf+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/pidf-diff+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/pkcs10": {
        "source": "iana",
        "extensions": [
            "p10"
        ]
    },
    "application/pkcs12": {
        "source": "iana"
    },
    "application/pkcs7-mime": {
        "source": "iana",
        "extensions": [
            "p7m",
            "p7c"
        ]
    },
    "application/pkcs7-signature": {
        "source": "iana",
        "extensions": [
            "p7s"
        ]
    },
    "application/pkcs8": {
        "source": "iana",
        "extensions": [
            "p8"
        ]
    },
    "application/pkcs8-encrypted": {
        "source": "iana"
    },
    "application/pkix-attr-cert": {
        "source": "iana",
        "extensions": [
            "ac"
        ]
    },
    "application/pkix-cert": {
        "source": "iana",
        "extensions": [
            "cer"
        ]
    },
    "application/pkix-crl": {
        "source": "iana",
        "extensions": [
            "crl"
        ]
    },
    "application/pkix-pkipath": {
        "source": "iana",
        "extensions": [
            "pkipath"
        ]
    },
    "application/pkixcmp": {
        "source": "iana",
        "extensions": [
            "pki"
        ]
    },
    "application/pls+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "pls"
        ]
    },
    "application/poc-settings+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/postscript": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ai",
            "eps",
            "ps"
        ]
    },
    "application/ppsp-tracker+json": {
        "source": "iana",
        "compressible": true
    },
    "application/problem+json": {
        "source": "iana",
        "compressible": true
    },
    "application/problem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/provenance+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "provx"
        ]
    },
    "application/prs.alvestrand.titrax-sheet": {
        "source": "iana"
    },
    "application/prs.cww": {
        "source": "iana",
        "extensions": [
            "cww"
        ]
    },
    "application/prs.cyn": {
        "source": "iana",
        "charset": "7-BIT"
    },
    "application/prs.hpub+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/prs.nprend": {
        "source": "iana"
    },
    "application/prs.plucker": {
        "source": "iana"
    },
    "application/prs.rdf-xml-crypt": {
        "source": "iana"
    },
    "application/prs.xsf+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/pskc+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "pskcxml"
        ]
    },
    "application/pvd+json": {
        "source": "iana",
        "compressible": true
    },
    "application/qsig": {
        "source": "iana"
    },
    "application/raml+yaml": {
        "compressible": true,
        "extensions": [
            "raml"
        ]
    },
    "application/raptorfec": {
        "source": "iana"
    },
    "application/rdap+json": {
        "source": "iana",
        "compressible": true
    },
    "application/rdf+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rdf",
            "owl"
        ]
    },
    "application/reginfo+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rif"
        ]
    },
    "application/relax-ng-compact-syntax": {
        "source": "iana",
        "extensions": [
            "rnc"
        ]
    },
    "application/remote-printing": {
        "source": "iana"
    },
    "application/reputon+json": {
        "source": "iana",
        "compressible": true
    },
    "application/resource-lists+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rl"
        ]
    },
    "application/resource-lists-diff+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rld"
        ]
    },
    "application/rfc+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/riscos": {
        "source": "iana"
    },
    "application/rlmi+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/rls-services+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rs"
        ]
    },
    "application/route-apd+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rapd"
        ]
    },
    "application/route-s-tsid+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "sls"
        ]
    },
    "application/route-usd+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rusd"
        ]
    },
    "application/rpki-ghostbusters": {
        "source": "iana",
        "extensions": [
            "gbr"
        ]
    },
    "application/rpki-manifest": {
        "source": "iana",
        "extensions": [
            "mft"
        ]
    },
    "application/rpki-publication": {
        "source": "iana"
    },
    "application/rpki-roa": {
        "source": "iana",
        "extensions": [
            "roa"
        ]
    },
    "application/rpki-updown": {
        "source": "iana"
    },
    "application/rsd+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "rsd"
        ]
    },
    "application/rss+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "rss"
        ]
    },
    "application/rtf": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rtf"
        ]
    },
    "application/rtploopback": {
        "source": "iana"
    },
    "application/rtx": {
        "source": "iana"
    },
    "application/samlassertion+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/samlmetadata+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/sarif+json": {
        "source": "iana",
        "compressible": true
    },
    "application/sarif-external-properties+json": {
        "source": "iana",
        "compressible": true
    },
    "application/sbe": {
        "source": "iana"
    },
    "application/sbml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "sbml"
        ]
    },
    "application/scaip+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/scim+json": {
        "source": "iana",
        "compressible": true
    },
    "application/scvp-cv-request": {
        "source": "iana",
        "extensions": [
            "scq"
        ]
    },
    "application/scvp-cv-response": {
        "source": "iana",
        "extensions": [
            "scs"
        ]
    },
    "application/scvp-vp-request": {
        "source": "iana",
        "extensions": [
            "spq"
        ]
    },
    "application/scvp-vp-response": {
        "source": "iana",
        "extensions": [
            "spp"
        ]
    },
    "application/sdp": {
        "source": "iana",
        "extensions": [
            "sdp"
        ]
    },
    "application/secevent+jwt": {
        "source": "iana"
    },
    "application/senml+cbor": {
        "source": "iana"
    },
    "application/senml+json": {
        "source": "iana",
        "compressible": true
    },
    "application/senml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "senmlx"
        ]
    },
    "application/senml-etch+cbor": {
        "source": "iana"
    },
    "application/senml-etch+json": {
        "source": "iana",
        "compressible": true
    },
    "application/senml-exi": {
        "source": "iana"
    },
    "application/sensml+cbor": {
        "source": "iana"
    },
    "application/sensml+json": {
        "source": "iana",
        "compressible": true
    },
    "application/sensml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "sensmlx"
        ]
    },
    "application/sensml-exi": {
        "source": "iana"
    },
    "application/sep+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/sep-exi": {
        "source": "iana"
    },
    "application/session-info": {
        "source": "iana"
    },
    "application/set-payment": {
        "source": "iana"
    },
    "application/set-payment-initiation": {
        "source": "iana",
        "extensions": [
            "setpay"
        ]
    },
    "application/set-registration": {
        "source": "iana"
    },
    "application/set-registration-initiation": {
        "source": "iana",
        "extensions": [
            "setreg"
        ]
    },
    "application/sgml": {
        "source": "iana"
    },
    "application/sgml-open-catalog": {
        "source": "iana"
    },
    "application/shf+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "shf"
        ]
    },
    "application/sieve": {
        "source": "iana",
        "extensions": [
            "siv",
            "sieve"
        ]
    },
    "application/simple-filter+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/simple-message-summary": {
        "source": "iana"
    },
    "application/simplesymbolcontainer": {
        "source": "iana"
    },
    "application/sipc": {
        "source": "iana"
    },
    "application/slate": {
        "source": "iana"
    },
    "application/smil": {
        "source": "iana"
    },
    "application/smil+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "smi",
            "smil"
        ]
    },
    "application/smpte336m": {
        "source": "iana"
    },
    "application/soap+fastinfoset": {
        "source": "iana"
    },
    "application/soap+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/sparql-query": {
        "source": "iana",
        "extensions": [
            "rq"
        ]
    },
    "application/sparql-results+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "srx"
        ]
    },
    "application/spdx+json": {
        "source": "iana",
        "compressible": true
    },
    "application/spirits-event+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/sql": {
        "source": "iana"
    },
    "application/srgs": {
        "source": "iana",
        "extensions": [
            "gram"
        ]
    },
    "application/srgs+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "grxml"
        ]
    },
    "application/sru+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "sru"
        ]
    },
    "application/ssdl+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "ssdl"
        ]
    },
    "application/ssml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ssml"
        ]
    },
    "application/stix+json": {
        "source": "iana",
        "compressible": true
    },
    "application/swid+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "swidtag"
        ]
    },
    "application/tamp-apex-update": {
        "source": "iana"
    },
    "application/tamp-apex-update-confirm": {
        "source": "iana"
    },
    "application/tamp-community-update": {
        "source": "iana"
    },
    "application/tamp-community-update-confirm": {
        "source": "iana"
    },
    "application/tamp-error": {
        "source": "iana"
    },
    "application/tamp-sequence-adjust": {
        "source": "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
        "source": "iana"
    },
    "application/tamp-status-query": {
        "source": "iana"
    },
    "application/tamp-status-response": {
        "source": "iana"
    },
    "application/tamp-update": {
        "source": "iana"
    },
    "application/tamp-update-confirm": {
        "source": "iana"
    },
    "application/tar": {
        "compressible": true
    },
    "application/taxii+json": {
        "source": "iana",
        "compressible": true
    },
    "application/td+json": {
        "source": "iana",
        "compressible": true
    },
    "application/tei+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "tei",
            "teicorpus"
        ]
    },
    "application/tetra_isi": {
        "source": "iana"
    },
    "application/thraud+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "tfi"
        ]
    },
    "application/timestamp-query": {
        "source": "iana"
    },
    "application/timestamp-reply": {
        "source": "iana"
    },
    "application/timestamped-data": {
        "source": "iana",
        "extensions": [
            "tsd"
        ]
    },
    "application/tlsrpt+gzip": {
        "source": "iana"
    },
    "application/tlsrpt+json": {
        "source": "iana",
        "compressible": true
    },
    "application/tnauthlist": {
        "source": "iana"
    },
    "application/token-introspection+jwt": {
        "source": "iana"
    },
    "application/toml": {
        "compressible": true,
        "extensions": [
            "toml"
        ]
    },
    "application/trickle-ice-sdpfrag": {
        "source": "iana"
    },
    "application/trig": {
        "source": "iana",
        "extensions": [
            "trig"
        ]
    },
    "application/ttml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ttml"
        ]
    },
    "application/tve-trigger": {
        "source": "iana"
    },
    "application/tzif": {
        "source": "iana"
    },
    "application/tzif-leap": {
        "source": "iana"
    },
    "application/ubjson": {
        "compressible": false,
        "extensions": [
            "ubj"
        ]
    },
    "application/ulpfec": {
        "source": "iana"
    },
    "application/urc-grpsheet+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/urc-ressheet+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rsheet"
        ]
    },
    "application/urc-targetdesc+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "td"
        ]
    },
    "application/urc-uisocketdesc+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vcard+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vcard+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vemmi": {
        "source": "iana"
    },
    "application/vividence.scriptfile": {
        "source": "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "1km"
        ]
    },
    "application/vnd.3gpp-prose+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
        "source": "iana"
    },
    "application/vnd.3gpp.5gnas": {
        "source": "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.bsf+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.gmop+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.gtpc": {
        "source": "iana"
    },
    "application/vnd.3gpp.interworking-data": {
        "source": "iana"
    },
    "application/vnd.3gpp.lpp": {
        "source": "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
        "source": "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcdata-payload": {
        "source": "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcdata-signalling": {
        "source": "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.mid-call+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.ngap": {
        "source": "iana"
    },
    "application/vnd.3gpp.pfcp": {
        "source": "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
        "source": "iana",
        "extensions": [
            "plb"
        ]
    },
    "application/vnd.3gpp.pic-bw-small": {
        "source": "iana",
        "extensions": [
            "psb"
        ]
    },
    "application/vnd.3gpp.pic-bw-var": {
        "source": "iana",
        "extensions": [
            "pvb"
        ]
    },
    "application/vnd.3gpp.s1ap": {
        "source": "iana"
    },
    "application/vnd.3gpp.sms": {
        "source": "iana"
    },
    "application/vnd.3gpp.sms+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp.ussd+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.3gpp2.sms": {
        "source": "iana"
    },
    "application/vnd.3gpp2.tcap": {
        "source": "iana",
        "extensions": [
            "tcap"
        ]
    },
    "application/vnd.3lightssoftware.imagescal": {
        "source": "iana"
    },
    "application/vnd.3m.post-it-notes": {
        "source": "iana",
        "extensions": [
            "pwn"
        ]
    },
    "application/vnd.accpac.simply.aso": {
        "source": "iana",
        "extensions": [
            "aso"
        ]
    },
    "application/vnd.accpac.simply.imp": {
        "source": "iana",
        "extensions": [
            "imp"
        ]
    },
    "application/vnd.acucobol": {
        "source": "iana",
        "extensions": [
            "acu"
        ]
    },
    "application/vnd.acucorp": {
        "source": "iana",
        "extensions": [
            "atc",
            "acutc"
        ]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "air"
        ]
    },
    "application/vnd.adobe.flash.movie": {
        "source": "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
        "source": "iana",
        "extensions": [
            "fcdt"
        ]
    },
    "application/vnd.adobe.fxp": {
        "source": "iana",
        "extensions": [
            "fxp",
            "fxpl"
        ]
    },
    "application/vnd.adobe.partial-upload": {
        "source": "iana"
    },
    "application/vnd.adobe.xdp+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xdp"
        ]
    },
    "application/vnd.adobe.xfdf": {
        "source": "iana",
        "extensions": [
            "xfdf"
        ]
    },
    "application/vnd.aether.imp": {
        "source": "iana"
    },
    "application/vnd.afpc.afplinedata": {
        "source": "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
        "source": "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
        "source": "iana"
    },
    "application/vnd.afpc.foca-charset": {
        "source": "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
        "source": "iana"
    },
    "application/vnd.afpc.foca-codepage": {
        "source": "iana"
    },
    "application/vnd.afpc.modca": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-formdef": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-overlay": {
        "source": "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
        "source": "iana"
    },
    "application/vnd.age": {
        "source": "iana",
        "extensions": [
            "age"
        ]
    },
    "application/vnd.ah-barcode": {
        "source": "iana"
    },
    "application/vnd.ahead.space": {
        "source": "iana",
        "extensions": [
            "ahead"
        ]
    },
    "application/vnd.airzip.filesecure.azf": {
        "source": "iana",
        "extensions": [
            "azf"
        ]
    },
    "application/vnd.airzip.filesecure.azs": {
        "source": "iana",
        "extensions": [
            "azs"
        ]
    },
    "application/vnd.amadeus+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.amazon.ebook": {
        "source": "apache",
        "extensions": [
            "azw"
        ]
    },
    "application/vnd.amazon.mobi8-ebook": {
        "source": "iana"
    },
    "application/vnd.americandynamics.acc": {
        "source": "iana",
        "extensions": [
            "acc"
        ]
    },
    "application/vnd.amiga.ami": {
        "source": "iana",
        "extensions": [
            "ami"
        ]
    },
    "application/vnd.amundsen.maze+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.android.ota": {
        "source": "iana"
    },
    "application/vnd.android.package-archive": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "apk"
        ]
    },
    "application/vnd.anki": {
        "source": "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
        "source": "iana",
        "extensions": [
            "cii"
        ]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
        "source": "apache",
        "extensions": [
            "fti"
        ]
    },
    "application/vnd.antix.game-component": {
        "source": "iana",
        "extensions": [
            "atx"
        ]
    },
    "application/vnd.apache.arrow.file": {
        "source": "iana"
    },
    "application/vnd.apache.arrow.stream": {
        "source": "iana"
    },
    "application/vnd.apache.thrift.binary": {
        "source": "iana"
    },
    "application/vnd.apache.thrift.compact": {
        "source": "iana"
    },
    "application/vnd.apache.thrift.json": {
        "source": "iana"
    },
    "application/vnd.api+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.aplextor.warrp+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.apothekende.reservation+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.apple.installer+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mpkg"
        ]
    },
    "application/vnd.apple.keynote": {
        "source": "iana",
        "extensions": [
            "key"
        ]
    },
    "application/vnd.apple.mpegurl": {
        "source": "iana",
        "extensions": [
            "m3u8"
        ]
    },
    "application/vnd.apple.numbers": {
        "source": "iana",
        "extensions": [
            "numbers"
        ]
    },
    "application/vnd.apple.pages": {
        "source": "iana",
        "extensions": [
            "pages"
        ]
    },
    "application/vnd.apple.pkpass": {
        "compressible": false,
        "extensions": [
            "pkpass"
        ]
    },
    "application/vnd.arastra.swi": {
        "source": "iana"
    },
    "application/vnd.aristanetworks.swi": {
        "source": "iana",
        "extensions": [
            "swi"
        ]
    },
    "application/vnd.artisan+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.artsquare": {
        "source": "iana"
    },
    "application/vnd.astraea-software.iota": {
        "source": "iana",
        "extensions": [
            "iota"
        ]
    },
    "application/vnd.audiograph": {
        "source": "iana",
        "extensions": [
            "aep"
        ]
    },
    "application/vnd.autopackage": {
        "source": "iana"
    },
    "application/vnd.avalon+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.avistar+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.balsamiq.bmml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "bmml"
        ]
    },
    "application/vnd.balsamiq.bmpr": {
        "source": "iana"
    },
    "application/vnd.banana-accounting": {
        "source": "iana"
    },
    "application/vnd.bbf.usp.error": {
        "source": "iana"
    },
    "application/vnd.bbf.usp.msg": {
        "source": "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.bekitzur-stech+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.bint.med-content": {
        "source": "iana"
    },
    "application/vnd.biopax.rdf+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.blink-idb-value-wrapper": {
        "source": "iana"
    },
    "application/vnd.blueice.multipass": {
        "source": "iana",
        "extensions": [
            "mpm"
        ]
    },
    "application/vnd.bluetooth.ep.oob": {
        "source": "iana"
    },
    "application/vnd.bluetooth.le.oob": {
        "source": "iana"
    },
    "application/vnd.bmi": {
        "source": "iana",
        "extensions": [
            "bmi"
        ]
    },
    "application/vnd.bpf": {
        "source": "iana"
    },
    "application/vnd.bpf3": {
        "source": "iana"
    },
    "application/vnd.businessobjects": {
        "source": "iana",
        "extensions": [
            "rep"
        ]
    },
    "application/vnd.byu.uapi+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cab-jscript": {
        "source": "iana"
    },
    "application/vnd.canon-cpdl": {
        "source": "iana"
    },
    "application/vnd.canon-lips": {
        "source": "iana"
    },
    "application/vnd.capasystems-pg+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
        "source": "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
        "source": "iana"
    },
    "application/vnd.chemdraw+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "cdxml"
        ]
    },
    "application/vnd.chess-pgn": {
        "source": "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
        "source": "iana",
        "extensions": [
            "mmd"
        ]
    },
    "application/vnd.ciedi": {
        "source": "iana"
    },
    "application/vnd.cinderella": {
        "source": "iana",
        "extensions": [
            "cdy"
        ]
    },
    "application/vnd.cirpack.isdn-ext": {
        "source": "iana"
    },
    "application/vnd.citationstyles.style+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "csl"
        ]
    },
    "application/vnd.claymore": {
        "source": "iana",
        "extensions": [
            "cla"
        ]
    },
    "application/vnd.cloanto.rp9": {
        "source": "iana",
        "extensions": [
            "rp9"
        ]
    },
    "application/vnd.clonk.c4group": {
        "source": "iana",
        "extensions": [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config": {
        "source": "iana",
        "extensions": [
            "c11amc"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
        "source": "iana",
        "extensions": [
            "c11amz"
        ]
    },
    "application/vnd.coffeescript": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
        "source": "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
        "source": "iana"
    },
    "application/vnd.collection+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.collection.doc+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.collection.next+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.comicbook+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.comicbook-rar": {
        "source": "iana"
    },
    "application/vnd.commerce-battelle": {
        "source": "iana"
    },
    "application/vnd.commonspace": {
        "source": "iana",
        "extensions": [
            "csp"
        ]
    },
    "application/vnd.contact.cmsg": {
        "source": "iana",
        "extensions": [
            "cdbcmsg"
        ]
    },
    "application/vnd.coreos.ignition+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cosmocaller": {
        "source": "iana",
        "extensions": [
            "cmc"
        ]
    },
    "application/vnd.crick.clicker": {
        "source": "iana",
        "extensions": [
            "clkx"
        ]
    },
    "application/vnd.crick.clicker.keyboard": {
        "source": "iana",
        "extensions": [
            "clkk"
        ]
    },
    "application/vnd.crick.clicker.palette": {
        "source": "iana",
        "extensions": [
            "clkp"
        ]
    },
    "application/vnd.crick.clicker.template": {
        "source": "iana",
        "extensions": [
            "clkt"
        ]
    },
    "application/vnd.crick.clicker.wordbank": {
        "source": "iana",
        "extensions": [
            "clkw"
        ]
    },
    "application/vnd.criticaltools.wbs+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wbs"
        ]
    },
    "application/vnd.cryptii.pipe+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.crypto-shade-file": {
        "source": "iana"
    },
    "application/vnd.cryptomator.encrypted": {
        "source": "iana"
    },
    "application/vnd.cryptomator.vault": {
        "source": "iana"
    },
    "application/vnd.ctc-posml": {
        "source": "iana",
        "extensions": [
            "pml"
        ]
    },
    "application/vnd.ctct.ws+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cups-pdf": {
        "source": "iana"
    },
    "application/vnd.cups-postscript": {
        "source": "iana"
    },
    "application/vnd.cups-ppd": {
        "source": "iana",
        "extensions": [
            "ppd"
        ]
    },
    "application/vnd.cups-raster": {
        "source": "iana"
    },
    "application/vnd.cups-raw": {
        "source": "iana"
    },
    "application/vnd.curl": {
        "source": "iana"
    },
    "application/vnd.curl.car": {
        "source": "apache",
        "extensions": [
            "car"
        ]
    },
    "application/vnd.curl.pcurl": {
        "source": "apache",
        "extensions": [
            "pcurl"
        ]
    },
    "application/vnd.cyan.dean.root+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cybank": {
        "source": "iana"
    },
    "application/vnd.cyclonedx+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.cyclonedx+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.d3m-dataset": {
        "source": "iana"
    },
    "application/vnd.d3m-problem": {
        "source": "iana"
    },
    "application/vnd.dart": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "dart"
        ]
    },
    "application/vnd.data-vision.rdz": {
        "source": "iana",
        "extensions": [
            "rdz"
        ]
    },
    "application/vnd.datapackage+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dataresource+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dbf": {
        "source": "iana",
        "extensions": [
            "dbf"
        ]
    },
    "application/vnd.debian.binary-package": {
        "source": "iana"
    },
    "application/vnd.dece.data": {
        "source": "iana",
        "extensions": [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ]
    },
    "application/vnd.dece.ttml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "uvt",
            "uvvt"
        ]
    },
    "application/vnd.dece.unspecified": {
        "source": "iana",
        "extensions": [
            "uvx",
            "uvvx"
        ]
    },
    "application/vnd.dece.zip": {
        "source": "iana",
        "extensions": [
            "uvz",
            "uvvz"
        ]
    },
    "application/vnd.denovo.fcselayout-link": {
        "source": "iana",
        "extensions": [
            "fe_launch"
        ]
    },
    "application/vnd.desmume.movie": {
        "source": "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
        "source": "iana"
    },
    "application/vnd.dm.delegation+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dna": {
        "source": "iana",
        "extensions": [
            "dna"
        ]
    },
    "application/vnd.document+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dolby.mlp": {
        "source": "apache",
        "extensions": [
            "mlp"
        ]
    },
    "application/vnd.dolby.mobile.1": {
        "source": "iana"
    },
    "application/vnd.dolby.mobile.2": {
        "source": "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
        "source": "iana"
    },
    "application/vnd.dpgraph": {
        "source": "iana",
        "extensions": [
            "dpg"
        ]
    },
    "application/vnd.dreamfactory": {
        "source": "iana",
        "extensions": [
            "dfac"
        ]
    },
    "application/vnd.drive+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ds-keypoint": {
        "source": "apache",
        "extensions": [
            "kpxx"
        ]
    },
    "application/vnd.dtg.local": {
        "source": "iana"
    },
    "application/vnd.dtg.local.flash": {
        "source": "iana"
    },
    "application/vnd.dtg.local.html": {
        "source": "iana"
    },
    "application/vnd.dvb.ait": {
        "source": "iana",
        "extensions": [
            "ait"
        ]
    },
    "application/vnd.dvb.dvbisl+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.dvbj": {
        "source": "iana"
    },
    "application/vnd.dvb.esgcontainer": {
        "source": "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
        "source": "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
        "source": "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
        "source": "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
        "source": "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
        "source": "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
        "source": "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
        "source": "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-container+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-generic+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.notif-init+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.dvb.pfr": {
        "source": "iana"
    },
    "application/vnd.dvb.service": {
        "source": "iana",
        "extensions": [
            "svc"
        ]
    },
    "application/vnd.dxr": {
        "source": "iana"
    },
    "application/vnd.dynageo": {
        "source": "iana",
        "extensions": [
            "geo"
        ]
    },
    "application/vnd.dzr": {
        "source": "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
        "source": "iana"
    },
    "application/vnd.ecdis-update": {
        "source": "iana"
    },
    "application/vnd.ecip.rlp": {
        "source": "iana"
    },
    "application/vnd.eclipse.ditto+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ecowin.chart": {
        "source": "iana",
        "extensions": [
            "mag"
        ]
    },
    "application/vnd.ecowin.filerequest": {
        "source": "iana"
    },
    "application/vnd.ecowin.fileupdate": {
        "source": "iana"
    },
    "application/vnd.ecowin.series": {
        "source": "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
        "source": "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
        "source": "iana"
    },
    "application/vnd.efi.img": {
        "source": "iana"
    },
    "application/vnd.efi.iso": {
        "source": "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.enliven": {
        "source": "iana",
        "extensions": [
            "nml"
        ]
    },
    "application/vnd.enphase.envoy": {
        "source": "iana"
    },
    "application/vnd.eprints.data+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.epson.esf": {
        "source": "iana",
        "extensions": [
            "esf"
        ]
    },
    "application/vnd.epson.msf": {
        "source": "iana",
        "extensions": [
            "msf"
        ]
    },
    "application/vnd.epson.quickanime": {
        "source": "iana",
        "extensions": [
            "qam"
        ]
    },
    "application/vnd.epson.salt": {
        "source": "iana",
        "extensions": [
            "slt"
        ]
    },
    "application/vnd.epson.ssf": {
        "source": "iana",
        "extensions": [
            "ssf"
        ]
    },
    "application/vnd.ericsson.quickcall": {
        "source": "iana"
    },
    "application/vnd.espass-espass+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.eszigno3+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "es3",
            "et3"
        ]
    },
    "application/vnd.etsi.aoc+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.asic-e+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.etsi.asic-s+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.etsi.cug+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvcommand+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvprofile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvservice+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvsync+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.mcid+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.mheg5": {
        "source": "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.pstn+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.sci+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.simservs+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.timestamp-token": {
        "source": "iana"
    },
    "application/vnd.etsi.tsl+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.etsi.tsl.der": {
        "source": "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.eudora.data": {
        "source": "iana"
    },
    "application/vnd.evolv.ecig.profile": {
        "source": "iana"
    },
    "application/vnd.evolv.ecig.settings": {
        "source": "iana"
    },
    "application/vnd.evolv.ecig.theme": {
        "source": "iana"
    },
    "application/vnd.exstream-empower+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.exstream-package": {
        "source": "iana"
    },
    "application/vnd.ezpix-album": {
        "source": "iana",
        "extensions": [
            "ez2"
        ]
    },
    "application/vnd.ezpix-package": {
        "source": "iana",
        "extensions": [
            "ez3"
        ]
    },
    "application/vnd.f-secure.mobile": {
        "source": "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.fastcopy-disk-image": {
        "source": "iana"
    },
    "application/vnd.fdf": {
        "source": "iana",
        "extensions": [
            "fdf"
        ]
    },
    "application/vnd.fdsn.mseed": {
        "source": "iana",
        "extensions": [
            "mseed"
        ]
    },
    "application/vnd.fdsn.seed": {
        "source": "iana",
        "extensions": [
            "seed",
            "dataless"
        ]
    },
    "application/vnd.ffsns": {
        "source": "iana"
    },
    "application/vnd.ficlab.flb+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.filmit.zfc": {
        "source": "iana"
    },
    "application/vnd.fints": {
        "source": "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
        "source": "iana"
    },
    "application/vnd.flographit": {
        "source": "iana",
        "extensions": [
            "gph"
        ]
    },
    "application/vnd.fluxtime.clip": {
        "source": "iana",
        "extensions": [
            "ftc"
        ]
    },
    "application/vnd.font-fontforge-sfd": {
        "source": "iana"
    },
    "application/vnd.framemaker": {
        "source": "iana",
        "extensions": [
            "fm",
            "frame",
            "maker",
            "book"
        ]
    },
    "application/vnd.frogans.fnc": {
        "source": "iana",
        "extensions": [
            "fnc"
        ]
    },
    "application/vnd.frogans.ltf": {
        "source": "iana",
        "extensions": [
            "ltf"
        ]
    },
    "application/vnd.fsc.weblaunch": {
        "source": "iana",
        "extensions": [
            "fsc"
        ]
    },
    "application/vnd.fujifilm.fb.docuworks": {
        "source": "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
        "source": "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
        "source": "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.fujitsu.oasys": {
        "source": "iana",
        "extensions": [
            "oas"
        ]
    },
    "application/vnd.fujitsu.oasys2": {
        "source": "iana",
        "extensions": [
            "oa2"
        ]
    },
    "application/vnd.fujitsu.oasys3": {
        "source": "iana",
        "extensions": [
            "oa3"
        ]
    },
    "application/vnd.fujitsu.oasysgp": {
        "source": "iana",
        "extensions": [
            "fg5"
        ]
    },
    "application/vnd.fujitsu.oasysprs": {
        "source": "iana",
        "extensions": [
            "bh2"
        ]
    },
    "application/vnd.fujixerox.art-ex": {
        "source": "iana"
    },
    "application/vnd.fujixerox.art4": {
        "source": "iana"
    },
    "application/vnd.fujixerox.ddd": {
        "source": "iana",
        "extensions": [
            "ddd"
        ]
    },
    "application/vnd.fujixerox.docuworks": {
        "source": "iana",
        "extensions": [
            "xdw"
        ]
    },
    "application/vnd.fujixerox.docuworks.binder": {
        "source": "iana",
        "extensions": [
            "xbd"
        ]
    },
    "application/vnd.fujixerox.docuworks.container": {
        "source": "iana"
    },
    "application/vnd.fujixerox.hbpl": {
        "source": "iana"
    },
    "application/vnd.fut-misnet": {
        "source": "iana"
    },
    "application/vnd.futoin+cbor": {
        "source": "iana"
    },
    "application/vnd.futoin+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.fuzzysheet": {
        "source": "iana",
        "extensions": [
            "fzs"
        ]
    },
    "application/vnd.genomatix.tuxedo": {
        "source": "iana",
        "extensions": [
            "txd"
        ]
    },
    "application/vnd.gentics.grd+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.geo+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.geocube+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.geogebra.file": {
        "source": "iana",
        "extensions": [
            "ggb"
        ]
    },
    "application/vnd.geogebra.slides": {
        "source": "iana"
    },
    "application/vnd.geogebra.tool": {
        "source": "iana",
        "extensions": [
            "ggt"
        ]
    },
    "application/vnd.geometry-explorer": {
        "source": "iana",
        "extensions": [
            "gex",
            "gre"
        ]
    },
    "application/vnd.geonext": {
        "source": "iana",
        "extensions": [
            "gxt"
        ]
    },
    "application/vnd.geoplan": {
        "source": "iana",
        "extensions": [
            "g2w"
        ]
    },
    "application/vnd.geospace": {
        "source": "iana",
        "extensions": [
            "g3w"
        ]
    },
    "application/vnd.gerber": {
        "source": "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
        "source": "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
        "source": "iana"
    },
    "application/vnd.gmx": {
        "source": "iana",
        "extensions": [
            "gmx"
        ]
    },
    "application/vnd.google-apps.document": {
        "compressible": false,
        "extensions": [
            "gdoc"
        ]
    },
    "application/vnd.google-apps.presentation": {
        "compressible": false,
        "extensions": [
            "gslides"
        ]
    },
    "application/vnd.google-apps.spreadsheet": {
        "compressible": false,
        "extensions": [
            "gsheet"
        ]
    },
    "application/vnd.google-earth.kml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "kml"
        ]
    },
    "application/vnd.google-earth.kmz": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "kmz"
        ]
    },
    "application/vnd.gov.sk.e-form+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.gov.sk.e-form+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.grafeq": {
        "source": "iana",
        "extensions": [
            "gqf",
            "gqs"
        ]
    },
    "application/vnd.gridmp": {
        "source": "iana"
    },
    "application/vnd.groove-account": {
        "source": "iana",
        "extensions": [
            "gac"
        ]
    },
    "application/vnd.groove-help": {
        "source": "iana",
        "extensions": [
            "ghf"
        ]
    },
    "application/vnd.groove-identity-message": {
        "source": "iana",
        "extensions": [
            "gim"
        ]
    },
    "application/vnd.groove-injector": {
        "source": "iana",
        "extensions": [
            "grv"
        ]
    },
    "application/vnd.groove-tool-message": {
        "source": "iana",
        "extensions": [
            "gtm"
        ]
    },
    "application/vnd.groove-tool-template": {
        "source": "iana",
        "extensions": [
            "tpl"
        ]
    },
    "application/vnd.groove-vcard": {
        "source": "iana",
        "extensions": [
            "vcg"
        ]
    },
    "application/vnd.hal+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hal+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "hal"
        ]
    },
    "application/vnd.handheld-entertainment+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "zmm"
        ]
    },
    "application/vnd.hbci": {
        "source": "iana",
        "extensions": [
            "hbci"
        ]
    },
    "application/vnd.hc+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hcl-bireports": {
        "source": "iana"
    },
    "application/vnd.hdt": {
        "source": "iana"
    },
    "application/vnd.heroku+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hhe.lesson-player": {
        "source": "iana",
        "extensions": [
            "les"
        ]
    },
    "application/vnd.hl7cda+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.hl7v2+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.hp-hpgl": {
        "source": "iana",
        "extensions": [
            "hpgl"
        ]
    },
    "application/vnd.hp-hpid": {
        "source": "iana",
        "extensions": [
            "hpid"
        ]
    },
    "application/vnd.hp-hps": {
        "source": "iana",
        "extensions": [
            "hps"
        ]
    },
    "application/vnd.hp-jlyt": {
        "source": "iana",
        "extensions": [
            "jlt"
        ]
    },
    "application/vnd.hp-pcl": {
        "source": "iana",
        "extensions": [
            "pcl"
        ]
    },
    "application/vnd.hp-pclxl": {
        "source": "iana",
        "extensions": [
            "pclxl"
        ]
    },
    "application/vnd.httphone": {
        "source": "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
        "source": "iana",
        "extensions": [
            "sfd-hdstx"
        ]
    },
    "application/vnd.hyper+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hyper-item+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hyperdrive+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.hzn-3d-crossword": {
        "source": "iana"
    },
    "application/vnd.ibm.afplinedata": {
        "source": "iana"
    },
    "application/vnd.ibm.electronic-media": {
        "source": "iana"
    },
    "application/vnd.ibm.minipay": {
        "source": "iana",
        "extensions": [
            "mpy"
        ]
    },
    "application/vnd.ibm.modcap": {
        "source": "iana",
        "extensions": [
            "afp",
            "listafp",
            "list3820"
        ]
    },
    "application/vnd.ibm.rights-management": {
        "source": "iana",
        "extensions": [
            "irm"
        ]
    },
    "application/vnd.ibm.secure-container": {
        "source": "iana",
        "extensions": [
            "sc"
        ]
    },
    "application/vnd.iccprofile": {
        "source": "iana",
        "extensions": [
            "icc",
            "icm"
        ]
    },
    "application/vnd.ieee.1905": {
        "source": "iana"
    },
    "application/vnd.igloader": {
        "source": "iana",
        "extensions": [
            "igl"
        ]
    },
    "application/vnd.imagemeter.folder+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.imagemeter.image+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.immervision-ivp": {
        "source": "iana",
        "extensions": [
            "ivp"
        ]
    },
    "application/vnd.immervision-ivu": {
        "source": "iana",
        "extensions": [
            "ivu"
        ]
    },
    "application/vnd.ims.imsccv1p1": {
        "source": "iana"
    },
    "application/vnd.ims.imsccv1p2": {
        "source": "iana"
    },
    "application/vnd.ims.imsccv1p3": {
        "source": "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.informedcontrol.rms+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.informix-visionary": {
        "source": "iana"
    },
    "application/vnd.infotech.project": {
        "source": "iana"
    },
    "application/vnd.infotech.project+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.innopath.wamp.notification": {
        "source": "iana"
    },
    "application/vnd.insors.igm": {
        "source": "iana",
        "extensions": [
            "igm"
        ]
    },
    "application/vnd.intercon.formnet": {
        "source": "iana",
        "extensions": [
            "xpw",
            "xpx"
        ]
    },
    "application/vnd.intergeo": {
        "source": "iana",
        "extensions": [
            "i2g"
        ]
    },
    "application/vnd.intertrust.digibox": {
        "source": "iana"
    },
    "application/vnd.intertrust.nncp": {
        "source": "iana"
    },
    "application/vnd.intu.qbo": {
        "source": "iana",
        "extensions": [
            "qbo"
        ]
    },
    "application/vnd.intu.qfx": {
        "source": "iana",
        "extensions": [
            "qfx"
        ]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ipunplugged.rcprofile": {
        "source": "iana",
        "extensions": [
            "rcprofile"
        ]
    },
    "application/vnd.irepository.package+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "irp"
        ]
    },
    "application/vnd.is-xpr": {
        "source": "iana",
        "extensions": [
            "xpr"
        ]
    },
    "application/vnd.isac.fcs": {
        "source": "iana",
        "extensions": [
            "fcs"
        ]
    },
    "application/vnd.iso11783-10+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.jam": {
        "source": "iana",
        "extensions": [
            "jam"
        ]
    },
    "application/vnd.japannet-directory-service": {
        "source": "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
        "source": "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
        "source": "iana"
    },
    "application/vnd.japannet-registration": {
        "source": "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
        "source": "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
        "source": "iana"
    },
    "application/vnd.japannet-verification": {
        "source": "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
        "source": "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
        "source": "iana",
        "extensions": [
            "rms"
        ]
    },
    "application/vnd.jisp": {
        "source": "iana",
        "extensions": [
            "jisp"
        ]
    },
    "application/vnd.joost.joda-archive": {
        "source": "iana",
        "extensions": [
            "joda"
        ]
    },
    "application/vnd.jsk.isdn-ngn": {
        "source": "iana"
    },
    "application/vnd.kahootz": {
        "source": "iana",
        "extensions": [
            "ktz",
            "ktr"
        ]
    },
    "application/vnd.kde.karbon": {
        "source": "iana",
        "extensions": [
            "karbon"
        ]
    },
    "application/vnd.kde.kchart": {
        "source": "iana",
        "extensions": [
            "chrt"
        ]
    },
    "application/vnd.kde.kformula": {
        "source": "iana",
        "extensions": [
            "kfo"
        ]
    },
    "application/vnd.kde.kivio": {
        "source": "iana",
        "extensions": [
            "flw"
        ]
    },
    "application/vnd.kde.kontour": {
        "source": "iana",
        "extensions": [
            "kon"
        ]
    },
    "application/vnd.kde.kpresenter": {
        "source": "iana",
        "extensions": [
            "kpr",
            "kpt"
        ]
    },
    "application/vnd.kde.kspread": {
        "source": "iana",
        "extensions": [
            "ksp"
        ]
    },
    "application/vnd.kde.kword": {
        "source": "iana",
        "extensions": [
            "kwd",
            "kwt"
        ]
    },
    "application/vnd.kenameaapp": {
        "source": "iana",
        "extensions": [
            "htke"
        ]
    },
    "application/vnd.kidspiration": {
        "source": "iana",
        "extensions": [
            "kia"
        ]
    },
    "application/vnd.kinar": {
        "source": "iana",
        "extensions": [
            "kne",
            "knp"
        ]
    },
    "application/vnd.koan": {
        "source": "iana",
        "extensions": [
            "skp",
            "skd",
            "skt",
            "skm"
        ]
    },
    "application/vnd.kodak-descriptor": {
        "source": "iana",
        "extensions": [
            "sse"
        ]
    },
    "application/vnd.las": {
        "source": "iana"
    },
    "application/vnd.las.las+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.las.las+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "lasxml"
        ]
    },
    "application/vnd.laszip": {
        "source": "iana"
    },
    "application/vnd.leap+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.liberty-request+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
        "source": "iana",
        "extensions": [
            "lbd"
        ]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "lbe"
        ]
    },
    "application/vnd.logipipe.circuit+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.loom": {
        "source": "iana"
    },
    "application/vnd.lotus-1-2-3": {
        "source": "iana",
        "extensions": [
            "123"
        ]
    },
    "application/vnd.lotus-approach": {
        "source": "iana",
        "extensions": [
            "apr"
        ]
    },
    "application/vnd.lotus-freelance": {
        "source": "iana",
        "extensions": [
            "pre"
        ]
    },
    "application/vnd.lotus-notes": {
        "source": "iana",
        "extensions": [
            "nsf"
        ]
    },
    "application/vnd.lotus-organizer": {
        "source": "iana",
        "extensions": [
            "org"
        ]
    },
    "application/vnd.lotus-screencam": {
        "source": "iana",
        "extensions": [
            "scm"
        ]
    },
    "application/vnd.lotus-wordpro": {
        "source": "iana",
        "extensions": [
            "lwp"
        ]
    },
    "application/vnd.macports.portpkg": {
        "source": "iana",
        "extensions": [
            "portpkg"
        ]
    },
    "application/vnd.mapbox-vector-tile": {
        "source": "iana",
        "extensions": [
            "mvt"
        ]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.marlin.drm.license+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.marlin.drm.mdcf": {
        "source": "iana"
    },
    "application/vnd.mason+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.maxar.archive.3tz+zip": {
        "source": "iana",
        "compressible": false
    },
    "application/vnd.maxmind.maxmind-db": {
        "source": "iana"
    },
    "application/vnd.mcd": {
        "source": "iana",
        "extensions": [
            "mcd"
        ]
    },
    "application/vnd.medcalcdata": {
        "source": "iana",
        "extensions": [
            "mc1"
        ]
    },
    "application/vnd.mediastation.cdkey": {
        "source": "iana",
        "extensions": [
            "cdkey"
        ]
    },
    "application/vnd.meridian-slingshot": {
        "source": "iana"
    },
    "application/vnd.mfer": {
        "source": "iana",
        "extensions": [
            "mwf"
        ]
    },
    "application/vnd.mfmp": {
        "source": "iana",
        "extensions": [
            "mfm"
        ]
    },
    "application/vnd.micro+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.micrografx.flo": {
        "source": "iana",
        "extensions": [
            "flo"
        ]
    },
    "application/vnd.micrografx.igx": {
        "source": "iana",
        "extensions": [
            "igx"
        ]
    },
    "application/vnd.microsoft.portable-executable": {
        "source": "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
        "source": "iana"
    },
    "application/vnd.miele+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.mif": {
        "source": "iana",
        "extensions": [
            "mif"
        ]
    },
    "application/vnd.minisoft-hp3000-save": {
        "source": "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
        "source": "iana"
    },
    "application/vnd.mobius.daf": {
        "source": "iana",
        "extensions": [
            "daf"
        ]
    },
    "application/vnd.mobius.dis": {
        "source": "iana",
        "extensions": [
            "dis"
        ]
    },
    "application/vnd.mobius.mbk": {
        "source": "iana",
        "extensions": [
            "mbk"
        ]
    },
    "application/vnd.mobius.mqy": {
        "source": "iana",
        "extensions": [
            "mqy"
        ]
    },
    "application/vnd.mobius.msl": {
        "source": "iana",
        "extensions": [
            "msl"
        ]
    },
    "application/vnd.mobius.plc": {
        "source": "iana",
        "extensions": [
            "plc"
        ]
    },
    "application/vnd.mobius.txf": {
        "source": "iana",
        "extensions": [
            "txf"
        ]
    },
    "application/vnd.mophun.application": {
        "source": "iana",
        "extensions": [
            "mpn"
        ]
    },
    "application/vnd.mophun.certificate": {
        "source": "iana",
        "extensions": [
            "mpc"
        ]
    },
    "application/vnd.motorola.flexsuite": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
        "source": "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
        "source": "iana"
    },
    "application/vnd.motorola.iprm": {
        "source": "iana"
    },
    "application/vnd.mozilla.xul+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xul"
        ]
    },
    "application/vnd.ms-3mfdocument": {
        "source": "iana"
    },
    "application/vnd.ms-artgalry": {
        "source": "iana",
        "extensions": [
            "cil"
        ]
    },
    "application/vnd.ms-asf": {
        "source": "iana"
    },
    "application/vnd.ms-cab-compressed": {
        "source": "iana",
        "extensions": [
            "cab"
        ]
    },
    "application/vnd.ms-color.iccprofile": {
        "source": "apache"
    },
    "application/vnd.ms-excel": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "xls",
            "xlm",
            "xla",
            "xlc",
            "xlt",
            "xlw"
        ]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "xlam"
        ]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "xlsb"
        ]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "xlsm"
        ]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "xltm"
        ]
    },
    "application/vnd.ms-fontobject": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "eot"
        ]
    },
    "application/vnd.ms-htmlhelp": {
        "source": "iana",
        "extensions": [
            "chm"
        ]
    },
    "application/vnd.ms-ims": {
        "source": "iana",
        "extensions": [
            "ims"
        ]
    },
    "application/vnd.ms-lrm": {
        "source": "iana",
        "extensions": [
            "lrm"
        ]
    },
    "application/vnd.ms-office.activex+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ms-officetheme": {
        "source": "iana",
        "extensions": [
            "thmx"
        ]
    },
    "application/vnd.ms-opentype": {
        "source": "apache",
        "compressible": true
    },
    "application/vnd.ms-outlook": {
        "compressible": false,
        "extensions": [
            "msg"
        ]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
        "source": "apache"
    },
    "application/vnd.ms-pki.seccat": {
        "source": "apache",
        "extensions": [
            "cat"
        ]
    },
    "application/vnd.ms-pki.stl": {
        "source": "apache",
        "extensions": [
            "stl"
        ]
    },
    "application/vnd.ms-playready.initiator+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ms-powerpoint": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "ppt",
            "pps",
            "pot"
        ]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "ppam"
        ]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "pptm"
        ]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "sldm"
        ]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "ppsm"
        ]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "potm"
        ]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ms-printing.printticket+xml": {
        "source": "apache",
        "compressible": true
    },
    "application/vnd.ms-printschematicket+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ms-project": {
        "source": "iana",
        "extensions": [
            "mpp",
            "mpt"
        ]
    },
    "application/vnd.ms-tnef": {
        "source": "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
        "source": "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
        "source": "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
        "source": "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
        "source": "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
        "source": "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
        "source": "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
        "source": "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
        "source": "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "docm"
        ]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
        "source": "iana",
        "extensions": [
            "dotm"
        ]
    },
    "application/vnd.ms-works": {
        "source": "iana",
        "extensions": [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ]
    },
    "application/vnd.ms-wpl": {
        "source": "iana",
        "extensions": [
            "wpl"
        ]
    },
    "application/vnd.ms-xpsdocument": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "xps"
        ]
    },
    "application/vnd.msa-disk-image": {
        "source": "iana"
    },
    "application/vnd.mseq": {
        "source": "iana",
        "extensions": [
            "mseq"
        ]
    },
    "application/vnd.msign": {
        "source": "iana"
    },
    "application/vnd.multiad.creator": {
        "source": "iana"
    },
    "application/vnd.multiad.creator.cif": {
        "source": "iana"
    },
    "application/vnd.music-niff": {
        "source": "iana"
    },
    "application/vnd.musician": {
        "source": "iana",
        "extensions": [
            "mus"
        ]
    },
    "application/vnd.muvee.style": {
        "source": "iana",
        "extensions": [
            "msty"
        ]
    },
    "application/vnd.mynfc": {
        "source": "iana",
        "extensions": [
            "taglet"
        ]
    },
    "application/vnd.nacamar.ybrid+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.ncd.control": {
        "source": "iana"
    },
    "application/vnd.ncd.reference": {
        "source": "iana"
    },
    "application/vnd.nearst.inv+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nebumind.line": {
        "source": "iana"
    },
    "application/vnd.nervana": {
        "source": "iana"
    },
    "application/vnd.netfpx": {
        "source": "iana"
    },
    "application/vnd.neurolanguage.nlu": {
        "source": "iana",
        "extensions": [
            "nlu"
        ]
    },
    "application/vnd.nimn": {
        "source": "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
        "source": "iana"
    },
    "application/vnd.nintendo.snes.rom": {
        "source": "iana"
    },
    "application/vnd.nitf": {
        "source": "iana",
        "extensions": [
            "ntf",
            "nitf"
        ]
    },
    "application/vnd.noblenet-directory": {
        "source": "iana",
        "extensions": [
            "nnd"
        ]
    },
    "application/vnd.noblenet-sealer": {
        "source": "iana",
        "extensions": [
            "nns"
        ]
    },
    "application/vnd.noblenet-web": {
        "source": "iana",
        "extensions": [
            "nnw"
        ]
    },
    "application/vnd.nokia.catalogs": {
        "source": "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
        "source": "iana"
    },
    "application/vnd.nokia.conml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nokia.iptv.config+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nokia.isds-radio-presets": {
        "source": "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
        "source": "iana"
    },
    "application/vnd.nokia.landmark+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ac"
        ]
    },
    "application/vnd.nokia.n-gage.data": {
        "source": "iana",
        "extensions": [
            "ngdat"
        ]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
        "source": "iana",
        "extensions": [
            "n-gage"
        ]
    },
    "application/vnd.nokia.ncd": {
        "source": "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
        "source": "iana"
    },
    "application/vnd.nokia.pcd+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.nokia.radio-preset": {
        "source": "iana",
        "extensions": [
            "rpst"
        ]
    },
    "application/vnd.nokia.radio-presets": {
        "source": "iana",
        "extensions": [
            "rpss"
        ]
    },
    "application/vnd.novadigm.edm": {
        "source": "iana",
        "extensions": [
            "edm"
        ]
    },
    "application/vnd.novadigm.edx": {
        "source": "iana",
        "extensions": [
            "edx"
        ]
    },
    "application/vnd.novadigm.ext": {
        "source": "iana",
        "extensions": [
            "ext"
        ]
    },
    "application/vnd.ntt-local.content-share": {
        "source": "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
        "source": "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
        "source": "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
        "source": "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
        "source": "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
        "source": "iana",
        "extensions": [
            "odc"
        ]
    },
    "application/vnd.oasis.opendocument.chart-template": {
        "source": "iana",
        "extensions": [
            "otc"
        ]
    },
    "application/vnd.oasis.opendocument.database": {
        "source": "iana",
        "extensions": [
            "odb"
        ]
    },
    "application/vnd.oasis.opendocument.formula": {
        "source": "iana",
        "extensions": [
            "odf"
        ]
    },
    "application/vnd.oasis.opendocument.formula-template": {
        "source": "iana",
        "extensions": [
            "odft"
        ]
    },
    "application/vnd.oasis.opendocument.graphics": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "odg"
        ]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
        "source": "iana",
        "extensions": [
            "otg"
        ]
    },
    "application/vnd.oasis.opendocument.image": {
        "source": "iana",
        "extensions": [
            "odi"
        ]
    },
    "application/vnd.oasis.opendocument.image-template": {
        "source": "iana",
        "extensions": [
            "oti"
        ]
    },
    "application/vnd.oasis.opendocument.presentation": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "odp"
        ]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
        "source": "iana",
        "extensions": [
            "otp"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "ods"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
        "source": "iana",
        "extensions": [
            "ots"
        ]
    },
    "application/vnd.oasis.opendocument.text": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "odt"
        ]
    },
    "application/vnd.oasis.opendocument.text-master": {
        "source": "iana",
        "extensions": [
            "odm"
        ]
    },
    "application/vnd.oasis.opendocument.text-template": {
        "source": "iana",
        "extensions": [
            "ott"
        ]
    },
    "application/vnd.oasis.opendocument.text-web": {
        "source": "iana",
        "extensions": [
            "oth"
        ]
    },
    "application/vnd.obn": {
        "source": "iana"
    },
    "application/vnd.ocf+cbor": {
        "source": "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oftn.l10n+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.cspg-hexbinary": {
        "source": "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.pae.gem": {
        "source": "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.spdlist+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.ueprofile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oipf.userprofile+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.olpc-sugar": {
        "source": "iana",
        "extensions": [
            "xo"
        ]
    },
    "application/vnd.oma-scws-config": {
        "source": "iana"
    },
    "application/vnd.oma-scws-http-request": {
        "source": "iana"
    },
    "application/vnd.oma-scws-http-response": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.imd+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.ltkm": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.sgdu": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
        "source": "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.sprov+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.bcast.stkm": {
        "source": "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.cab-pcc+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.dcd": {
        "source": "iana"
    },
    "application/vnd.oma.dcdc": {
        "source": "iana"
    },
    "application/vnd.oma.dd2+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "dd2"
        ]
    },
    "application/vnd.oma.drm.risd+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.group-usage-list+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.lwm2m+cbor": {
        "source": "iana"
    },
    "application/vnd.oma.lwm2m+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.lwm2m+tlv": {
        "source": "iana"
    },
    "application/vnd.oma.pal+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.poc.final-report+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.poc.groups+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.push": {
        "source": "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oma.xcap-directory+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.omads-email+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.omads-file+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.omads-folder+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.omaloc-supl-init": {
        "source": "iana"
    },
    "application/vnd.onepager": {
        "source": "iana"
    },
    "application/vnd.onepagertamp": {
        "source": "iana"
    },
    "application/vnd.onepagertamx": {
        "source": "iana"
    },
    "application/vnd.onepagertat": {
        "source": "iana"
    },
    "application/vnd.onepagertatp": {
        "source": "iana"
    },
    "application/vnd.onepagertatx": {
        "source": "iana"
    },
    "application/vnd.openblox.game+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "obgx"
        ]
    },
    "application/vnd.openblox.game-binary": {
        "source": "iana"
    },
    "application/vnd.openeye.oeb": {
        "source": "iana"
    },
    "application/vnd.openofficeorg.extension": {
        "source": "apache",
        "extensions": [
            "oxt"
        ]
    },
    "application/vnd.openstreetmap.data+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "osm"
        ]
    },
    "application/vnd.opentimestamps.ots": {
        "source": "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "pptx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        "source": "iana",
        "extensions": [
            "sldx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        "source": "iana",
        "extensions": [
            "ppsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
        "source": "iana",
        "extensions": [
            "potx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "xlsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        "source": "iana",
        "extensions": [
            "xltx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
        "source": "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "docx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        "source": "iana",
        "extensions": [
            "dotx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oracle.resource+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.orange.indata": {
        "source": "iana"
    },
    "application/vnd.osa.netdeploy": {
        "source": "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
        "source": "iana",
        "extensions": [
            "mgp"
        ]
    },
    "application/vnd.osgi.bundle": {
        "source": "iana"
    },
    "application/vnd.osgi.dp": {
        "source": "iana",
        "extensions": [
            "dp"
        ]
    },
    "application/vnd.osgi.subsystem": {
        "source": "iana",
        "extensions": [
            "esa"
        ]
    },
    "application/vnd.otps.ct-kip+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.oxli.countgraph": {
        "source": "iana"
    },
    "application/vnd.pagerduty+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.palm": {
        "source": "iana",
        "extensions": [
            "pdb",
            "pqa",
            "oprc"
        ]
    },
    "application/vnd.panoply": {
        "source": "iana"
    },
    "application/vnd.paos.xml": {
        "source": "iana"
    },
    "application/vnd.patentdive": {
        "source": "iana"
    },
    "application/vnd.patientecommsdoc": {
        "source": "iana"
    },
    "application/vnd.pawaafile": {
        "source": "iana",
        "extensions": [
            "paw"
        ]
    },
    "application/vnd.pcos": {
        "source": "iana"
    },
    "application/vnd.pg.format": {
        "source": "iana",
        "extensions": [
            "str"
        ]
    },
    "application/vnd.pg.osasli": {
        "source": "iana",
        "extensions": [
            "ei6"
        ]
    },
    "application/vnd.piaccess.application-licence": {
        "source": "iana"
    },
    "application/vnd.picsel": {
        "source": "iana",
        "extensions": [
            "efif"
        ]
    },
    "application/vnd.pmi.widget": {
        "source": "iana",
        "extensions": [
            "wg"
        ]
    },
    "application/vnd.poc.group-advertisement+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.pocketlearn": {
        "source": "iana",
        "extensions": [
            "plf"
        ]
    },
    "application/vnd.powerbuilder6": {
        "source": "iana",
        "extensions": [
            "pbd"
        ]
    },
    "application/vnd.powerbuilder6-s": {
        "source": "iana"
    },
    "application/vnd.powerbuilder7": {
        "source": "iana"
    },
    "application/vnd.powerbuilder7-s": {
        "source": "iana"
    },
    "application/vnd.powerbuilder75": {
        "source": "iana"
    },
    "application/vnd.powerbuilder75-s": {
        "source": "iana"
    },
    "application/vnd.preminet": {
        "source": "iana"
    },
    "application/vnd.previewsystems.box": {
        "source": "iana",
        "extensions": [
            "box"
        ]
    },
    "application/vnd.proteus.magazine": {
        "source": "iana",
        "extensions": [
            "mgz"
        ]
    },
    "application/vnd.psfs": {
        "source": "iana"
    },
    "application/vnd.publishare-delta-tree": {
        "source": "iana",
        "extensions": [
            "qps"
        ]
    },
    "application/vnd.pvi.ptid1": {
        "source": "iana",
        "extensions": [
            "ptid"
        ]
    },
    "application/vnd.pwg-multiplexed": {
        "source": "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.qualcomm.brew-app-res": {
        "source": "iana"
    },
    "application/vnd.quarantainenet": {
        "source": "iana"
    },
    "application/vnd.quark.quarkxpress": {
        "source": "iana",
        "extensions": [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ]
    },
    "application/vnd.quobject-quoxdocument": {
        "source": "iana"
    },
    "application/vnd.radisys.moml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-audit+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-conf+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.rainstor.data": {
        "source": "iana"
    },
    "application/vnd.rapid": {
        "source": "iana"
    },
    "application/vnd.rar": {
        "source": "iana",
        "extensions": [
            "rar"
        ]
    },
    "application/vnd.realvnc.bed": {
        "source": "iana",
        "extensions": [
            "bed"
        ]
    },
    "application/vnd.recordare.musicxml": {
        "source": "iana",
        "extensions": [
            "mxl"
        ]
    },
    "application/vnd.recordare.musicxml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "musicxml"
        ]
    },
    "application/vnd.renlearn.rlprint": {
        "source": "iana"
    },
    "application/vnd.resilient.logic": {
        "source": "iana"
    },
    "application/vnd.restful+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.rig.cryptonote": {
        "source": "iana",
        "extensions": [
            "cryptonote"
        ]
    },
    "application/vnd.rim.cod": {
        "source": "apache",
        "extensions": [
            "cod"
        ]
    },
    "application/vnd.rn-realmedia": {
        "source": "apache",
        "extensions": [
            "rm"
        ]
    },
    "application/vnd.rn-realmedia-vbr": {
        "source": "apache",
        "extensions": [
            "rmvb"
        ]
    },
    "application/vnd.route66.link66+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "link66"
        ]
    },
    "application/vnd.rs-274x": {
        "source": "iana"
    },
    "application/vnd.ruckus.download": {
        "source": "iana"
    },
    "application/vnd.s3sms": {
        "source": "iana"
    },
    "application/vnd.sailingtracker.track": {
        "source": "iana",
        "extensions": [
            "st"
        ]
    },
    "application/vnd.sar": {
        "source": "iana"
    },
    "application/vnd.sbm.cid": {
        "source": "iana"
    },
    "application/vnd.sbm.mid2": {
        "source": "iana"
    },
    "application/vnd.scribus": {
        "source": "iana"
    },
    "application/vnd.sealed.3df": {
        "source": "iana"
    },
    "application/vnd.sealed.csf": {
        "source": "iana"
    },
    "application/vnd.sealed.doc": {
        "source": "iana"
    },
    "application/vnd.sealed.eml": {
        "source": "iana"
    },
    "application/vnd.sealed.mht": {
        "source": "iana"
    },
    "application/vnd.sealed.net": {
        "source": "iana"
    },
    "application/vnd.sealed.ppt": {
        "source": "iana"
    },
    "application/vnd.sealed.tiff": {
        "source": "iana"
    },
    "application/vnd.sealed.xls": {
        "source": "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
        "source": "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
        "source": "iana"
    },
    "application/vnd.seemail": {
        "source": "iana",
        "extensions": [
            "see"
        ]
    },
    "application/vnd.seis+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.sema": {
        "source": "iana",
        "extensions": [
            "sema"
        ]
    },
    "application/vnd.semd": {
        "source": "iana",
        "extensions": [
            "semd"
        ]
    },
    "application/vnd.semf": {
        "source": "iana",
        "extensions": [
            "semf"
        ]
    },
    "application/vnd.shade-save-file": {
        "source": "iana"
    },
    "application/vnd.shana.informed.formdata": {
        "source": "iana",
        "extensions": [
            "ifm"
        ]
    },
    "application/vnd.shana.informed.formtemplate": {
        "source": "iana",
        "extensions": [
            "itp"
        ]
    },
    "application/vnd.shana.informed.interchange": {
        "source": "iana",
        "extensions": [
            "iif"
        ]
    },
    "application/vnd.shana.informed.package": {
        "source": "iana",
        "extensions": [
            "ipk"
        ]
    },
    "application/vnd.shootproof+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.shopkick+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.shp": {
        "source": "iana"
    },
    "application/vnd.shx": {
        "source": "iana"
    },
    "application/vnd.sigrok.session": {
        "source": "iana"
    },
    "application/vnd.simtech-mindmapper": {
        "source": "iana",
        "extensions": [
            "twd",
            "twds"
        ]
    },
    "application/vnd.siren+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.smaf": {
        "source": "iana",
        "extensions": [
            "mmf"
        ]
    },
    "application/vnd.smart.notebook": {
        "source": "iana"
    },
    "application/vnd.smart.teacher": {
        "source": "iana",
        "extensions": [
            "teacher"
        ]
    },
    "application/vnd.snesdev-page-table": {
        "source": "iana"
    },
    "application/vnd.software602.filler.form+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "fo"
        ]
    },
    "application/vnd.software602.filler.form-xml-zip": {
        "source": "iana"
    },
    "application/vnd.solent.sdkm+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "sdkm",
            "sdkd"
        ]
    },
    "application/vnd.spotfire.dxp": {
        "source": "iana",
        "extensions": [
            "dxp"
        ]
    },
    "application/vnd.spotfire.sfs": {
        "source": "iana",
        "extensions": [
            "sfs"
        ]
    },
    "application/vnd.sqlite3": {
        "source": "iana"
    },
    "application/vnd.sss-cod": {
        "source": "iana"
    },
    "application/vnd.sss-dtf": {
        "source": "iana"
    },
    "application/vnd.sss-ntf": {
        "source": "iana"
    },
    "application/vnd.stardivision.calc": {
        "source": "apache",
        "extensions": [
            "sdc"
        ]
    },
    "application/vnd.stardivision.draw": {
        "source": "apache",
        "extensions": [
            "sda"
        ]
    },
    "application/vnd.stardivision.impress": {
        "source": "apache",
        "extensions": [
            "sdd"
        ]
    },
    "application/vnd.stardivision.math": {
        "source": "apache",
        "extensions": [
            "smf"
        ]
    },
    "application/vnd.stardivision.writer": {
        "source": "apache",
        "extensions": [
            "sdw",
            "vor"
        ]
    },
    "application/vnd.stardivision.writer-global": {
        "source": "apache",
        "extensions": [
            "sgl"
        ]
    },
    "application/vnd.stepmania.package": {
        "source": "iana",
        "extensions": [
            "smzip"
        ]
    },
    "application/vnd.stepmania.stepchart": {
        "source": "iana",
        "extensions": [
            "sm"
        ]
    },
    "application/vnd.street-stream": {
        "source": "iana"
    },
    "application/vnd.sun.wadl+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wadl"
        ]
    },
    "application/vnd.sun.xml.calc": {
        "source": "apache",
        "extensions": [
            "sxc"
        ]
    },
    "application/vnd.sun.xml.calc.template": {
        "source": "apache",
        "extensions": [
            "stc"
        ]
    },
    "application/vnd.sun.xml.draw": {
        "source": "apache",
        "extensions": [
            "sxd"
        ]
    },
    "application/vnd.sun.xml.draw.template": {
        "source": "apache",
        "extensions": [
            "std"
        ]
    },
    "application/vnd.sun.xml.impress": {
        "source": "apache",
        "extensions": [
            "sxi"
        ]
    },
    "application/vnd.sun.xml.impress.template": {
        "source": "apache",
        "extensions": [
            "sti"
        ]
    },
    "application/vnd.sun.xml.math": {
        "source": "apache",
        "extensions": [
            "sxm"
        ]
    },
    "application/vnd.sun.xml.writer": {
        "source": "apache",
        "extensions": [
            "sxw"
        ]
    },
    "application/vnd.sun.xml.writer.global": {
        "source": "apache",
        "extensions": [
            "sxg"
        ]
    },
    "application/vnd.sun.xml.writer.template": {
        "source": "apache",
        "extensions": [
            "stw"
        ]
    },
    "application/vnd.sus-calendar": {
        "source": "iana",
        "extensions": [
            "sus",
            "susp"
        ]
    },
    "application/vnd.svd": {
        "source": "iana",
        "extensions": [
            "svd"
        ]
    },
    "application/vnd.swiftview-ics": {
        "source": "iana"
    },
    "application/vnd.sycle+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.syft+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.symbian.install": {
        "source": "apache",
        "extensions": [
            "sis",
            "sisx"
        ]
    },
    "application/vnd.syncml+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "xsm"
        ]
    },
    "application/vnd.syncml.dm+wbxml": {
        "source": "iana",
        "charset": "UTF-8",
        "extensions": [
            "bdm"
        ]
    },
    "application/vnd.syncml.dm+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "xdm"
        ]
    },
    "application/vnd.syncml.dm.notification": {
        "source": "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
        "source": "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "ddf"
        ]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
        "source": "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true
    },
    "application/vnd.syncml.ds.notification": {
        "source": "iana"
    },
    "application/vnd.tableschema+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.tao.intent-module-archive": {
        "source": "iana",
        "extensions": [
            "tao"
        ]
    },
    "application/vnd.tcpdump.pcap": {
        "source": "iana",
        "extensions": [
            "pcap",
            "cap",
            "dmp"
        ]
    },
    "application/vnd.think-cell.ppttc+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.tml": {
        "source": "iana"
    },
    "application/vnd.tmobile-livetv": {
        "source": "iana",
        "extensions": [
            "tmo"
        ]
    },
    "application/vnd.tri.onesource": {
        "source": "iana"
    },
    "application/vnd.trid.tpt": {
        "source": "iana",
        "extensions": [
            "tpt"
        ]
    },
    "application/vnd.triscape.mxs": {
        "source": "iana",
        "extensions": [
            "mxs"
        ]
    },
    "application/vnd.trueapp": {
        "source": "iana",
        "extensions": [
            "tra"
        ]
    },
    "application/vnd.truedoc": {
        "source": "iana"
    },
    "application/vnd.ubisoft.webplayer": {
        "source": "iana"
    },
    "application/vnd.ufdl": {
        "source": "iana",
        "extensions": [
            "ufd",
            "ufdl"
        ]
    },
    "application/vnd.uiq.theme": {
        "source": "iana",
        "extensions": [
            "utz"
        ]
    },
    "application/vnd.umajin": {
        "source": "iana",
        "extensions": [
            "umj"
        ]
    },
    "application/vnd.unity": {
        "source": "iana",
        "extensions": [
            "unityweb"
        ]
    },
    "application/vnd.uoml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "uoml"
        ]
    },
    "application/vnd.uplanet.alert": {
        "source": "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
        "source": "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.cacheop": {
        "source": "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.channel": {
        "source": "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.list": {
        "source": "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.listcmd": {
        "source": "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
        "source": "iana"
    },
    "application/vnd.uplanet.signal": {
        "source": "iana"
    },
    "application/vnd.uri-map": {
        "source": "iana"
    },
    "application/vnd.valve.source.material": {
        "source": "iana"
    },
    "application/vnd.vcx": {
        "source": "iana",
        "extensions": [
            "vcx"
        ]
    },
    "application/vnd.vd-study": {
        "source": "iana"
    },
    "application/vnd.vectorworks": {
        "source": "iana"
    },
    "application/vnd.vel+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.verimatrix.vcas": {
        "source": "iana"
    },
    "application/vnd.veritone.aion+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.veryant.thin": {
        "source": "iana"
    },
    "application/vnd.ves.encrypted": {
        "source": "iana"
    },
    "application/vnd.vidsoft.vidconference": {
        "source": "iana"
    },
    "application/vnd.visio": {
        "source": "iana",
        "extensions": [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ]
    },
    "application/vnd.visionary": {
        "source": "iana",
        "extensions": [
            "vis"
        ]
    },
    "application/vnd.vividence.scriptfile": {
        "source": "iana"
    },
    "application/vnd.vsf": {
        "source": "iana",
        "extensions": [
            "vsf"
        ]
    },
    "application/vnd.wap.sic": {
        "source": "iana"
    },
    "application/vnd.wap.slc": {
        "source": "iana"
    },
    "application/vnd.wap.wbxml": {
        "source": "iana",
        "charset": "UTF-8",
        "extensions": [
            "wbxml"
        ]
    },
    "application/vnd.wap.wmlc": {
        "source": "iana",
        "extensions": [
            "wmlc"
        ]
    },
    "application/vnd.wap.wmlscriptc": {
        "source": "iana",
        "extensions": [
            "wmlsc"
        ]
    },
    "application/vnd.webturbo": {
        "source": "iana",
        "extensions": [
            "wtb"
        ]
    },
    "application/vnd.wfa.dpp": {
        "source": "iana"
    },
    "application/vnd.wfa.p2p": {
        "source": "iana"
    },
    "application/vnd.wfa.wsc": {
        "source": "iana"
    },
    "application/vnd.windows.devicepairing": {
        "source": "iana"
    },
    "application/vnd.wmc": {
        "source": "iana"
    },
    "application/vnd.wmf.bootstrap": {
        "source": "iana"
    },
    "application/vnd.wolfram.mathematica": {
        "source": "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
        "source": "iana"
    },
    "application/vnd.wolfram.player": {
        "source": "iana",
        "extensions": [
            "nbp"
        ]
    },
    "application/vnd.wordperfect": {
        "source": "iana",
        "extensions": [
            "wpd"
        ]
    },
    "application/vnd.wqd": {
        "source": "iana",
        "extensions": [
            "wqd"
        ]
    },
    "application/vnd.wrq-hp3000-labelled": {
        "source": "iana"
    },
    "application/vnd.wt.stf": {
        "source": "iana",
        "extensions": [
            "stf"
        ]
    },
    "application/vnd.wv.csp+wbxml": {
        "source": "iana"
    },
    "application/vnd.wv.csp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.wv.ssp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.xacml+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.xara": {
        "source": "iana",
        "extensions": [
            "xar"
        ]
    },
    "application/vnd.xfdl": {
        "source": "iana",
        "extensions": [
            "xfdl"
        ]
    },
    "application/vnd.xfdl.webform": {
        "source": "iana"
    },
    "application/vnd.xmi+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/vnd.xmpie.cpkg": {
        "source": "iana"
    },
    "application/vnd.xmpie.dpkg": {
        "source": "iana"
    },
    "application/vnd.xmpie.plan": {
        "source": "iana"
    },
    "application/vnd.xmpie.ppkg": {
        "source": "iana"
    },
    "application/vnd.xmpie.xlim": {
        "source": "iana"
    },
    "application/vnd.yamaha.hv-dic": {
        "source": "iana",
        "extensions": [
            "hvd"
        ]
    },
    "application/vnd.yamaha.hv-script": {
        "source": "iana",
        "extensions": [
            "hvs"
        ]
    },
    "application/vnd.yamaha.hv-voice": {
        "source": "iana",
        "extensions": [
            "hvp"
        ]
    },
    "application/vnd.yamaha.openscoreformat": {
        "source": "iana",
        "extensions": [
            "osf"
        ]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "osfpvg"
        ]
    },
    "application/vnd.yamaha.remote-setup": {
        "source": "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
        "source": "iana",
        "extensions": [
            "saf"
        ]
    },
    "application/vnd.yamaha.smaf-phrase": {
        "source": "iana",
        "extensions": [
            "spf"
        ]
    },
    "application/vnd.yamaha.through-ngn": {
        "source": "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
        "source": "iana"
    },
    "application/vnd.yaoweme": {
        "source": "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
        "source": "iana",
        "extensions": [
            "cmp"
        ]
    },
    "application/vnd.youtube.yt": {
        "source": "iana"
    },
    "application/vnd.zul": {
        "source": "iana",
        "extensions": [
            "zir",
            "zirz"
        ]
    },
    "application/vnd.zzazz.deck+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "zaz"
        ]
    },
    "application/voicexml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "vxml"
        ]
    },
    "application/voucher-cms+json": {
        "source": "iana",
        "compressible": true
    },
    "application/vq-rtcpxr": {
        "source": "iana"
    },
    "application/wasm": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wasm"
        ]
    },
    "application/watcherinfo+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wif"
        ]
    },
    "application/webpush-options+json": {
        "source": "iana",
        "compressible": true
    },
    "application/whoispp-query": {
        "source": "iana"
    },
    "application/whoispp-response": {
        "source": "iana"
    },
    "application/widget": {
        "source": "iana",
        "extensions": [
            "wgt"
        ]
    },
    "application/winhlp": {
        "source": "apache",
        "extensions": [
            "hlp"
        ]
    },
    "application/wita": {
        "source": "iana"
    },
    "application/wordperfect5.1": {
        "source": "iana"
    },
    "application/wsdl+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wsdl"
        ]
    },
    "application/wspolicy+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "wspolicy"
        ]
    },
    "application/x-7z-compressed": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "7z"
        ]
    },
    "application/x-abiword": {
        "source": "apache",
        "extensions": [
            "abw"
        ]
    },
    "application/x-ace-compressed": {
        "source": "apache",
        "extensions": [
            "ace"
        ]
    },
    "application/x-amf": {
        "source": "apache"
    },
    "application/x-apple-diskimage": {
        "source": "apache",
        "extensions": [
            "dmg"
        ]
    },
    "application/x-arj": {
        "compressible": false,
        "extensions": [
            "arj"
        ]
    },
    "application/x-authorware-bin": {
        "source": "apache",
        "extensions": [
            "aab",
            "x32",
            "u32",
            "vox"
        ]
    },
    "application/x-authorware-map": {
        "source": "apache",
        "extensions": [
            "aam"
        ]
    },
    "application/x-authorware-seg": {
        "source": "apache",
        "extensions": [
            "aas"
        ]
    },
    "application/x-bcpio": {
        "source": "apache",
        "extensions": [
            "bcpio"
        ]
    },
    "application/x-bdoc": {
        "compressible": false,
        "extensions": [
            "bdoc"
        ]
    },
    "application/x-bittorrent": {
        "source": "apache",
        "extensions": [
            "torrent"
        ]
    },
    "application/x-blorb": {
        "source": "apache",
        "extensions": [
            "blb",
            "blorb"
        ]
    },
    "application/x-bzip": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "bz"
        ]
    },
    "application/x-bzip2": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "bz2",
            "boz"
        ]
    },
    "application/x-cbr": {
        "source": "apache",
        "extensions": [
            "cbr",
            "cba",
            "cbt",
            "cbz",
            "cb7"
        ]
    },
    "application/x-cdlink": {
        "source": "apache",
        "extensions": [
            "vcd"
        ]
    },
    "application/x-cfs-compressed": {
        "source": "apache",
        "extensions": [
            "cfs"
        ]
    },
    "application/x-chat": {
        "source": "apache",
        "extensions": [
            "chat"
        ]
    },
    "application/x-chess-pgn": {
        "source": "apache",
        "extensions": [
            "pgn"
        ]
    },
    "application/x-chrome-extension": {
        "extensions": [
            "crx"
        ]
    },
    "application/x-cocoa": {
        "source": "nginx",
        "extensions": [
            "cco"
        ]
    },
    "application/x-compress": {
        "source": "apache"
    },
    "application/x-conference": {
        "source": "apache",
        "extensions": [
            "nsc"
        ]
    },
    "application/x-cpio": {
        "source": "apache",
        "extensions": [
            "cpio"
        ]
    },
    "application/x-csh": {
        "source": "apache",
        "extensions": [
            "csh"
        ]
    },
    "application/x-deb": {
        "compressible": false
    },
    "application/x-debian-package": {
        "source": "apache",
        "extensions": [
            "deb",
            "udeb"
        ]
    },
    "application/x-dgc-compressed": {
        "source": "apache",
        "extensions": [
            "dgc"
        ]
    },
    "application/x-director": {
        "source": "apache",
        "extensions": [
            "dir",
            "dcr",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ]
    },
    "application/x-doom": {
        "source": "apache",
        "extensions": [
            "wad"
        ]
    },
    "application/x-dtbncx+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "ncx"
        ]
    },
    "application/x-dtbook+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "dtb"
        ]
    },
    "application/x-dtbresource+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "res"
        ]
    },
    "application/x-dvi": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "dvi"
        ]
    },
    "application/x-envoy": {
        "source": "apache",
        "extensions": [
            "evy"
        ]
    },
    "application/x-eva": {
        "source": "apache",
        "extensions": [
            "eva"
        ]
    },
    "application/x-font-bdf": {
        "source": "apache",
        "extensions": [
            "bdf"
        ]
    },
    "application/x-font-dos": {
        "source": "apache"
    },
    "application/x-font-framemaker": {
        "source": "apache"
    },
    "application/x-font-ghostscript": {
        "source": "apache",
        "extensions": [
            "gsf"
        ]
    },
    "application/x-font-libgrx": {
        "source": "apache"
    },
    "application/x-font-linux-psf": {
        "source": "apache",
        "extensions": [
            "psf"
        ]
    },
    "application/x-font-pcf": {
        "source": "apache",
        "extensions": [
            "pcf"
        ]
    },
    "application/x-font-snf": {
        "source": "apache",
        "extensions": [
            "snf"
        ]
    },
    "application/x-font-speedo": {
        "source": "apache"
    },
    "application/x-font-sunos-news": {
        "source": "apache"
    },
    "application/x-font-type1": {
        "source": "apache",
        "extensions": [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ]
    },
    "application/x-font-vfont": {
        "source": "apache"
    },
    "application/x-freearc": {
        "source": "apache",
        "extensions": [
            "arc"
        ]
    },
    "application/x-futuresplash": {
        "source": "apache",
        "extensions": [
            "spl"
        ]
    },
    "application/x-gca-compressed": {
        "source": "apache",
        "extensions": [
            "gca"
        ]
    },
    "application/x-glulx": {
        "source": "apache",
        "extensions": [
            "ulx"
        ]
    },
    "application/x-gnumeric": {
        "source": "apache",
        "extensions": [
            "gnumeric"
        ]
    },
    "application/x-gramps-xml": {
        "source": "apache",
        "extensions": [
            "gramps"
        ]
    },
    "application/x-gtar": {
        "source": "apache",
        "extensions": [
            "gtar"
        ]
    },
    "application/x-gzip": {
        "source": "apache"
    },
    "application/x-hdf": {
        "source": "apache",
        "extensions": [
            "hdf"
        ]
    },
    "application/x-httpd-php": {
        "compressible": true,
        "extensions": [
            "php"
        ]
    },
    "application/x-install-instructions": {
        "source": "apache",
        "extensions": [
            "install"
        ]
    },
    "application/x-iso9660-image": {
        "source": "apache",
        "extensions": [
            "iso"
        ]
    },
    "application/x-iwork-keynote-sffkey": {
        "extensions": [
            "key"
        ]
    },
    "application/x-iwork-numbers-sffnumbers": {
        "extensions": [
            "numbers"
        ]
    },
    "application/x-iwork-pages-sffpages": {
        "extensions": [
            "pages"
        ]
    },
    "application/x-java-archive-diff": {
        "source": "nginx",
        "extensions": [
            "jardiff"
        ]
    },
    "application/x-java-jnlp-file": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "jnlp"
        ]
    },
    "application/x-javascript": {
        "compressible": true
    },
    "application/x-keepass2": {
        "extensions": [
            "kdbx"
        ]
    },
    "application/x-latex": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "latex"
        ]
    },
    "application/x-lua-bytecode": {
        "extensions": [
            "luac"
        ]
    },
    "application/x-lzh-compressed": {
        "source": "apache",
        "extensions": [
            "lzh",
            "lha"
        ]
    },
    "application/x-makeself": {
        "source": "nginx",
        "extensions": [
            "run"
        ]
    },
    "application/x-mie": {
        "source": "apache",
        "extensions": [
            "mie"
        ]
    },
    "application/x-mobipocket-ebook": {
        "source": "apache",
        "extensions": [
            "prc",
            "mobi"
        ]
    },
    "application/x-mpegurl": {
        "compressible": false
    },
    "application/x-ms-application": {
        "source": "apache",
        "extensions": [
            "application"
        ]
    },
    "application/x-ms-shortcut": {
        "source": "apache",
        "extensions": [
            "lnk"
        ]
    },
    "application/x-ms-wmd": {
        "source": "apache",
        "extensions": [
            "wmd"
        ]
    },
    "application/x-ms-wmz": {
        "source": "apache",
        "extensions": [
            "wmz"
        ]
    },
    "application/x-ms-xbap": {
        "source": "apache",
        "extensions": [
            "xbap"
        ]
    },
    "application/x-msaccess": {
        "source": "apache",
        "extensions": [
            "mdb"
        ]
    },
    "application/x-msbinder": {
        "source": "apache",
        "extensions": [
            "obd"
        ]
    },
    "application/x-mscardfile": {
        "source": "apache",
        "extensions": [
            "crd"
        ]
    },
    "application/x-msclip": {
        "source": "apache",
        "extensions": [
            "clp"
        ]
    },
    "application/x-msdos-program": {
        "extensions": [
            "exe"
        ]
    },
    "application/x-msdownload": {
        "source": "apache",
        "extensions": [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ]
    },
    "application/x-msmediaview": {
        "source": "apache",
        "extensions": [
            "mvb",
            "m13",
            "m14"
        ]
    },
    "application/x-msmetafile": {
        "source": "apache",
        "extensions": [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ]
    },
    "application/x-msmoney": {
        "source": "apache",
        "extensions": [
            "mny"
        ]
    },
    "application/x-mspublisher": {
        "source": "apache",
        "extensions": [
            "pub"
        ]
    },
    "application/x-msschedule": {
        "source": "apache",
        "extensions": [
            "scd"
        ]
    },
    "application/x-msterminal": {
        "source": "apache",
        "extensions": [
            "trm"
        ]
    },
    "application/x-mswrite": {
        "source": "apache",
        "extensions": [
            "wri"
        ]
    },
    "application/x-netcdf": {
        "source": "apache",
        "extensions": [
            "nc",
            "cdf"
        ]
    },
    "application/x-ns-proxy-autoconfig": {
        "compressible": true,
        "extensions": [
            "pac"
        ]
    },
    "application/x-nzb": {
        "source": "apache",
        "extensions": [
            "nzb"
        ]
    },
    "application/x-perl": {
        "source": "nginx",
        "extensions": [
            "pl",
            "pm"
        ]
    },
    "application/x-pilot": {
        "source": "nginx",
        "extensions": [
            "prc",
            "pdb"
        ]
    },
    "application/x-pkcs12": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "p12",
            "pfx"
        ]
    },
    "application/x-pkcs7-certificates": {
        "source": "apache",
        "extensions": [
            "p7b",
            "spc"
        ]
    },
    "application/x-pkcs7-certreqresp": {
        "source": "apache",
        "extensions": [
            "p7r"
        ]
    },
    "application/x-pki-message": {
        "source": "iana"
    },
    "application/x-rar-compressed": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "rar"
        ]
    },
    "application/x-redhat-package-manager": {
        "source": "nginx",
        "extensions": [
            "rpm"
        ]
    },
    "application/x-research-info-systems": {
        "source": "apache",
        "extensions": [
            "ris"
        ]
    },
    "application/x-sea": {
        "source": "nginx",
        "extensions": [
            "sea"
        ]
    },
    "application/x-sh": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "sh"
        ]
    },
    "application/x-shar": {
        "source": "apache",
        "extensions": [
            "shar"
        ]
    },
    "application/x-shockwave-flash": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "swf"
        ]
    },
    "application/x-silverlight-app": {
        "source": "apache",
        "extensions": [
            "xap"
        ]
    },
    "application/x-sql": {
        "source": "apache",
        "extensions": [
            "sql"
        ]
    },
    "application/x-stuffit": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "sit"
        ]
    },
    "application/x-stuffitx": {
        "source": "apache",
        "extensions": [
            "sitx"
        ]
    },
    "application/x-subrip": {
        "source": "apache",
        "extensions": [
            "srt"
        ]
    },
    "application/x-sv4cpio": {
        "source": "apache",
        "extensions": [
            "sv4cpio"
        ]
    },
    "application/x-sv4crc": {
        "source": "apache",
        "extensions": [
            "sv4crc"
        ]
    },
    "application/x-t3vm-image": {
        "source": "apache",
        "extensions": [
            "t3"
        ]
    },
    "application/x-tads": {
        "source": "apache",
        "extensions": [
            "gam"
        ]
    },
    "application/x-tar": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "tar"
        ]
    },
    "application/x-tcl": {
        "source": "apache",
        "extensions": [
            "tcl",
            "tk"
        ]
    },
    "application/x-tex": {
        "source": "apache",
        "extensions": [
            "tex"
        ]
    },
    "application/x-tex-tfm": {
        "source": "apache",
        "extensions": [
            "tfm"
        ]
    },
    "application/x-texinfo": {
        "source": "apache",
        "extensions": [
            "texinfo",
            "texi"
        ]
    },
    "application/x-tgif": {
        "source": "apache",
        "extensions": [
            "obj"
        ]
    },
    "application/x-ustar": {
        "source": "apache",
        "extensions": [
            "ustar"
        ]
    },
    "application/x-virtualbox-hdd": {
        "compressible": true,
        "extensions": [
            "hdd"
        ]
    },
    "application/x-virtualbox-ova": {
        "compressible": true,
        "extensions": [
            "ova"
        ]
    },
    "application/x-virtualbox-ovf": {
        "compressible": true,
        "extensions": [
            "ovf"
        ]
    },
    "application/x-virtualbox-vbox": {
        "compressible": true,
        "extensions": [
            "vbox"
        ]
    },
    "application/x-virtualbox-vbox-extpack": {
        "compressible": false,
        "extensions": [
            "vbox-extpack"
        ]
    },
    "application/x-virtualbox-vdi": {
        "compressible": true,
        "extensions": [
            "vdi"
        ]
    },
    "application/x-virtualbox-vhd": {
        "compressible": true,
        "extensions": [
            "vhd"
        ]
    },
    "application/x-virtualbox-vmdk": {
        "compressible": true,
        "extensions": [
            "vmdk"
        ]
    },
    "application/x-wais-source": {
        "source": "apache",
        "extensions": [
            "src"
        ]
    },
    "application/x-web-app-manifest+json": {
        "compressible": true,
        "extensions": [
            "webapp"
        ]
    },
    "application/x-www-form-urlencoded": {
        "source": "iana",
        "compressible": true
    },
    "application/x-x509-ca-cert": {
        "source": "iana",
        "extensions": [
            "der",
            "crt",
            "pem"
        ]
    },
    "application/x-x509-ca-ra-cert": {
        "source": "iana"
    },
    "application/x-x509-next-ca-cert": {
        "source": "iana"
    },
    "application/x-xfig": {
        "source": "apache",
        "extensions": [
            "fig"
        ]
    },
    "application/x-xliff+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "xlf"
        ]
    },
    "application/x-xpinstall": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "xpi"
        ]
    },
    "application/x-xz": {
        "source": "apache",
        "extensions": [
            "xz"
        ]
    },
    "application/x-zmachine": {
        "source": "apache",
        "extensions": [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ]
    },
    "application/x400-bp": {
        "source": "iana"
    },
    "application/xacml+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xaml+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "xaml"
        ]
    },
    "application/xcap-att+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xav"
        ]
    },
    "application/xcap-caps+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xca"
        ]
    },
    "application/xcap-diff+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xdf"
        ]
    },
    "application/xcap-el+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xel"
        ]
    },
    "application/xcap-error+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xcap-ns+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xns"
        ]
    },
    "application/xcon-conference-info+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xcon-conference-info-diff+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xenc+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xenc"
        ]
    },
    "application/xhtml+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xhtml",
            "xht"
        ]
    },
    "application/xhtml-voice+xml": {
        "source": "apache",
        "compressible": true
    },
    "application/xliff+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xlf"
        ]
    },
    "application/xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xml",
            "xsl",
            "xsd",
            "rng"
        ]
    },
    "application/xml-dtd": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "dtd"
        ]
    },
    "application/xml-external-parsed-entity": {
        "source": "iana"
    },
    "application/xml-patch+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xmpp+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/xop+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xop"
        ]
    },
    "application/xproc+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "xpl"
        ]
    },
    "application/xslt+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xsl",
            "xslt"
        ]
    },
    "application/xspf+xml": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "xspf"
        ]
    },
    "application/xv+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ]
    },
    "application/yang": {
        "source": "iana",
        "extensions": [
            "yang"
        ]
    },
    "application/yang-data+json": {
        "source": "iana",
        "compressible": true
    },
    "application/yang-data+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/yang-patch+json": {
        "source": "iana",
        "compressible": true
    },
    "application/yang-patch+xml": {
        "source": "iana",
        "compressible": true
    },
    "application/yin+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "yin"
        ]
    },
    "application/zip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "zip"
        ]
    },
    "application/zlib": {
        "source": "iana"
    },
    "application/zstd": {
        "source": "iana"
    },
    "audio/1d-interleaved-parityfec": {
        "source": "iana"
    },
    "audio/32kadpcm": {
        "source": "iana"
    },
    "audio/3gpp": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "3gpp"
        ]
    },
    "audio/3gpp2": {
        "source": "iana"
    },
    "audio/aac": {
        "source": "iana"
    },
    "audio/ac3": {
        "source": "iana"
    },
    "audio/adpcm": {
        "source": "apache",
        "extensions": [
            "adp"
        ]
    },
    "audio/amr": {
        "source": "iana",
        "extensions": [
            "amr"
        ]
    },
    "audio/amr-wb": {
        "source": "iana"
    },
    "audio/amr-wb+": {
        "source": "iana"
    },
    "audio/aptx": {
        "source": "iana"
    },
    "audio/asc": {
        "source": "iana"
    },
    "audio/atrac-advanced-lossless": {
        "source": "iana"
    },
    "audio/atrac-x": {
        "source": "iana"
    },
    "audio/atrac3": {
        "source": "iana"
    },
    "audio/basic": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "au",
            "snd"
        ]
    },
    "audio/bv16": {
        "source": "iana"
    },
    "audio/bv32": {
        "source": "iana"
    },
    "audio/clearmode": {
        "source": "iana"
    },
    "audio/cn": {
        "source": "iana"
    },
    "audio/dat12": {
        "source": "iana"
    },
    "audio/dls": {
        "source": "iana"
    },
    "audio/dsr-es201108": {
        "source": "iana"
    },
    "audio/dsr-es202050": {
        "source": "iana"
    },
    "audio/dsr-es202211": {
        "source": "iana"
    },
    "audio/dsr-es202212": {
        "source": "iana"
    },
    "audio/dv": {
        "source": "iana"
    },
    "audio/dvi4": {
        "source": "iana"
    },
    "audio/eac3": {
        "source": "iana"
    },
    "audio/encaprtp": {
        "source": "iana"
    },
    "audio/evrc": {
        "source": "iana"
    },
    "audio/evrc-qcp": {
        "source": "iana"
    },
    "audio/evrc0": {
        "source": "iana"
    },
    "audio/evrc1": {
        "source": "iana"
    },
    "audio/evrcb": {
        "source": "iana"
    },
    "audio/evrcb0": {
        "source": "iana"
    },
    "audio/evrcb1": {
        "source": "iana"
    },
    "audio/evrcnw": {
        "source": "iana"
    },
    "audio/evrcnw0": {
        "source": "iana"
    },
    "audio/evrcnw1": {
        "source": "iana"
    },
    "audio/evrcwb": {
        "source": "iana"
    },
    "audio/evrcwb0": {
        "source": "iana"
    },
    "audio/evrcwb1": {
        "source": "iana"
    },
    "audio/evs": {
        "source": "iana"
    },
    "audio/flexfec": {
        "source": "iana"
    },
    "audio/fwdred": {
        "source": "iana"
    },
    "audio/g711-0": {
        "source": "iana"
    },
    "audio/g719": {
        "source": "iana"
    },
    "audio/g722": {
        "source": "iana"
    },
    "audio/g7221": {
        "source": "iana"
    },
    "audio/g723": {
        "source": "iana"
    },
    "audio/g726-16": {
        "source": "iana"
    },
    "audio/g726-24": {
        "source": "iana"
    },
    "audio/g726-32": {
        "source": "iana"
    },
    "audio/g726-40": {
        "source": "iana"
    },
    "audio/g728": {
        "source": "iana"
    },
    "audio/g729": {
        "source": "iana"
    },
    "audio/g7291": {
        "source": "iana"
    },
    "audio/g729d": {
        "source": "iana"
    },
    "audio/g729e": {
        "source": "iana"
    },
    "audio/gsm": {
        "source": "iana"
    },
    "audio/gsm-efr": {
        "source": "iana"
    },
    "audio/gsm-hr-08": {
        "source": "iana"
    },
    "audio/ilbc": {
        "source": "iana"
    },
    "audio/ip-mr_v2.5": {
        "source": "iana"
    },
    "audio/isac": {
        "source": "apache"
    },
    "audio/l16": {
        "source": "iana"
    },
    "audio/l20": {
        "source": "iana"
    },
    "audio/l24": {
        "source": "iana",
        "compressible": false
    },
    "audio/l8": {
        "source": "iana"
    },
    "audio/lpc": {
        "source": "iana"
    },
    "audio/melp": {
        "source": "iana"
    },
    "audio/melp1200": {
        "source": "iana"
    },
    "audio/melp2400": {
        "source": "iana"
    },
    "audio/melp600": {
        "source": "iana"
    },
    "audio/mhas": {
        "source": "iana"
    },
    "audio/midi": {
        "source": "apache",
        "extensions": [
            "mid",
            "midi",
            "kar",
            "rmi"
        ]
    },
    "audio/mobile-xmf": {
        "source": "iana",
        "extensions": [
            "mxmf"
        ]
    },
    "audio/mp3": {
        "compressible": false,
        "extensions": [
            "mp3"
        ]
    },
    "audio/mp4": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "m4a",
            "mp4a"
        ]
    },
    "audio/mp4a-latm": {
        "source": "iana"
    },
    "audio/mpa": {
        "source": "iana"
    },
    "audio/mpa-robust": {
        "source": "iana"
    },
    "audio/mpeg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "mpga",
            "mp2",
            "mp2a",
            "mp3",
            "m2a",
            "m3a"
        ]
    },
    "audio/mpeg4-generic": {
        "source": "iana"
    },
    "audio/musepack": {
        "source": "apache"
    },
    "audio/ogg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "oga",
            "ogg",
            "spx",
            "opus"
        ]
    },
    "audio/opus": {
        "source": "iana"
    },
    "audio/parityfec": {
        "source": "iana"
    },
    "audio/pcma": {
        "source": "iana"
    },
    "audio/pcma-wb": {
        "source": "iana"
    },
    "audio/pcmu": {
        "source": "iana"
    },
    "audio/pcmu-wb": {
        "source": "iana"
    },
    "audio/prs.sid": {
        "source": "iana"
    },
    "audio/qcelp": {
        "source": "iana"
    },
    "audio/raptorfec": {
        "source": "iana"
    },
    "audio/red": {
        "source": "iana"
    },
    "audio/rtp-enc-aescm128": {
        "source": "iana"
    },
    "audio/rtp-midi": {
        "source": "iana"
    },
    "audio/rtploopback": {
        "source": "iana"
    },
    "audio/rtx": {
        "source": "iana"
    },
    "audio/s3m": {
        "source": "apache",
        "extensions": [
            "s3m"
        ]
    },
    "audio/scip": {
        "source": "iana"
    },
    "audio/silk": {
        "source": "apache",
        "extensions": [
            "sil"
        ]
    },
    "audio/smv": {
        "source": "iana"
    },
    "audio/smv-qcp": {
        "source": "iana"
    },
    "audio/smv0": {
        "source": "iana"
    },
    "audio/sofa": {
        "source": "iana"
    },
    "audio/sp-midi": {
        "source": "iana"
    },
    "audio/speex": {
        "source": "iana"
    },
    "audio/t140c": {
        "source": "iana"
    },
    "audio/t38": {
        "source": "iana"
    },
    "audio/telephone-event": {
        "source": "iana"
    },
    "audio/tetra_acelp": {
        "source": "iana"
    },
    "audio/tetra_acelp_bb": {
        "source": "iana"
    },
    "audio/tone": {
        "source": "iana"
    },
    "audio/tsvcis": {
        "source": "iana"
    },
    "audio/uemclip": {
        "source": "iana"
    },
    "audio/ulpfec": {
        "source": "iana"
    },
    "audio/usac": {
        "source": "iana"
    },
    "audio/vdvi": {
        "source": "iana"
    },
    "audio/vmr-wb": {
        "source": "iana"
    },
    "audio/vnd.3gpp.iufp": {
        "source": "iana"
    },
    "audio/vnd.4sb": {
        "source": "iana"
    },
    "audio/vnd.audiokoz": {
        "source": "iana"
    },
    "audio/vnd.celp": {
        "source": "iana"
    },
    "audio/vnd.cisco.nse": {
        "source": "iana"
    },
    "audio/vnd.cmles.radio-events": {
        "source": "iana"
    },
    "audio/vnd.cns.anp1": {
        "source": "iana"
    },
    "audio/vnd.cns.inf1": {
        "source": "iana"
    },
    "audio/vnd.dece.audio": {
        "source": "iana",
        "extensions": [
            "uva",
            "uvva"
        ]
    },
    "audio/vnd.digital-winds": {
        "source": "iana",
        "extensions": [
            "eol"
        ]
    },
    "audio/vnd.dlna.adts": {
        "source": "iana"
    },
    "audio/vnd.dolby.heaac.1": {
        "source": "iana"
    },
    "audio/vnd.dolby.heaac.2": {
        "source": "iana"
    },
    "audio/vnd.dolby.mlp": {
        "source": "iana"
    },
    "audio/vnd.dolby.mps": {
        "source": "iana"
    },
    "audio/vnd.dolby.pl2": {
        "source": "iana"
    },
    "audio/vnd.dolby.pl2x": {
        "source": "iana"
    },
    "audio/vnd.dolby.pl2z": {
        "source": "iana"
    },
    "audio/vnd.dolby.pulse.1": {
        "source": "iana"
    },
    "audio/vnd.dra": {
        "source": "iana",
        "extensions": [
            "dra"
        ]
    },
    "audio/vnd.dts": {
        "source": "iana",
        "extensions": [
            "dts"
        ]
    },
    "audio/vnd.dts.hd": {
        "source": "iana",
        "extensions": [
            "dtshd"
        ]
    },
    "audio/vnd.dts.uhd": {
        "source": "iana"
    },
    "audio/vnd.dvb.file": {
        "source": "iana"
    },
    "audio/vnd.everad.plj": {
        "source": "iana"
    },
    "audio/vnd.hns.audio": {
        "source": "iana"
    },
    "audio/vnd.lucent.voice": {
        "source": "iana",
        "extensions": [
            "lvp"
        ]
    },
    "audio/vnd.ms-playready.media.pya": {
        "source": "iana",
        "extensions": [
            "pya"
        ]
    },
    "audio/vnd.nokia.mobile-xmf": {
        "source": "iana"
    },
    "audio/vnd.nortel.vbk": {
        "source": "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
        "source": "iana",
        "extensions": [
            "ecelp4800"
        ]
    },
    "audio/vnd.nuera.ecelp7470": {
        "source": "iana",
        "extensions": [
            "ecelp7470"
        ]
    },
    "audio/vnd.nuera.ecelp9600": {
        "source": "iana",
        "extensions": [
            "ecelp9600"
        ]
    },
    "audio/vnd.octel.sbc": {
        "source": "iana"
    },
    "audio/vnd.presonus.multitrack": {
        "source": "iana"
    },
    "audio/vnd.qcelp": {
        "source": "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
        "source": "iana"
    },
    "audio/vnd.rip": {
        "source": "iana",
        "extensions": [
            "rip"
        ]
    },
    "audio/vnd.rn-realaudio": {
        "compressible": false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
        "source": "iana"
    },
    "audio/vnd.vmx.cvsd": {
        "source": "iana"
    },
    "audio/vnd.wave": {
        "compressible": false
    },
    "audio/vorbis": {
        "source": "iana",
        "compressible": false
    },
    "audio/vorbis-config": {
        "source": "iana"
    },
    "audio/wav": {
        "compressible": false,
        "extensions": [
            "wav"
        ]
    },
    "audio/wave": {
        "compressible": false,
        "extensions": [
            "wav"
        ]
    },
    "audio/webm": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "weba"
        ]
    },
    "audio/x-aac": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "aac"
        ]
    },
    "audio/x-aiff": {
        "source": "apache",
        "extensions": [
            "aif",
            "aiff",
            "aifc"
        ]
    },
    "audio/x-caf": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "caf"
        ]
    },
    "audio/x-flac": {
        "source": "apache",
        "extensions": [
            "flac"
        ]
    },
    "audio/x-m4a": {
        "source": "nginx",
        "extensions": [
            "m4a"
        ]
    },
    "audio/x-matroska": {
        "source": "apache",
        "extensions": [
            "mka"
        ]
    },
    "audio/x-mpegurl": {
        "source": "apache",
        "extensions": [
            "m3u"
        ]
    },
    "audio/x-ms-wax": {
        "source": "apache",
        "extensions": [
            "wax"
        ]
    },
    "audio/x-ms-wma": {
        "source": "apache",
        "extensions": [
            "wma"
        ]
    },
    "audio/x-pn-realaudio": {
        "source": "apache",
        "extensions": [
            "ram",
            "ra"
        ]
    },
    "audio/x-pn-realaudio-plugin": {
        "source": "apache",
        "extensions": [
            "rmp"
        ]
    },
    "audio/x-realaudio": {
        "source": "nginx",
        "extensions": [
            "ra"
        ]
    },
    "audio/x-tta": {
        "source": "apache"
    },
    "audio/x-wav": {
        "source": "apache",
        "extensions": [
            "wav"
        ]
    },
    "audio/xm": {
        "source": "apache",
        "extensions": [
            "xm"
        ]
    },
    "chemical/x-cdx": {
        "source": "apache",
        "extensions": [
            "cdx"
        ]
    },
    "chemical/x-cif": {
        "source": "apache",
        "extensions": [
            "cif"
        ]
    },
    "chemical/x-cmdf": {
        "source": "apache",
        "extensions": [
            "cmdf"
        ]
    },
    "chemical/x-cml": {
        "source": "apache",
        "extensions": [
            "cml"
        ]
    },
    "chemical/x-csml": {
        "source": "apache",
        "extensions": [
            "csml"
        ]
    },
    "chemical/x-pdb": {
        "source": "apache"
    },
    "chemical/x-xyz": {
        "source": "apache",
        "extensions": [
            "xyz"
        ]
    },
    "font/collection": {
        "source": "iana",
        "extensions": [
            "ttc"
        ]
    },
    "font/otf": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "otf"
        ]
    },
    "font/sfnt": {
        "source": "iana"
    },
    "font/ttf": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ttf"
        ]
    },
    "font/woff": {
        "source": "iana",
        "extensions": [
            "woff"
        ]
    },
    "font/woff2": {
        "source": "iana",
        "extensions": [
            "woff2"
        ]
    },
    "image/aces": {
        "source": "iana",
        "extensions": [
            "exr"
        ]
    },
    "image/apng": {
        "compressible": false,
        "extensions": [
            "apng"
        ]
    },
    "image/avci": {
        "source": "iana",
        "extensions": [
            "avci"
        ]
    },
    "image/avcs": {
        "source": "iana",
        "extensions": [
            "avcs"
        ]
    },
    "image/avif": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "avif"
        ]
    },
    "image/bmp": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "bmp"
        ]
    },
    "image/cgm": {
        "source": "iana",
        "extensions": [
            "cgm"
        ]
    },
    "image/dicom-rle": {
        "source": "iana",
        "extensions": [
            "drle"
        ]
    },
    "image/emf": {
        "source": "iana",
        "extensions": [
            "emf"
        ]
    },
    "image/fits": {
        "source": "iana",
        "extensions": [
            "fits"
        ]
    },
    "image/g3fax": {
        "source": "iana",
        "extensions": [
            "g3"
        ]
    },
    "image/gif": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "gif"
        ]
    },
    "image/heic": {
        "source": "iana",
        "extensions": [
            "heic"
        ]
    },
    "image/heic-sequence": {
        "source": "iana",
        "extensions": [
            "heics"
        ]
    },
    "image/heif": {
        "source": "iana",
        "extensions": [
            "heif"
        ]
    },
    "image/heif-sequence": {
        "source": "iana",
        "extensions": [
            "heifs"
        ]
    },
    "image/hej2k": {
        "source": "iana",
        "extensions": [
            "hej2"
        ]
    },
    "image/hsj2": {
        "source": "iana",
        "extensions": [
            "hsj2"
        ]
    },
    "image/ief": {
        "source": "iana",
        "extensions": [
            "ief"
        ]
    },
    "image/jls": {
        "source": "iana",
        "extensions": [
            "jls"
        ]
    },
    "image/jp2": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "jp2",
            "jpg2"
        ]
    },
    "image/jpeg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "jpeg",
            "jpg",
            "jpe"
        ]
    },
    "image/jph": {
        "source": "iana",
        "extensions": [
            "jph"
        ]
    },
    "image/jphc": {
        "source": "iana",
        "extensions": [
            "jhc"
        ]
    },
    "image/jpm": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "jpm"
        ]
    },
    "image/jpx": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "jpx",
            "jpf"
        ]
    },
    "image/jxr": {
        "source": "iana",
        "extensions": [
            "jxr"
        ]
    },
    "image/jxra": {
        "source": "iana",
        "extensions": [
            "jxra"
        ]
    },
    "image/jxrs": {
        "source": "iana",
        "extensions": [
            "jxrs"
        ]
    },
    "image/jxs": {
        "source": "iana",
        "extensions": [
            "jxs"
        ]
    },
    "image/jxsc": {
        "source": "iana",
        "extensions": [
            "jxsc"
        ]
    },
    "image/jxsi": {
        "source": "iana",
        "extensions": [
            "jxsi"
        ]
    },
    "image/jxss": {
        "source": "iana",
        "extensions": [
            "jxss"
        ]
    },
    "image/ktx": {
        "source": "iana",
        "extensions": [
            "ktx"
        ]
    },
    "image/ktx2": {
        "source": "iana",
        "extensions": [
            "ktx2"
        ]
    },
    "image/naplps": {
        "source": "iana"
    },
    "image/pjpeg": {
        "compressible": false
    },
    "image/png": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "png"
        ]
    },
    "image/prs.btif": {
        "source": "iana",
        "extensions": [
            "btif"
        ]
    },
    "image/prs.pti": {
        "source": "iana",
        "extensions": [
            "pti"
        ]
    },
    "image/pwg-raster": {
        "source": "iana"
    },
    "image/sgi": {
        "source": "apache",
        "extensions": [
            "sgi"
        ]
    },
    "image/svg+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "svg",
            "svgz"
        ]
    },
    "image/t38": {
        "source": "iana",
        "extensions": [
            "t38"
        ]
    },
    "image/tiff": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "tif",
            "tiff"
        ]
    },
    "image/tiff-fx": {
        "source": "iana",
        "extensions": [
            "tfx"
        ]
    },
    "image/vnd.adobe.photoshop": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "psd"
        ]
    },
    "image/vnd.airzip.accelerator.azv": {
        "source": "iana",
        "extensions": [
            "azv"
        ]
    },
    "image/vnd.cns.inf2": {
        "source": "iana"
    },
    "image/vnd.dece.graphic": {
        "source": "iana",
        "extensions": [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ]
    },
    "image/vnd.djvu": {
        "source": "iana",
        "extensions": [
            "djvu",
            "djv"
        ]
    },
    "image/vnd.dvb.subtitle": {
        "source": "iana",
        "extensions": [
            "sub"
        ]
    },
    "image/vnd.dwg": {
        "source": "iana",
        "extensions": [
            "dwg"
        ]
    },
    "image/vnd.dxf": {
        "source": "iana",
        "extensions": [
            "dxf"
        ]
    },
    "image/vnd.fastbidsheet": {
        "source": "iana",
        "extensions": [
            "fbs"
        ]
    },
    "image/vnd.fpx": {
        "source": "iana",
        "extensions": [
            "fpx"
        ]
    },
    "image/vnd.fst": {
        "source": "iana",
        "extensions": [
            "fst"
        ]
    },
    "image/vnd.fujixerox.edmics-mmr": {
        "source": "iana",
        "extensions": [
            "mmr"
        ]
    },
    "image/vnd.fujixerox.edmics-rlc": {
        "source": "iana",
        "extensions": [
            "rlc"
        ]
    },
    "image/vnd.globalgraphics.pgb": {
        "source": "iana"
    },
    "image/vnd.microsoft.icon": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "ico"
        ]
    },
    "image/vnd.mix": {
        "source": "iana"
    },
    "image/vnd.mozilla.apng": {
        "source": "iana"
    },
    "image/vnd.ms-dds": {
        "compressible": true,
        "extensions": [
            "dds"
        ]
    },
    "image/vnd.ms-modi": {
        "source": "iana",
        "extensions": [
            "mdi"
        ]
    },
    "image/vnd.ms-photo": {
        "source": "apache",
        "extensions": [
            "wdp"
        ]
    },
    "image/vnd.net-fpx": {
        "source": "iana",
        "extensions": [
            "npx"
        ]
    },
    "image/vnd.pco.b16": {
        "source": "iana",
        "extensions": [
            "b16"
        ]
    },
    "image/vnd.radiance": {
        "source": "iana"
    },
    "image/vnd.sealed.png": {
        "source": "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
        "source": "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
        "source": "iana"
    },
    "image/vnd.svf": {
        "source": "iana"
    },
    "image/vnd.tencent.tap": {
        "source": "iana",
        "extensions": [
            "tap"
        ]
    },
    "image/vnd.valve.source.texture": {
        "source": "iana",
        "extensions": [
            "vtf"
        ]
    },
    "image/vnd.wap.wbmp": {
        "source": "iana",
        "extensions": [
            "wbmp"
        ]
    },
    "image/vnd.xiff": {
        "source": "iana",
        "extensions": [
            "xif"
        ]
    },
    "image/vnd.zbrush.pcx": {
        "source": "iana",
        "extensions": [
            "pcx"
        ]
    },
    "image/webp": {
        "source": "apache",
        "extensions": [
            "webp"
        ]
    },
    "image/wmf": {
        "source": "iana",
        "extensions": [
            "wmf"
        ]
    },
    "image/x-3ds": {
        "source": "apache",
        "extensions": [
            "3ds"
        ]
    },
    "image/x-cmu-raster": {
        "source": "apache",
        "extensions": [
            "ras"
        ]
    },
    "image/x-cmx": {
        "source": "apache",
        "extensions": [
            "cmx"
        ]
    },
    "image/x-freehand": {
        "source": "apache",
        "extensions": [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ]
    },
    "image/x-icon": {
        "source": "apache",
        "compressible": true,
        "extensions": [
            "ico"
        ]
    },
    "image/x-jng": {
        "source": "nginx",
        "extensions": [
            "jng"
        ]
    },
    "image/x-mrsid-image": {
        "source": "apache",
        "extensions": [
            "sid"
        ]
    },
    "image/x-ms-bmp": {
        "source": "nginx",
        "compressible": true,
        "extensions": [
            "bmp"
        ]
    },
    "image/x-pcx": {
        "source": "apache",
        "extensions": [
            "pcx"
        ]
    },
    "image/x-pict": {
        "source": "apache",
        "extensions": [
            "pic",
            "pct"
        ]
    },
    "image/x-portable-anymap": {
        "source": "apache",
        "extensions": [
            "pnm"
        ]
    },
    "image/x-portable-bitmap": {
        "source": "apache",
        "extensions": [
            "pbm"
        ]
    },
    "image/x-portable-graymap": {
        "source": "apache",
        "extensions": [
            "pgm"
        ]
    },
    "image/x-portable-pixmap": {
        "source": "apache",
        "extensions": [
            "ppm"
        ]
    },
    "image/x-rgb": {
        "source": "apache",
        "extensions": [
            "rgb"
        ]
    },
    "image/x-tga": {
        "source": "apache",
        "extensions": [
            "tga"
        ]
    },
    "image/x-xbitmap": {
        "source": "apache",
        "extensions": [
            "xbm"
        ]
    },
    "image/x-xcf": {
        "compressible": false
    },
    "image/x-xpixmap": {
        "source": "apache",
        "extensions": [
            "xpm"
        ]
    },
    "image/x-xwindowdump": {
        "source": "apache",
        "extensions": [
            "xwd"
        ]
    },
    "message/cpim": {
        "source": "iana"
    },
    "message/delivery-status": {
        "source": "iana"
    },
    "message/disposition-notification": {
        "source": "iana",
        "extensions": [
            "disposition-notification"
        ]
    },
    "message/external-body": {
        "source": "iana"
    },
    "message/feedback-report": {
        "source": "iana"
    },
    "message/global": {
        "source": "iana",
        "extensions": [
            "u8msg"
        ]
    },
    "message/global-delivery-status": {
        "source": "iana",
        "extensions": [
            "u8dsn"
        ]
    },
    "message/global-disposition-notification": {
        "source": "iana",
        "extensions": [
            "u8mdn"
        ]
    },
    "message/global-headers": {
        "source": "iana",
        "extensions": [
            "u8hdr"
        ]
    },
    "message/http": {
        "source": "iana",
        "compressible": false
    },
    "message/imdn+xml": {
        "source": "iana",
        "compressible": true
    },
    "message/news": {
        "source": "iana"
    },
    "message/partial": {
        "source": "iana",
        "compressible": false
    },
    "message/rfc822": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "eml",
            "mime"
        ]
    },
    "message/s-http": {
        "source": "iana"
    },
    "message/sip": {
        "source": "iana"
    },
    "message/sipfrag": {
        "source": "iana"
    },
    "message/tracking-status": {
        "source": "iana"
    },
    "message/vnd.si.simp": {
        "source": "iana"
    },
    "message/vnd.wfa.wsc": {
        "source": "iana",
        "extensions": [
            "wsc"
        ]
    },
    "model/3mf": {
        "source": "iana",
        "extensions": [
            "3mf"
        ]
    },
    "model/e57": {
        "source": "iana"
    },
    "model/gltf+json": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "gltf"
        ]
    },
    "model/gltf-binary": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "glb"
        ]
    },
    "model/iges": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "igs",
            "iges"
        ]
    },
    "model/mesh": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "msh",
            "mesh",
            "silo"
        ]
    },
    "model/mtl": {
        "source": "iana",
        "extensions": [
            "mtl"
        ]
    },
    "model/obj": {
        "source": "iana",
        "extensions": [
            "obj"
        ]
    },
    "model/step": {
        "source": "iana"
    },
    "model/step+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "stpx"
        ]
    },
    "model/step+zip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "stpz"
        ]
    },
    "model/step-xml+zip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "stpxz"
        ]
    },
    "model/stl": {
        "source": "iana",
        "extensions": [
            "stl"
        ]
    },
    "model/vnd.collada+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "dae"
        ]
    },
    "model/vnd.dwf": {
        "source": "iana",
        "extensions": [
            "dwf"
        ]
    },
    "model/vnd.flatland.3dml": {
        "source": "iana"
    },
    "model/vnd.gdl": {
        "source": "iana",
        "extensions": [
            "gdl"
        ]
    },
    "model/vnd.gs-gdl": {
        "source": "apache"
    },
    "model/vnd.gs.gdl": {
        "source": "iana"
    },
    "model/vnd.gtw": {
        "source": "iana",
        "extensions": [
            "gtw"
        ]
    },
    "model/vnd.moml+xml": {
        "source": "iana",
        "compressible": true
    },
    "model/vnd.mts": {
        "source": "iana",
        "extensions": [
            "mts"
        ]
    },
    "model/vnd.opengex": {
        "source": "iana",
        "extensions": [
            "ogex"
        ]
    },
    "model/vnd.parasolid.transmit.binary": {
        "source": "iana",
        "extensions": [
            "x_b"
        ]
    },
    "model/vnd.parasolid.transmit.text": {
        "source": "iana",
        "extensions": [
            "x_t"
        ]
    },
    "model/vnd.pytha.pyox": {
        "source": "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
        "source": "iana"
    },
    "model/vnd.sap.vds": {
        "source": "iana",
        "extensions": [
            "vds"
        ]
    },
    "model/vnd.usdz+zip": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "usdz"
        ]
    },
    "model/vnd.valve.source.compiled-map": {
        "source": "iana",
        "extensions": [
            "bsp"
        ]
    },
    "model/vnd.vtu": {
        "source": "iana",
        "extensions": [
            "vtu"
        ]
    },
    "model/vrml": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "wrl",
            "vrml"
        ]
    },
    "model/x3d+binary": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "x3db",
            "x3dbz"
        ]
    },
    "model/x3d+fastinfoset": {
        "source": "iana",
        "extensions": [
            "x3db"
        ]
    },
    "model/x3d+vrml": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "x3dv",
            "x3dvz"
        ]
    },
    "model/x3d+xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "x3d",
            "x3dz"
        ]
    },
    "model/x3d-vrml": {
        "source": "iana",
        "extensions": [
            "x3dv"
        ]
    },
    "multipart/alternative": {
        "source": "iana",
        "compressible": false
    },
    "multipart/appledouble": {
        "source": "iana"
    },
    "multipart/byteranges": {
        "source": "iana"
    },
    "multipart/digest": {
        "source": "iana"
    },
    "multipart/encrypted": {
        "source": "iana",
        "compressible": false
    },
    "multipart/form-data": {
        "source": "iana",
        "compressible": false
    },
    "multipart/header-set": {
        "source": "iana"
    },
    "multipart/mixed": {
        "source": "iana"
    },
    "multipart/multilingual": {
        "source": "iana"
    },
    "multipart/parallel": {
        "source": "iana"
    },
    "multipart/related": {
        "source": "iana",
        "compressible": false
    },
    "multipart/report": {
        "source": "iana"
    },
    "multipart/signed": {
        "source": "iana",
        "compressible": false
    },
    "multipart/vnd.bint.med-plus": {
        "source": "iana"
    },
    "multipart/voice-message": {
        "source": "iana"
    },
    "multipart/x-mixed-replace": {
        "source": "iana"
    },
    "text/1d-interleaved-parityfec": {
        "source": "iana"
    },
    "text/cache-manifest": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "appcache",
            "manifest"
        ]
    },
    "text/calendar": {
        "source": "iana",
        "extensions": [
            "ics",
            "ifb"
        ]
    },
    "text/calender": {
        "compressible": true
    },
    "text/cmd": {
        "compressible": true
    },
    "text/coffeescript": {
        "extensions": [
            "coffee",
            "litcoffee"
        ]
    },
    "text/cql": {
        "source": "iana"
    },
    "text/cql-expression": {
        "source": "iana"
    },
    "text/cql-identifier": {
        "source": "iana"
    },
    "text/css": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "css"
        ]
    },
    "text/csv": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "csv"
        ]
    },
    "text/csv-schema": {
        "source": "iana"
    },
    "text/directory": {
        "source": "iana"
    },
    "text/dns": {
        "source": "iana"
    },
    "text/ecmascript": {
        "source": "iana"
    },
    "text/encaprtp": {
        "source": "iana"
    },
    "text/enriched": {
        "source": "iana"
    },
    "text/fhirpath": {
        "source": "iana"
    },
    "text/flexfec": {
        "source": "iana"
    },
    "text/fwdred": {
        "source": "iana"
    },
    "text/gff3": {
        "source": "iana"
    },
    "text/grammar-ref-list": {
        "source": "iana"
    },
    "text/html": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "html",
            "htm",
            "shtml"
        ]
    },
    "text/jade": {
        "extensions": [
            "jade"
        ]
    },
    "text/javascript": {
        "source": "iana",
        "compressible": true
    },
    "text/jcr-cnd": {
        "source": "iana"
    },
    "text/jsx": {
        "compressible": true,
        "extensions": [
            "jsx"
        ]
    },
    "text/less": {
        "compressible": true,
        "extensions": [
            "less"
        ]
    },
    "text/markdown": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "markdown",
            "md"
        ]
    },
    "text/mathml": {
        "source": "nginx",
        "extensions": [
            "mml"
        ]
    },
    "text/mdx": {
        "compressible": true,
        "extensions": [
            "mdx"
        ]
    },
    "text/mizar": {
        "source": "iana"
    },
    "text/n3": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "n3"
        ]
    },
    "text/parameters": {
        "source": "iana",
        "charset": "UTF-8"
    },
    "text/parityfec": {
        "source": "iana"
    },
    "text/plain": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "txt",
            "text",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "ini"
        ]
    },
    "text/provenance-notation": {
        "source": "iana",
        "charset": "UTF-8"
    },
    "text/prs.fallenstein.rst": {
        "source": "iana"
    },
    "text/prs.lines.tag": {
        "source": "iana",
        "extensions": [
            "dsc"
        ]
    },
    "text/prs.prop.logic": {
        "source": "iana"
    },
    "text/raptorfec": {
        "source": "iana"
    },
    "text/red": {
        "source": "iana"
    },
    "text/rfc822-headers": {
        "source": "iana"
    },
    "text/richtext": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rtx"
        ]
    },
    "text/rtf": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "rtf"
        ]
    },
    "text/rtp-enc-aescm128": {
        "source": "iana"
    },
    "text/rtploopback": {
        "source": "iana"
    },
    "text/rtx": {
        "source": "iana"
    },
    "text/sgml": {
        "source": "iana",
        "extensions": [
            "sgml",
            "sgm"
        ]
    },
    "text/shaclc": {
        "source": "iana"
    },
    "text/shex": {
        "source": "iana",
        "extensions": [
            "shex"
        ]
    },
    "text/slim": {
        "extensions": [
            "slim",
            "slm"
        ]
    },
    "text/spdx": {
        "source": "iana",
        "extensions": [
            "spdx"
        ]
    },
    "text/strings": {
        "source": "iana"
    },
    "text/stylus": {
        "extensions": [
            "stylus",
            "styl"
        ]
    },
    "text/t140": {
        "source": "iana"
    },
    "text/tab-separated-values": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "tsv"
        ]
    },
    "text/troff": {
        "source": "iana",
        "extensions": [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ]
    },
    "text/turtle": {
        "source": "iana",
        "charset": "UTF-8",
        "extensions": [
            "ttl"
        ]
    },
    "text/ulpfec": {
        "source": "iana"
    },
    "text/uri-list": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "uri",
            "uris",
            "urls"
        ]
    },
    "text/vcard": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "vcard"
        ]
    },
    "text/vnd.a": {
        "source": "iana"
    },
    "text/vnd.abc": {
        "source": "iana"
    },
    "text/vnd.ascii-art": {
        "source": "iana"
    },
    "text/vnd.curl": {
        "source": "iana",
        "extensions": [
            "curl"
        ]
    },
    "text/vnd.curl.dcurl": {
        "source": "apache",
        "extensions": [
            "dcurl"
        ]
    },
    "text/vnd.curl.mcurl": {
        "source": "apache",
        "extensions": [
            "mcurl"
        ]
    },
    "text/vnd.curl.scurl": {
        "source": "apache",
        "extensions": [
            "scurl"
        ]
    },
    "text/vnd.debian.copyright": {
        "source": "iana",
        "charset": "UTF-8"
    },
    "text/vnd.dmclientscript": {
        "source": "iana"
    },
    "text/vnd.dvb.subtitle": {
        "source": "iana",
        "extensions": [
            "sub"
        ]
    },
    "text/vnd.esmertec.theme-descriptor": {
        "source": "iana",
        "charset": "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
        "source": "iana",
        "extensions": [
            "ged"
        ]
    },
    "text/vnd.ficlab.flt": {
        "source": "iana"
    },
    "text/vnd.fly": {
        "source": "iana",
        "extensions": [
            "fly"
        ]
    },
    "text/vnd.fmi.flexstor": {
        "source": "iana",
        "extensions": [
            "flx"
        ]
    },
    "text/vnd.gml": {
        "source": "iana"
    },
    "text/vnd.graphviz": {
        "source": "iana",
        "extensions": [
            "gv"
        ]
    },
    "text/vnd.hans": {
        "source": "iana"
    },
    "text/vnd.hgl": {
        "source": "iana"
    },
    "text/vnd.in3d.3dml": {
        "source": "iana",
        "extensions": [
            "3dml"
        ]
    },
    "text/vnd.in3d.spot": {
        "source": "iana",
        "extensions": [
            "spot"
        ]
    },
    "text/vnd.iptc.newsml": {
        "source": "iana"
    },
    "text/vnd.iptc.nitf": {
        "source": "iana"
    },
    "text/vnd.latex-z": {
        "source": "iana"
    },
    "text/vnd.motorola.reflex": {
        "source": "iana"
    },
    "text/vnd.ms-mediapackage": {
        "source": "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
        "source": "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
        "source": "iana"
    },
    "text/vnd.senx.warpscript": {
        "source": "iana"
    },
    "text/vnd.si.uricatalogue": {
        "source": "iana"
    },
    "text/vnd.sosi": {
        "source": "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
        "source": "iana",
        "charset": "UTF-8",
        "extensions": [
            "jad"
        ]
    },
    "text/vnd.trolltech.linguist": {
        "source": "iana",
        "charset": "UTF-8"
    },
    "text/vnd.wap.si": {
        "source": "iana"
    },
    "text/vnd.wap.sl": {
        "source": "iana"
    },
    "text/vnd.wap.wml": {
        "source": "iana",
        "extensions": [
            "wml"
        ]
    },
    "text/vnd.wap.wmlscript": {
        "source": "iana",
        "extensions": [
            "wmls"
        ]
    },
    "text/vtt": {
        "source": "iana",
        "charset": "UTF-8",
        "compressible": true,
        "extensions": [
            "vtt"
        ]
    },
    "text/x-asm": {
        "source": "apache",
        "extensions": [
            "s",
            "asm"
        ]
    },
    "text/x-c": {
        "source": "apache",
        "extensions": [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ]
    },
    "text/x-component": {
        "source": "nginx",
        "extensions": [
            "htc"
        ]
    },
    "text/x-fortran": {
        "source": "apache",
        "extensions": [
            "f",
            "for",
            "f77",
            "f90"
        ]
    },
    "text/x-gwt-rpc": {
        "compressible": true
    },
    "text/x-handlebars-template": {
        "extensions": [
            "hbs"
        ]
    },
    "text/x-java-source": {
        "source": "apache",
        "extensions": [
            "java"
        ]
    },
    "text/x-jquery-tmpl": {
        "compressible": true
    },
    "text/x-lua": {
        "extensions": [
            "lua"
        ]
    },
    "text/x-markdown": {
        "compressible": true,
        "extensions": [
            "mkd"
        ]
    },
    "text/x-nfo": {
        "source": "apache",
        "extensions": [
            "nfo"
        ]
    },
    "text/x-opml": {
        "source": "apache",
        "extensions": [
            "opml"
        ]
    },
    "text/x-org": {
        "compressible": true,
        "extensions": [
            "org"
        ]
    },
    "text/x-pascal": {
        "source": "apache",
        "extensions": [
            "p",
            "pas"
        ]
    },
    "text/x-processing": {
        "compressible": true,
        "extensions": [
            "pde"
        ]
    },
    "text/x-sass": {
        "extensions": [
            "sass"
        ]
    },
    "text/x-scss": {
        "extensions": [
            "scss"
        ]
    },
    "text/x-setext": {
        "source": "apache",
        "extensions": [
            "etx"
        ]
    },
    "text/x-sfv": {
        "source": "apache",
        "extensions": [
            "sfv"
        ]
    },
    "text/x-suse-ymp": {
        "compressible": true,
        "extensions": [
            "ymp"
        ]
    },
    "text/x-uuencode": {
        "source": "apache",
        "extensions": [
            "uu"
        ]
    },
    "text/x-vcalendar": {
        "source": "apache",
        "extensions": [
            "vcs"
        ]
    },
    "text/x-vcard": {
        "source": "apache",
        "extensions": [
            "vcf"
        ]
    },
    "text/xml": {
        "source": "iana",
        "compressible": true,
        "extensions": [
            "xml"
        ]
    },
    "text/xml-external-parsed-entity": {
        "source": "iana"
    },
    "text/yaml": {
        "compressible": true,
        "extensions": [
            "yaml",
            "yml"
        ]
    },
    "video/1d-interleaved-parityfec": {
        "source": "iana"
    },
    "video/3gpp": {
        "source": "iana",
        "extensions": [
            "3gp",
            "3gpp"
        ]
    },
    "video/3gpp-tt": {
        "source": "iana"
    },
    "video/3gpp2": {
        "source": "iana",
        "extensions": [
            "3g2"
        ]
    },
    "video/av1": {
        "source": "iana"
    },
    "video/bmpeg": {
        "source": "iana"
    },
    "video/bt656": {
        "source": "iana"
    },
    "video/celb": {
        "source": "iana"
    },
    "video/dv": {
        "source": "iana"
    },
    "video/encaprtp": {
        "source": "iana"
    },
    "video/ffv1": {
        "source": "iana"
    },
    "video/flexfec": {
        "source": "iana"
    },
    "video/h261": {
        "source": "iana",
        "extensions": [
            "h261"
        ]
    },
    "video/h263": {
        "source": "iana",
        "extensions": [
            "h263"
        ]
    },
    "video/h263-1998": {
        "source": "iana"
    },
    "video/h263-2000": {
        "source": "iana"
    },
    "video/h264": {
        "source": "iana",
        "extensions": [
            "h264"
        ]
    },
    "video/h264-rcdo": {
        "source": "iana"
    },
    "video/h264-svc": {
        "source": "iana"
    },
    "video/h265": {
        "source": "iana"
    },
    "video/iso.segment": {
        "source": "iana",
        "extensions": [
            "m4s"
        ]
    },
    "video/jpeg": {
        "source": "iana",
        "extensions": [
            "jpgv"
        ]
    },
    "video/jpeg2000": {
        "source": "iana"
    },
    "video/jpm": {
        "source": "apache",
        "extensions": [
            "jpm",
            "jpgm"
        ]
    },
    "video/jxsv": {
        "source": "iana"
    },
    "video/mj2": {
        "source": "iana",
        "extensions": [
            "mj2",
            "mjp2"
        ]
    },
    "video/mp1s": {
        "source": "iana"
    },
    "video/mp2p": {
        "source": "iana"
    },
    "video/mp2t": {
        "source": "iana",
        "extensions": [
            "ts"
        ]
    },
    "video/mp4": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "mp4",
            "mp4v",
            "mpg4"
        ]
    },
    "video/mp4v-es": {
        "source": "iana"
    },
    "video/mpeg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v"
        ]
    },
    "video/mpeg4-generic": {
        "source": "iana"
    },
    "video/mpv": {
        "source": "iana"
    },
    "video/nv": {
        "source": "iana"
    },
    "video/ogg": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "ogv"
        ]
    },
    "video/parityfec": {
        "source": "iana"
    },
    "video/pointer": {
        "source": "iana"
    },
    "video/quicktime": {
        "source": "iana",
        "compressible": false,
        "extensions": [
            "qt",
            "mov"
        ]
    },
    "video/raptorfec": {
        "source": "iana"
    },
    "video/raw": {
        "source": "iana"
    },
    "video/rtp-enc-aescm128": {
        "source": "iana"
    },
    "video/rtploopback": {
        "source": "iana"
    },
    "video/rtx": {
        "source": "iana"
    },
    "video/scip": {
        "source": "iana"
    },
    "video/smpte291": {
        "source": "iana"
    },
    "video/smpte292m": {
        "source": "iana"
    },
    "video/ulpfec": {
        "source": "iana"
    },
    "video/vc1": {
        "source": "iana"
    },
    "video/vc2": {
        "source": "iana"
    },
    "video/vnd.cctv": {
        "source": "iana"
    },
    "video/vnd.dece.hd": {
        "source": "iana",
        "extensions": [
            "uvh",
            "uvvh"
        ]
    },
    "video/vnd.dece.mobile": {
        "source": "iana",
        "extensions": [
            "uvm",
            "uvvm"
        ]
    },
    "video/vnd.dece.mp4": {
        "source": "iana"
    },
    "video/vnd.dece.pd": {
        "source": "iana",
        "extensions": [
            "uvp",
            "uvvp"
        ]
    },
    "video/vnd.dece.sd": {
        "source": "iana",
        "extensions": [
            "uvs",
            "uvvs"
        ]
    },
    "video/vnd.dece.video": {
        "source": "iana",
        "extensions": [
            "uvv",
            "uvvv"
        ]
    },
    "video/vnd.directv.mpeg": {
        "source": "iana"
    },
    "video/vnd.directv.mpeg-tts": {
        "source": "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
        "source": "iana"
    },
    "video/vnd.dvb.file": {
        "source": "iana",
        "extensions": [
            "dvb"
        ]
    },
    "video/vnd.fvt": {
        "source": "iana",
        "extensions": [
            "fvt"
        ]
    },
    "video/vnd.hns.video": {
        "source": "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
        "source": "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
        "source": "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
        "source": "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
        "source": "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
        "source": "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
        "source": "iana"
    },
    "video/vnd.motorola.video": {
        "source": "iana"
    },
    "video/vnd.motorola.videop": {
        "source": "iana"
    },
    "video/vnd.mpegurl": {
        "source": "iana",
        "extensions": [
            "mxu",
            "m4u"
        ]
    },
    "video/vnd.ms-playready.media.pyv": {
        "source": "iana",
        "extensions": [
            "pyv"
        ]
    },
    "video/vnd.nokia.interleaved-multimedia": {
        "source": "iana"
    },
    "video/vnd.nokia.mp4vr": {
        "source": "iana"
    },
    "video/vnd.nokia.videovoip": {
        "source": "iana"
    },
    "video/vnd.objectvideo": {
        "source": "iana"
    },
    "video/vnd.radgamettools.bink": {
        "source": "iana"
    },
    "video/vnd.radgamettools.smacker": {
        "source": "iana"
    },
    "video/vnd.sealed.mpeg1": {
        "source": "iana"
    },
    "video/vnd.sealed.mpeg4": {
        "source": "iana"
    },
    "video/vnd.sealed.swf": {
        "source": "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
        "source": "iana"
    },
    "video/vnd.uvvu.mp4": {
        "source": "iana",
        "extensions": [
            "uvu",
            "uvvu"
        ]
    },
    "video/vnd.vivo": {
        "source": "iana",
        "extensions": [
            "viv"
        ]
    },
    "video/vnd.youtube.yt": {
        "source": "iana"
    },
    "video/vp8": {
        "source": "iana"
    },
    "video/vp9": {
        "source": "iana"
    },
    "video/webm": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "webm"
        ]
    },
    "video/x-f4v": {
        "source": "apache",
        "extensions": [
            "f4v"
        ]
    },
    "video/x-fli": {
        "source": "apache",
        "extensions": [
            "fli"
        ]
    },
    "video/x-flv": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "flv"
        ]
    },
    "video/x-m4v": {
        "source": "apache",
        "extensions": [
            "m4v"
        ]
    },
    "video/x-matroska": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "mkv",
            "mk3d",
            "mks"
        ]
    },
    "video/x-mng": {
        "source": "apache",
        "extensions": [
            "mng"
        ]
    },
    "video/x-ms-asf": {
        "source": "apache",
        "extensions": [
            "asf",
            "asx"
        ]
    },
    "video/x-ms-vob": {
        "source": "apache",
        "extensions": [
            "vob"
        ]
    },
    "video/x-ms-wm": {
        "source": "apache",
        "extensions": [
            "wm"
        ]
    },
    "video/x-ms-wmv": {
        "source": "apache",
        "compressible": false,
        "extensions": [
            "wmv"
        ]
    },
    "video/x-ms-wmx": {
        "source": "apache",
        "extensions": [
            "wmx"
        ]
    },
    "video/x-ms-wvx": {
        "source": "apache",
        "extensions": [
            "wvx"
        ]
    },
    "video/x-msvideo": {
        "source": "apache",
        "extensions": [
            "avi"
        ]
    },
    "video/x-sgi-movie": {
        "source": "apache",
        "extensions": [
            "movie"
        ]
    },
    "video/x-smv": {
        "source": "apache",
        "extensions": [
            "smv"
        ]
    },
    "x-conference/x-cooltalk": {
        "source": "apache",
        "extensions": [
            "ice"
        ]
    },
    "x-shader/x-fragment": {
        "compressible": true
    },
    "x-shader/x-vertex": {
        "compressible": true
    }
};
function consumeToken(v3) {
    const notPos = indexOf(v3, isNotTokenChar);
    if (notPos == -1) {
        return [
            v3,
            ""
        ];
    }
    if (notPos == 0) {
        return [
            "",
            v3
        ];
    }
    return [
        v3.slice(0, notPos),
        v3.slice(notPos)
    ];
}
function consumeValue(v4) {
    if (!v4) {
        return [
            "",
            v4
        ];
    }
    if (v4[0] !== `"`) {
        return consumeToken(v4);
    }
    let value20 = "";
    for(let i47 = 1; i47 < v4.length; i47++){
        const r8 = v4[i47];
        if (r8 === `"`) {
            return [
                value20,
                v4.slice(i47 + 1)
            ];
        }
        if (r8 === "\\" && i47 + 1 < v4.length && isTSpecial(v4[i47 + 1])) {
            value20 += v4[i47 + 1];
            i47++;
            continue;
        }
        if (r8 === "\r" || r8 === "\n") {
            return [
                "",
                v4
            ];
        }
        value20 += v4[i47];
    }
    return [
        "",
        v4
    ];
}
function consumeMediaParam(v5) {
    let rest = v5.trimStart();
    if (!rest.startsWith(";")) {
        return [
            "",
            "",
            v5
        ];
    }
    rest = rest.slice(1);
    rest = rest.trimStart();
    let param;
    [param, rest] = consumeToken(rest);
    param = param.toLowerCase();
    if (!param) {
        return [
            "",
            "",
            v5
        ];
    }
    rest = rest.slice(1);
    rest = rest.trimStart();
    const [value21, rest2] = consumeValue(rest);
    if (value21 == "" && rest2 === rest) {
        return [
            "",
            "",
            v5
        ];
    }
    rest = rest2;
    return [
        param,
        value21,
        rest
    ];
}
function decode2331Encoding(v6) {
    const sv = v6.split(`'`, 3);
    if (sv.length !== 3) {
        return undefined;
    }
    const charset = sv[0].toLowerCase();
    if (!charset) {
        return undefined;
    }
    if (charset != "us-ascii" && charset != "utf-8") {
        return undefined;
    }
    const encv = decodeURI(sv[2]);
    if (!encv) {
        return undefined;
    }
    return encv;
}
function indexOf(s11, fn) {
    let i48 = -1;
    for (const v7 of s11){
        i48++;
        if (fn(v7)) {
            return i48;
        }
    }
    return -1;
}
function isIterator(obj) {
    if (obj == null) {
        return false;
    }
    return typeof obj[Symbol.iterator] === "function";
}
function isToken(s12) {
    if (!s12) {
        return false;
    }
    return indexOf(s12, isNotTokenChar) < 0;
}
function isNotTokenChar(r9) {
    return !isTokenChar(r9);
}
function isTokenChar(r10) {
    const code18 = r10.charCodeAt(0);
    return code18 > 0x20 && code18 < 0x7f && !isTSpecial(r10);
}
function isTSpecial(r11) {
    return `()<>@,;:\\"/[]?=`.includes(r11[0]);
}
const CHAR_CODE_SPACE = " ".charCodeAt(0);
const CHAR_CODE_TILDE = "~".charCodeAt(0);
function needsEncoding(s13) {
    for (const b12 of s13){
        const charCode = b12.charCodeAt(0);
        if ((charCode < CHAR_CODE_SPACE || charCode > CHAR_CODE_TILDE) && b12 !== "\t") {
            return true;
        }
    }
    return false;
}
const extensions = new Map();
const types = new Map();
(function populateMaps() {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type of Object.keys(__default)){
        const mime = __default[type];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions.set(type, exts);
        for (const ext of exts){
            const current = types.get(ext);
            if (current) {
                const from = preference.indexOf(__default[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from > to || from === to && current.startsWith("application/"))) {
                    continue;
                }
            }
            types.set(ext, type);
        }
    }
})();
function contentType(extensionOrType) {
    try {
        const [mediaType, params = {}] = extensionOrType.includes("/") ? parseMediaType1(extensionOrType) : [
            typeByExtension(extensionOrType),
            undefined
        ];
        if (!mediaType) {
            return undefined;
        }
        if (!("charset" in params)) {
            const charset = getCharset(mediaType);
            if (charset) {
                params.charset = charset;
            }
        }
        return formatMediaType(mediaType, params);
    } catch  {}
    return undefined;
}
function extension(type) {
    const exts = extensionsByType(type);
    if (exts) {
        return exts[0];
    }
    return undefined;
}
function extensionsByType(type) {
    try {
        const [mediaType] = parseMediaType1(type);
        return extensions.get(mediaType);
    } catch  {}
}
function formatMediaType(type, param) {
    let b13 = "";
    const [major, sub] = type.split("/");
    if (!sub) {
        if (!isToken(type)) {
            return "";
        }
        b13 += type.toLowerCase();
    } else {
        if (!isToken(major) || !isToken(sub)) {
            return "";
        }
        b13 += `${major.toLowerCase()}/${sub.toLowerCase()}`;
    }
    if (param) {
        param = isIterator(param) ? Object.fromEntries(param) : param;
        const attrs = Object.keys(param);
        attrs.sort();
        for (const attribute of attrs){
            if (!isToken(attribute)) {
                return "";
            }
            const value22 = param[attribute];
            b13 += `; ${attribute.toLowerCase()}`;
            const needEnc = needsEncoding(value22);
            if (needEnc) {
                b13 += "*";
            }
            b13 += "=";
            if (needEnc) {
                b13 += `utf-8''${encodeURIComponent(value22)}`;
                continue;
            }
            if (isToken(value22)) {
                b13 += value22;
                continue;
            }
            b13 += `"${value22.replace(/["\\]/gi, (m6)=>`\\${m6}`)}"`;
        }
    }
    return b13;
}
function getCharset(type) {
    try {
        const [mediaType, params] = parseMediaType1(type);
        if (params && params["charset"]) {
            return params["charset"];
        }
        const entry = __default[mediaType];
        if (entry && entry.charset) {
            return entry.charset;
        }
        if (mediaType.startsWith("text/")) {
            return "UTF-8";
        }
    } catch  {}
    return undefined;
}
function parseMediaType1(v8) {
    const [base] = v8.split(";");
    const mediaType = base.toLowerCase().trim();
    const params = {};
    const continuation = new Map();
    v8 = v8.slice(base.length);
    while(v8.length){
        v8 = v8.trimStart();
        if (v8.length === 0) {
            break;
        }
        const [key30, value23, rest] = consumeMediaParam(v8);
        if (!key30) {
            if (rest.trim() === ";") {
                break;
            }
            throw new TypeError("Invalid media parameter.");
        }
        let pmap = params;
        const [baseName, rest2] = key30.split("*");
        if (baseName && rest2 != null) {
            if (!continuation.has(baseName)) {
                continuation.set(baseName, {});
            }
            pmap = continuation.get(baseName);
        }
        if (key30 in pmap) {
            throw new TypeError("Duplicate key parsed.");
        }
        pmap[key30] = value23;
        v8 = rest;
    }
    let str13 = "";
    for (const [key31, pieceMap] of continuation){
        const singlePartKey = `${key31}*`;
        const v9 = pieceMap[singlePartKey];
        if (v9) {
            const decv = decode2331Encoding(v9);
            if (decv) {
                params[key31] = decv;
            }
            continue;
        }
        str13 = "";
        let valid = false;
        for(let n10 = 0;; n10++){
            const simplePart = `${key31}*${n10}`;
            let v10 = pieceMap[simplePart];
            if (v10) {
                valid = true;
                str13 += v10;
                continue;
            }
            const encodedPart = `${simplePart}*`;
            v10 = pieceMap[encodedPart];
            if (!v10) {
                break;
            }
            valid = true;
            if (n10 === 0) {
                const decv = decode2331Encoding(v10);
                if (decv) {
                    str13 += decv;
                }
            } else {
                const decv = decodeURI(v10);
                str13 += decv;
            }
        }
        if (valid) {
            params[key31] = str13;
        }
    }
    return Object.keys(params).length ? [
        mediaType,
        params
    ] : [
        mediaType,
        undefined
    ];
}
function typeByExtension(extension1) {
    extension1 = extension1.startsWith(".") ? extension1.slice(1) : extension1;
    return types.get(extension1.toLowerCase());
}
function readerFromStreamReader(streamReader) {
    const buffer = new Buffer();
    return {
        async read (p20) {
            if (buffer.empty()) {
                const res = await streamReader.read();
                if (res.done) {
                    return null;
                }
                await writeAll(buffer, res.value);
            }
            return buffer.read(p20);
        }
    };
}
async function readAll(r12) {
    const buf = new Buffer();
    await buf.readFrom(r12);
    return buf.bytes();
}
async function writeAll(w5, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w5.write(arr.subarray(nwritten));
    }
}
const osType1 = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path35) {
    if (typeof path35 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path35)}`);
    }
}
function isPosixPathSeparator1(code19) {
    return code19 === 47;
}
function isPathSeparator1(code20) {
    return isPosixPathSeparator1(code20) || code20 === 92;
}
function isWindowsDeviceRoot1(code21) {
    return code21 >= 97 && code21 <= 122 || code21 >= 65 && code21 <= 90;
}
function normalizeString1(path36, allowAboveRoot, separator, isPathSeparator11) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code22;
    for(let i49 = 0, len1 = path36.length; i49 <= len1; ++i49){
        if (i49 < len1) code22 = path36.charCodeAt(i49);
        else if (isPathSeparator11(code22)) break;
        else code22 = CHAR_FORWARD_SLASH1;
        if (isPathSeparator11(code22)) {
            if (lastSlash === i49 - 1 || dots === 1) {} else if (lastSlash !== i49 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i49;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i49;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path36.slice(lastSlash + 1, i49);
                else res = path36.slice(lastSlash + 1, i49);
                lastSegmentLength = i49 - lastSlash - 1;
            }
            lastSlash = i49;
            dots = 0;
        } else if (code22 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep9, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep9 + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c10)=>{
        return WHITESPACE_ENCODINGS1[c10] ?? c10;
    });
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i50 = pathSegments.length - 1; i50 >= -1; i50--){
        let path37;
        const { Deno  } = globalThis;
        if (i50 >= 0) {
            path37 = pathSegments[i50];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path37 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path37 = Deno.cwd();
            if (path37 === undefined || path37.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path37 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path37);
        const len2 = path37.length;
        if (len2 === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute11 = false;
        const code23 = path37.charCodeAt(0);
        if (len2 > 1) {
            if (isPathSeparator1(code23)) {
                isAbsolute11 = true;
                if (isPathSeparator1(path37.charCodeAt(1))) {
                    let j9 = 2;
                    let last = j9;
                    for(; j9 < len2; ++j9){
                        if (isPathSeparator1(path37.charCodeAt(j9))) break;
                    }
                    if (j9 < len2 && j9 !== last) {
                        const firstPart = path37.slice(last, j9);
                        last = j9;
                        for(; j9 < len2; ++j9){
                            if (!isPathSeparator1(path37.charCodeAt(j9))) break;
                        }
                        if (j9 < len2 && j9 !== last) {
                            last = j9;
                            for(; j9 < len2; ++j9){
                                if (isPathSeparator1(path37.charCodeAt(j9))) break;
                            }
                            if (j9 === len2) {
                                device = `\\\\${firstPart}\\${path37.slice(last)}`;
                                rootEnd = j9;
                            } else if (j9 !== last) {
                                device = `\\\\${firstPart}\\${path37.slice(last, j9)}`;
                                rootEnd = j9;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code23)) {
                if (path37.charCodeAt(1) === 58) {
                    device = path37.slice(0, 2);
                    rootEnd = 2;
                    if (len2 > 2) {
                        if (isPathSeparator1(path37.charCodeAt(2))) {
                            isAbsolute11 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code23)) {
            rootEnd = 1;
            isAbsolute11 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path37.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute11;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path38) {
    assertPath1(path38);
    const len3 = path38.length;
    if (len3 === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute21 = false;
    const code24 = path38.charCodeAt(0);
    if (len3 > 1) {
        if (isPathSeparator1(code24)) {
            isAbsolute21 = true;
            if (isPathSeparator1(path38.charCodeAt(1))) {
                let j10 = 2;
                let last = j10;
                for(; j10 < len3; ++j10){
                    if (isPathSeparator1(path38.charCodeAt(j10))) break;
                }
                if (j10 < len3 && j10 !== last) {
                    const firstPart = path38.slice(last, j10);
                    last = j10;
                    for(; j10 < len3; ++j10){
                        if (!isPathSeparator1(path38.charCodeAt(j10))) break;
                    }
                    if (j10 < len3 && j10 !== last) {
                        last = j10;
                        for(; j10 < len3; ++j10){
                            if (isPathSeparator1(path38.charCodeAt(j10))) break;
                        }
                        if (j10 === len3) {
                            return `\\\\${firstPart}\\${path38.slice(last)}\\`;
                        } else if (j10 !== last) {
                            device = `\\\\${firstPart}\\${path38.slice(last, j10)}`;
                            rootEnd = j10;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code24)) {
            if (path38.charCodeAt(1) === 58) {
                device = path38.slice(0, 2);
                rootEnd = 2;
                if (len3 > 2) {
                    if (isPathSeparator1(path38.charCodeAt(2))) {
                        isAbsolute21 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code24)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len3) {
        tail = normalizeString1(path38.slice(rootEnd), !isAbsolute21, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute21) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path38.charCodeAt(len3 - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute21) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute21) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path39) {
    assertPath1(path39);
    const len4 = path39.length;
    if (len4 === 0) return false;
    const code25 = path39.charCodeAt(0);
    if (isPathSeparator1(code25)) {
        return true;
    } else if (isWindowsDeviceRoot1(code25)) {
        if (len4 > 2 && path39.charCodeAt(1) === 58) {
            if (isPathSeparator1(path39.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join4(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i51 = 0; i51 < pathsCount; ++i51){
        const path40 = paths[i51];
        assertPath1(path40);
        if (path40.length > 0) {
            if (joined === undefined) joined = firstPart = path40;
            else joined += `\\${path40}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert3(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i52 = 0;
    for(; i52 <= length; ++i52){
        if (i52 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i52) === 92) {
                    return toOrig.slice(toStart + i52 + 1);
                } else if (i52 === 2) {
                    return toOrig.slice(toStart + i52);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i52) === 92) {
                    lastCommonSep = i52;
                } else if (i52 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i52);
        const toCode = to.charCodeAt(toStart + i52);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i52;
    }
    if (i52 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i52 = fromStart + lastCommonSep + 1; i52 <= fromEnd; ++i52){
        if (i52 === fromEnd || from.charCodeAt(i52) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path41) {
    if (typeof path41 !== "string") return path41;
    if (path41.length === 0) return "";
    const resolvedPath = resolve3(path41);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code26 = resolvedPath.charCodeAt(2);
                if (code26 !== 63 && code26 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path41;
}
function dirname3(path42) {
    assertPath1(path42);
    const len5 = path42.length;
    if (len5 === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code27 = path42.charCodeAt(0);
    if (len5 > 1) {
        if (isPathSeparator1(code27)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path42.charCodeAt(1))) {
                let j11 = 2;
                let last = j11;
                for(; j11 < len5; ++j11){
                    if (isPathSeparator1(path42.charCodeAt(j11))) break;
                }
                if (j11 < len5 && j11 !== last) {
                    last = j11;
                    for(; j11 < len5; ++j11){
                        if (!isPathSeparator1(path42.charCodeAt(j11))) break;
                    }
                    if (j11 < len5 && j11 !== last) {
                        last = j11;
                        for(; j11 < len5; ++j11){
                            if (isPathSeparator1(path42.charCodeAt(j11))) break;
                        }
                        if (j11 === len5) {
                            return path42;
                        }
                        if (j11 !== last) {
                            rootEnd = offset = j11 + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code27)) {
            if (path42.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len5 > 2) {
                    if (isPathSeparator1(path42.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code27)) {
        return path42;
    }
    for(let i53 = len5 - 1; i53 >= offset; --i53){
        if (isPathSeparator1(path42.charCodeAt(i53))) {
            if (!matchedSlash) {
                end = i53;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path42.slice(0, end);
}
function basename3(path43, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path43);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i54;
    if (path43.length >= 2) {
        const drive = path43.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path43.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path43.length) {
        if (ext.length === path43.length && ext === path43) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i54 = path43.length - 1; i54 >= start; --i54){
            const code28 = path43.charCodeAt(i54);
            if (isPathSeparator1(code28)) {
                if (!matchedSlash) {
                    start = i54 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i54 + 1;
                }
                if (extIdx >= 0) {
                    if (code28 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i54;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path43.length;
        return path43.slice(start, end);
    } else {
        for(i54 = path43.length - 1; i54 >= start; --i54){
            if (isPathSeparator1(path43.charCodeAt(i54))) {
                if (!matchedSlash) {
                    start = i54 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i54 + 1;
            }
        }
        if (end === -1) return "";
        return path43.slice(start, end);
    }
}
function extname3(path44) {
    assertPath1(path44);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path44.length >= 2 && path44.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path44.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i55 = path44.length - 1; i55 >= start; --i55){
        const code29 = path44.charCodeAt(i55);
        if (isPathSeparator1(code29)) {
            if (!matchedSlash) {
                startPart = i55 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i55 + 1;
        }
        if (code29 === 46) {
            if (startDot === -1) startDot = i55;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path44.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse4(path45) {
    assertPath1(path45);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len6 = path45.length;
    if (len6 === 0) return ret;
    let rootEnd = 0;
    let code30 = path45.charCodeAt(0);
    if (len6 > 1) {
        if (isPathSeparator1(code30)) {
            rootEnd = 1;
            if (isPathSeparator1(path45.charCodeAt(1))) {
                let j12 = 2;
                let last = j12;
                for(; j12 < len6; ++j12){
                    if (isPathSeparator1(path45.charCodeAt(j12))) break;
                }
                if (j12 < len6 && j12 !== last) {
                    last = j12;
                    for(; j12 < len6; ++j12){
                        if (!isPathSeparator1(path45.charCodeAt(j12))) break;
                    }
                    if (j12 < len6 && j12 !== last) {
                        last = j12;
                        for(; j12 < len6; ++j12){
                            if (isPathSeparator1(path45.charCodeAt(j12))) break;
                        }
                        if (j12 === len6) {
                            rootEnd = j12;
                        } else if (j12 !== last) {
                            rootEnd = j12 + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code30)) {
            if (path45.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len6 > 2) {
                    if (isPathSeparator1(path45.charCodeAt(2))) {
                        if (len6 === 3) {
                            ret.root = ret.dir = path45;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path45;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code30)) {
        ret.root = ret.dir = path45;
        return ret;
    }
    if (rootEnd > 0) ret.root = path45.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i56 = path45.length - 1;
    let preDotState = 0;
    for(; i56 >= rootEnd; --i56){
        code30 = path45.charCodeAt(i56);
        if (isPathSeparator1(code30)) {
            if (!matchedSlash) {
                startPart = i56 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i56 + 1;
        }
        if (code30 === 46) {
            if (startDot === -1) startDot = i56;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path45.slice(startPart, end);
        }
    } else {
        ret.name = path45.slice(startPart, startDot);
        ret.base = path45.slice(startPart, end);
        ret.ext = path45.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path45.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path46 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path46 = `\\\\${url.hostname}${path46}`;
    }
    return path46;
}
function toFileUrl3(path47) {
    if (!isAbsolute3(path47)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname2, pathname] = path47.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname2 != null && hostname2 != "localhost") {
        url.hostname = hostname2;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod7 = {
    sep: sep3,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join4,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format4,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i57 = pathSegments.length - 1; i57 >= -1 && !resolvedAbsolute; i57--){
        let path48;
        if (i57 >= 0) path48 = pathSegments[i57];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path48 = Deno.cwd();
        }
        assertPath1(path48);
        if (path48.length === 0) {
            continue;
        }
        resolvedPath = `${path48}/${resolvedPath}`;
        resolvedAbsolute = path48.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path49) {
    assertPath1(path49);
    if (path49.length === 0) return ".";
    const isAbsolute12 = path49.charCodeAt(0) === 47;
    const trailingSeparator = path49.charCodeAt(path49.length - 1) === 47;
    path49 = normalizeString1(path49, !isAbsolute12, "/", isPosixPathSeparator1);
    if (path49.length === 0 && !isAbsolute12) path49 = ".";
    if (path49.length > 0 && trailingSeparator) path49 += "/";
    if (isAbsolute12) return `/${path49}`;
    return path49;
}
function isAbsolute4(path50) {
    assertPath1(path50);
    return path50.length > 0 && path50.charCodeAt(0) === 47;
}
function join5(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i58 = 0, len7 = paths.length; i58 < len7; ++i58){
        const path51 = paths[i58];
        assertPath1(path51);
        if (path51.length > 0) {
            if (!joined) joined = path51;
            else joined += `/${path51}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i59 = 0;
    for(; i59 <= length; ++i59){
        if (i59 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i59) === 47) {
                    return to.slice(toStart + i59 + 1);
                } else if (i59 === 0) {
                    return to.slice(toStart + i59);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i59) === 47) {
                    lastCommonSep = i59;
                } else if (i59 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i59);
        const toCode = to.charCodeAt(toStart + i59);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i59;
    }
    let out = "";
    for(i59 = fromStart + lastCommonSep + 1; i59 <= fromEnd; ++i59){
        if (i59 === fromEnd || from.charCodeAt(i59) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path52) {
    return path52;
}
function dirname4(path53) {
    assertPath1(path53);
    if (path53.length === 0) return ".";
    const hasRoot = path53.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i60 = path53.length - 1; i60 >= 1; --i60){
        if (path53.charCodeAt(i60) === 47) {
            if (!matchedSlash) {
                end = i60;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path53.slice(0, end);
}
function basename4(path54, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path54);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i61;
    if (ext !== undefined && ext.length > 0 && ext.length <= path54.length) {
        if (ext.length === path54.length && ext === path54) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i61 = path54.length - 1; i61 >= 0; --i61){
            const code31 = path54.charCodeAt(i61);
            if (code31 === 47) {
                if (!matchedSlash) {
                    start = i61 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i61 + 1;
                }
                if (extIdx >= 0) {
                    if (code31 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i61;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path54.length;
        return path54.slice(start, end);
    } else {
        for(i61 = path54.length - 1; i61 >= 0; --i61){
            if (path54.charCodeAt(i61) === 47) {
                if (!matchedSlash) {
                    start = i61 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i61 + 1;
            }
        }
        if (end === -1) return "";
        return path54.slice(start, end);
    }
}
function extname4(path55) {
    assertPath1(path55);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i62 = path55.length - 1; i62 >= 0; --i62){
        const code32 = path55.charCodeAt(i62);
        if (code32 === 47) {
            if (!matchedSlash) {
                startPart = i62 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i62 + 1;
        }
        if (code32 === 46) {
            if (startDot === -1) startDot = i62;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path55.slice(startDot, end);
}
function format5(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse5(path56) {
    assertPath1(path56);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path56.length === 0) return ret;
    const isAbsolute22 = path56.charCodeAt(0) === 47;
    let start;
    if (isAbsolute22) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i63 = path56.length - 1;
    let preDotState = 0;
    for(; i63 >= start; --i63){
        const code33 = path56.charCodeAt(i63);
        if (code33 === 47) {
            if (!matchedSlash) {
                startPart = i63 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i63 + 1;
        }
        if (code33 === 46) {
            if (startDot === -1) startDot = i63;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute22) {
                ret.base = ret.name = path56.slice(1, end);
            } else {
                ret.base = ret.name = path56.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute22) {
            ret.name = path56.slice(1, startDot);
            ret.base = path56.slice(1, end);
        } else {
            ret.name = path56.slice(startPart, startDot);
            ret.base = path56.slice(startPart, end);
        }
        ret.ext = path56.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path56.slice(0, startPart - 1);
    else if (isAbsolute22) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path57) {
    if (!isAbsolute4(path57)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path57.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod8 = {
    sep: sep4,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join5,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format5,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path2 = isWindows1 ? mod7 : mod8;
const { join: join6 , normalize: normalize6  } = path2;
const path3 = isWindows1 ? mod7 : mod8;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format6 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join7 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
function lexer(str14) {
    const tokens = [];
    let i64 = 0;
    while(i64 < str14.length){
        const __char = str14[i64];
        if (__char === "*" || __char === "+" || __char === "?") {
            tokens.push({
                type: "MODIFIER",
                index: i64,
                value: str14[i64++]
            });
            continue;
        }
        if (__char === "\\") {
            tokens.push({
                type: "ESCAPED_CHAR",
                index: i64++,
                value: str14[i64++]
            });
            continue;
        }
        if (__char === "{") {
            tokens.push({
                type: "OPEN",
                index: i64,
                value: str14[i64++]
            });
            continue;
        }
        if (__char === "}") {
            tokens.push({
                type: "CLOSE",
                index: i64,
                value: str14[i64++]
            });
            continue;
        }
        if (__char === ":") {
            let name = "";
            let j13 = i64 + 1;
            while(j13 < str14.length){
                const code34 = str14.charCodeAt(j13);
                if (code34 >= 48 && code34 <= 57 || code34 >= 65 && code34 <= 90 || code34 >= 97 && code34 <= 122 || code34 === 95) {
                    name += str14[j13++];
                    continue;
                }
                break;
            }
            if (!name) throw new TypeError(`Missing parameter name at ${i64}`);
            tokens.push({
                type: "NAME",
                index: i64,
                value: name
            });
            i64 = j13;
            continue;
        }
        if (__char === "(") {
            let count = 1;
            let pattern = "";
            let j14 = i64 + 1;
            if (str14[j14] === "?") {
                throw new TypeError(`Pattern cannot start with "?" at ${j14}`);
            }
            while(j14 < str14.length){
                if (str14[j14] === "\\") {
                    pattern += str14[j14++] + str14[j14++];
                    continue;
                }
                if (str14[j14] === ")") {
                    count--;
                    if (count === 0) {
                        j14++;
                        break;
                    }
                } else if (str14[j14] === "(") {
                    count++;
                    if (str14[j14 + 1] !== "?") {
                        throw new TypeError(`Capturing groups are not allowed at ${j14}`);
                    }
                }
                pattern += str14[j14++];
            }
            if (count) throw new TypeError(`Unbalanced pattern at ${i64}`);
            if (!pattern) throw new TypeError(`Missing pattern at ${i64}`);
            tokens.push({
                type: "PATTERN",
                index: i64,
                value: pattern
            });
            i64 = j14;
            continue;
        }
        tokens.push({
            type: "CHAR",
            index: i64,
            value: str14[i64++]
        });
    }
    tokens.push({
        type: "END",
        index: i64,
        value: ""
    });
    return tokens;
}
function parse7(str15, options = {}) {
    const tokens = lexer(str15);
    const { prefixes ="./"  } = options;
    const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
    const result1 = [];
    let key32 = 0;
    let i65 = 0;
    let path58 = "";
    const tryConsume = (type)=>{
        if (i65 < tokens.length && tokens[i65].type === type) return tokens[i65++].value;
    };
    const mustConsume = (type)=>{
        const value24 = tryConsume(type);
        if (value24 !== undefined) return value24;
        const { type: nextType , index  } = tokens[i65];
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
    };
    const consumeText = ()=>{
        let result = "";
        let value25;
        while(value25 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")){
            result += value25;
        }
        return result;
    };
    while(i65 < tokens.length){
        const __char = tryConsume("CHAR");
        const name = tryConsume("NAME");
        const pattern = tryConsume("PATTERN");
        if (name || pattern) {
            let prefix = __char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path58 += prefix;
                prefix = "";
            }
            if (path58) {
                result1.push(path58);
                path58 = "";
            }
            result1.push({
                name: name || key32++,
                prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        const value26 = __char || tryConsume("ESCAPED_CHAR");
        if (value26) {
            path58 += value26;
            continue;
        }
        if (path58) {
            result1.push(path58);
            path58 = "";
        }
        const open = tryConsume("OPEN");
        if (open) {
            const prefix = consumeText();
            const name = tryConsume("NAME") || "";
            const pattern = tryConsume("PATTERN") || "";
            const suffix = consumeText();
            mustConsume("CLOSE");
            result1.push({
                name: name || (pattern ? key32++ : ""),
                pattern: name && !pattern ? defaultPattern : pattern,
                prefix,
                suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result1;
}
function compile(str16, options) {
    return tokensToFunction(parse7(str16, options), options);
}
function tokensToFunction(tokens, options = {}) {
    const reFlags = flags(options);
    const { encode: encode5 = (x8)=>x8 , validate: validate1 = true  } = options;
    const matches = tokens.map((token)=>{
        if (typeof token === "object") {
            return new RegExp(`^(?:${token.pattern})$`, reFlags);
        }
    });
    return (data)=>{
        let path59 = "";
        for(let i66 = 0; i66 < tokens.length; i66++){
            const token = tokens[i66];
            if (typeof token === "string") {
                path59 += token;
                continue;
            }
            const value27 = data ? data[token.name] : undefined;
            const optional = token.modifier === "?" || token.modifier === "*";
            const repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value27)) {
                if (!repeat) {
                    throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                }
                if (value27.length === 0) {
                    if (optional) continue;
                    throw new TypeError(`Expected "${token.name}" to not be empty`);
                }
                for(let j15 = 0; j15 < value27.length; j15++){
                    const segment = encode5(value27[j15], token);
                    if (validate1 && !matches[i66].test(segment)) {
                        throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path59 += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value27 === "string" || typeof value27 === "number") {
                const segment = encode5(String(value27), token);
                if (validate1 && !matches[i66].test(segment)) {
                    throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                }
                path59 += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional) continue;
            const typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
        }
        return path59;
    };
}
function escapeString(str17) {
    return str17.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path60, keys) {
    if (!keys) return path60;
    const groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    let index = 0;
    let execResult = groupsRegex.exec(path60.source);
    while(execResult){
        keys.push({
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        });
        execResult = groupsRegex.exec(path60.source);
    }
    return path60;
}
function arrayToRegexp(paths, keys, options) {
    const parts1 = paths.map((path61)=>pathToRegexp(path61, keys, options).source);
    return new RegExp(`(?:${parts1.join("|")})`, flags(options));
}
function stringToRegexp(path62, keys, options) {
    return tokensToRegexp(parse7(path62, options), keys, options);
}
function tokensToRegexp(tokens, keys, options = {}) {
    const { strict =false , start =true , end =true , encode: encode6 = (x9)=>x9 , delimiter: delimiter6 = "/#?" , endsWith ="" ,  } = options;
    const endsWithRe = `[${escapeString(endsWith)}]|$`;
    const delimiterRe = `[${escapeString(delimiter6)}]`;
    let route = start ? "^" : "";
    for (const token of tokens){
        if (typeof token === "string") {
            route += escapeString(encode6(token));
        } else {
            const prefix = escapeString(encode6(token.prefix));
            const suffix = escapeString(encode6(token.suffix));
            if (token.pattern) {
                if (keys) keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        const mod18 = token.modifier === "*" ? "?" : "";
                        route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod18}`;
                    } else {
                        route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                    }
                } else {
                    if (token.modifier === "+" || token.modifier === "*") {
                        route += `((?:${token.pattern})${token.modifier})`;
                    } else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
            } else {
                route += `(?:${prefix}${suffix})${token.modifier}`;
            }
        }
    }
    if (end) {
        if (!strict) route += `${delimiterRe}?`;
        route += !options.endsWith ? "$" : `(?=${endsWithRe})`;
    } else {
        const endToken = tokens[tokens.length - 1];
        const isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === undefined;
        if (!strict) {
            route += `(?:${delimiterRe}(?=${endsWithRe}))?`;
        }
        if (!isEndDelimited) {
            route += `(?=${delimiterRe}|${endsWithRe})`;
        }
    }
    return new RegExp(route, flags(options));
}
function pathToRegexp(path63, keys, options) {
    if (path63 instanceof RegExp) return regexpToRegexp(path63, keys);
    if (Array.isArray(path63)) return arrayToRegexp(path63, keys, options);
    return stringToRegexp(path63, keys, options);
}
const SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
const TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
const TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
class MediaType {
    constructor(type, subtype, suffix){
        this.type = type;
        this.subtype = subtype;
        this.suffix = suffix;
    }
    type;
    subtype;
    suffix;
}
function format7(obj) {
    const { subtype , suffix , type  } = obj;
    if (!TYPE_NAME_REGEXP.test(type)) {
        throw new TypeError("Invalid type.");
    }
    if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
        throw new TypeError("Invalid subtype.");
    }
    let str18 = `${type}/${subtype}`;
    if (suffix) {
        if (!TYPE_NAME_REGEXP.test(suffix)) {
            throw new TypeError("Invalid suffix.");
        }
        str18 += `+${suffix}`;
    }
    return str18;
}
function parse8(str19) {
    const match = TYPE_REGEXP.exec(str19.toLowerCase());
    if (!match) {
        throw new TypeError("Invalid media type.");
    }
    let [, type, subtype] = match;
    let suffix;
    const idx = subtype.lastIndexOf("+");
    if (idx !== -1) {
        suffix = subtype.substr(idx + 1);
        subtype = subtype.substr(0, idx);
    }
    return new MediaType(type, subtype, suffix);
}
function mimeMatch(expected, actual) {
    if (expected === undefined) {
        return false;
    }
    const actualParts = actual.split("/");
    const expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
    }
    const [actualType, actualSubtype] = actualParts;
    const [expectedType, expectedSubtype] = expectedParts;
    if (expectedType !== "*" && expectedType !== actualType) {
        return false;
    }
    if (expectedSubtype.substr(0, 2) === "*+") {
        return expectedSubtype.length <= actualSubtype.length + 1 && expectedSubtype.substr(1) === actualSubtype.substr(1 - expectedSubtype.length);
    }
    if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
        return false;
    }
    return true;
}
function normalize8(type) {
    if (type === "urlencoded") {
        return "application/x-www-form-urlencoded";
    } else if (type === "multipart") {
        return "multipart/*";
    } else if (type[0] === "+") {
        return `*/*${type}`;
    }
    return type.includes("/") ? type : typeByExtension(type);
}
function normalizeType(value28) {
    try {
        const val = value28.split(";");
        const type = parse8(val[0]);
        return format7(type);
    } catch  {
        return;
    }
}
function isMediaType(value29, types2) {
    const val = normalizeType(value29);
    if (!val) {
        return false;
    }
    if (!types2.length) {
        return val;
    }
    for (const type of types2){
        if (mimeMatch(normalize8(type), val)) {
            return type[0] === "+" || type.includes("*") ? val : type;
        }
    }
    return false;
}
const ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
const HTAB = "\t".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const CR2 = "\r".charCodeAt(0);
const LF2 = "\n".charCodeAt(0);
const UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
const UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
const BODY_TYPES = [
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
];
function assert4(cond, msg20 = "Assertion failed") {
    if (!cond) {
        throw new Error(msg20);
    }
}
function decodeComponent(text) {
    try {
        return decodeURIComponent(text);
    } catch  {
        return text;
    }
}
function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
function bufferToHex(buffer) {
    const arr = Array.from(new Uint8Array(buffer));
    return arr.map((b14)=>b14.toString(16).padStart(2, "0")).join("");
}
async function getRandomFilename(prefix = "", extension2 = "") {
    const buffer = await crypto.subtle.digest("SHA-1", crypto.getRandomValues(new Uint8Array(256)));
    return `${prefix}${bufferToHex(buffer)}${extension2 ? `.${extension2}` : ""}`;
}
async function getBoundary() {
    const buffer = await crypto.subtle.digest("SHA-1", crypto.getRandomValues(new Uint8Array(256)));
    return `oak_${bufferToHex(buffer)}`;
}
function isAsyncIterable(value30) {
    return typeof value30 === "object" && value30 !== null && Symbol.asyncIterator in value30 && typeof value30[Symbol.asyncIterator] === "function";
}
function isRouterContext(value31) {
    return "params" in value31;
}
function isReader(value32) {
    return typeof value32 === "object" && value32 !== null && "read" in value32 && typeof value32.read === "function";
}
function isCloser(value33) {
    return typeof value33 === "object" && value33 != null && "close" in value33 && typeof value33["close"] === "function";
}
function isConn(value34) {
    return typeof value34 === "object" && value34 != null && "rid" in value34 && typeof value34.rid === "number" && "localAddr" in value34 && "remoteAddr" in value34;
}
function isListenTlsOptions(value35) {
    return typeof value35 === "object" && value35 !== null && ("cert" in value35 || "certFile" in value35) && ("key" in value35 || "keyFile" in value35) && "port" in value35;
}
function readableStreamFromAsyncIterable(source) {
    return new ReadableStream({
        async start (controller) {
            for await (const chunk of source){
                if (BODY_TYPES.includes(typeof chunk)) {
                    controller.enqueue(encoder.encode(String(chunk)));
                } else if (chunk instanceof Uint8Array) {
                    controller.enqueue(chunk);
                } else if (ArrayBuffer.isView(chunk)) {
                    controller.enqueue(new Uint8Array(chunk.buffer));
                } else if (chunk instanceof ArrayBuffer) {
                    controller.enqueue(new Uint8Array(chunk));
                } else {
                    try {
                        controller.enqueue(encoder.encode(JSON.stringify(chunk)));
                    } catch  {}
                }
            }
            controller.close();
        }
    });
}
function readableStreamFromReader(reader, options = {}) {
    const { autoClose =true , chunkSize =16_640 , strategy ,  } = options;
    return new ReadableStream({
        async pull (controller) {
            const chunk = new Uint8Array(chunkSize);
            try {
                const read1 = await reader.read(chunk);
                if (read1 === null) {
                    if (isCloser(reader) && autoClose) {
                        reader.close();
                    }
                    controller.close();
                    return;
                }
                controller.enqueue(chunk.subarray(0, read1));
            } catch (e16) {
                controller.error(e16);
                if (isCloser(reader)) {
                    reader.close();
                }
            }
        },
        cancel () {
            if (isCloser(reader) && autoClose) {
                reader.close();
            }
        }
    }, strategy);
}
function isErrorStatus(value36) {
    return [
        Status.BadRequest,
        Status.Unauthorized,
        Status.PaymentRequired,
        Status.Forbidden,
        Status.NotFound,
        Status.MethodNotAllowed,
        Status.NotAcceptable,
        Status.ProxyAuthRequired,
        Status.RequestTimeout,
        Status.Conflict,
        Status.Gone,
        Status.LengthRequired,
        Status.PreconditionFailed,
        Status.RequestEntityTooLarge,
        Status.RequestURITooLong,
        Status.UnsupportedMediaType,
        Status.RequestedRangeNotSatisfiable,
        Status.ExpectationFailed,
        Status.Teapot,
        Status.MisdirectedRequest,
        Status.UnprocessableEntity,
        Status.Locked,
        Status.FailedDependency,
        Status.UpgradeRequired,
        Status.PreconditionRequired,
        Status.TooManyRequests,
        Status.RequestHeaderFieldsTooLarge,
        Status.UnavailableForLegalReasons,
        Status.InternalServerError,
        Status.NotImplemented,
        Status.BadGateway,
        Status.ServiceUnavailable,
        Status.GatewayTimeout,
        Status.HTTPVersionNotSupported,
        Status.VariantAlsoNegotiates,
        Status.InsufficientStorage,
        Status.LoopDetected,
        Status.NotExtended,
        Status.NetworkAuthenticationRequired, 
    ].includes(value36);
}
function isRedirectStatus(value37) {
    return [
        Status.MultipleChoices,
        Status.MovedPermanently,
        Status.Found,
        Status.SeeOther,
        Status.UseProxy,
        Status.TemporaryRedirect,
        Status.PermanentRedirect, 
    ].includes(value37);
}
function isHtml(value38) {
    return /^\s*<(?:!DOCTYPE|html|body)/i.test(value38);
}
function skipLWSPChar(u8) {
    const result = new Uint8Array(u8.length);
    let j16 = 0;
    for(let i67 = 0; i67 < u8.length; i67++){
        if (u8[i67] === SPACE || u8[i67] === HTAB) continue;
        result[j16++] = u8[i67];
    }
    return result.slice(0, j16);
}
function stripEol(value39) {
    if (value39[value39.byteLength - 1] == LF2) {
        let drop = 1;
        if (value39.byteLength > 1 && value39[value39.byteLength - 2] === CR2) {
            drop = 2;
        }
        return value39.subarray(0, value39.byteLength - drop);
    }
    return value39;
}
const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
function resolvePath(rootPath, relativePath) {
    let path64 = relativePath;
    let root = rootPath;
    if (relativePath === undefined) {
        path64 = rootPath;
        root = ".";
    }
    if (path64 == null) {
        throw new TypeError("Argument relativePath is required.");
    }
    if (path64.includes("\0")) {
        throw createHttpError(400, "Malicious Path");
    }
    if (isAbsolute5(path64)) {
        throw createHttpError(400, "Malicious Path");
    }
    if (UP_PATH_REGEXP.test(normalize7("." + sep5 + path64))) {
        throw createHttpError(403);
    }
    return normalize7(join7(root, path64));
}
class Uint8ArrayTransformStream extends TransformStream {
    constructor(){
        const init = {
            async transform (chunk, controller) {
                chunk = await chunk;
                switch(typeof chunk){
                    case "object":
                        if (chunk === null) {
                            controller.terminate();
                        } else if (ArrayBuffer.isView(chunk)) {
                            controller.enqueue(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength));
                        } else if (Array.isArray(chunk) && chunk.every((value40)=>typeof value40 === "number")) {
                            controller.enqueue(new Uint8Array(chunk));
                        } else if (typeof chunk.valueOf === "function" && chunk.valueOf() !== chunk) {
                            this.transform(chunk.valueOf(), controller);
                        } else if ("toJSON" in chunk) {
                            this.transform(JSON.stringify(chunk), controller);
                        }
                        break;
                    case "symbol":
                        controller.error(new TypeError("Cannot transform a symbol to a Uint8Array"));
                        break;
                    case "undefined":
                        controller.error(new TypeError("Cannot transform undefined to a Uint8Array"));
                        break;
                    default:
                        controller.enqueue(this.encoder.encode(String(chunk)));
                }
            },
            encoder: new TextEncoder()
        };
        super(init);
    }
}
const replacements = {
    "/": "_",
    "+": "-",
    "=": ""
};
const encoder = new TextEncoder();
function encodeBase64Safe(data) {
    return mod6.encode(data).replace(/\/|\+|=/g, (c11)=>replacements[c11]);
}
function importKey(key33) {
    if (typeof key33 === "string") {
        key33 = encoder.encode(key33);
    } else if (Array.isArray(key33)) {
        key33 = new Uint8Array(key33);
    }
    return crypto.subtle.importKey("raw", key33, {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, true, [
        "sign",
        "verify"
    ]);
}
function sign(data, key34) {
    if (typeof data === "string") {
        data = encoder.encode(data);
    } else if (Array.isArray(data)) {
        data = Uint8Array.from(data);
    }
    return crypto.subtle.sign("HMAC", key34, data);
}
const MIN_BUF_SIZE2 = 16;
const CR3 = "\r".charCodeAt(0);
const LF3 = "\n".charCodeAt(0);
class BufferFullError2 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class BufReader2 {
    #buffer;
    #reader;
    #posRead = 0;
    #posWrite = 0;
    #eof = false;
    async #fill() {
        if (this.#posRead > 0) {
            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
            this.#posWrite -= this.#posRead;
            this.#posRead = 0;
        }
        if (this.#posWrite >= this.#buffer.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert4(rr >= 0, "negative read");
            this.#posWrite += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
     #reset(buffer, reader) {
        this.#buffer = buffer;
        this.#reader = reader;
        this.#eof = false;
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE2;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    buffered() {
        return this.#posWrite - this.#posRead;
    }
    async readLine(strip = true) {
        let line;
        try {
            line = await this.readSlice(LF3);
        } catch (err) {
            assert4(err instanceof Error);
            let { partial  } = err;
            assert4(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError2)) {
                throw err;
            }
            if (!this.#eof && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR3) {
                assert4(this.#posRead > 0, "Tried to rewind past start of buffer");
                this.#posRead--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            return {
                bytes: partial,
                eol: this.#eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                bytes: line,
                eol: true
            };
        }
        if (strip) {
            line = stripEol(line);
        }
        return {
            bytes: line,
            eol: true
        };
    }
    async readSlice(delim) {
        let s14 = 0;
        let slice;
        while(true){
            let i68 = this.#buffer.subarray(this.#posRead + s14, this.#posWrite).indexOf(delim);
            if (i68 >= 0) {
                i68 += s14;
                slice = this.#buffer.subarray(this.#posRead, this.#posRead + i68 + 1);
                this.#posRead += i68 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#posRead === this.#posWrite) {
                    return null;
                }
                slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                this.#posRead = this.#posWrite;
                break;
            }
            if (this.buffered() >= this.#buffer.byteLength) {
                this.#posRead = this.#posWrite;
                const oldbuf = this.#buffer;
                const newbuf = this.#buffer.slice(0);
                this.#buffer = newbuf;
                throw new BufferFullError2(oldbuf);
            }
            s14 = this.#posWrite - this.#posRead;
            try {
                await this.#fill();
            } catch (err) {
                const e17 = err instanceof Error ? err : new Error("[non-object thrown]");
                e17.partial = slice;
                throw err;
            }
        }
        return slice;
    }
}
const COLON = ":".charCodeAt(0);
const HTAB1 = "\t".charCodeAt(0);
const SPACE1 = " ".charCodeAt(0);
const decoder = new TextDecoder();
function toParamRegExp(attributePattern, flags2) {
    return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` + `(` + `[^";\\s][^;\\s]*` + `|` + `"(?:[^"\\\\]|\\\\"?)+"?` + `)`, flags2);
}
async function readHeaders(body) {
    const headers = {};
    let readResult = await body.readLine();
    while(readResult){
        const { bytes  } = readResult;
        if (!bytes.length) {
            return headers;
        }
        let i69 = bytes.indexOf(COLON);
        if (i69 === -1) {
            throw new errors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
        }
        const key35 = decoder.decode(bytes.subarray(0, i69)).trim().toLowerCase();
        if (key35 === "") {
            throw new errors.BadRequest("Invalid header key.");
        }
        i69++;
        while(i69 < bytes.byteLength && (bytes[i69] === SPACE1 || bytes[i69] === HTAB1)){
            i69++;
        }
        const value41 = decoder.decode(bytes.subarray(i69)).trim();
        headers[key35] = value41;
        readResult = await body.readLine();
    }
    throw new errors.BadRequest("Unexpected end of body reached.");
}
function unquote(value42) {
    if (value42.startsWith(`"`)) {
        const parts2 = value42.slice(1).split(`\\"`);
        for(let i70 = 0; i70 < parts2.length; ++i70){
            const quoteIndex = parts2[i70].indexOf(`"`);
            if (quoteIndex !== -1) {
                parts2[i70] = parts2[i70].slice(0, quoteIndex);
                parts2.length = i70 + 1;
            }
            parts2[i70] = parts2[i70].replace(/\\(.)/g, "$1");
        }
        value42 = parts2.join(`"`);
    }
    return value42;
}
let needsEncodingFixup = false;
function fixupEncoding(value43) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value43)) {
        value43 = textDecode("utf-8", value43);
        if (needsEncodingFixup) {
            value43 = textDecode("iso-8859-1", value43);
        }
    }
    return value43;
}
const FILENAME_STAR_REGEX = toParamRegExp("filename\\*", "i");
const FILENAME_START_ITER_REGEX = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
const FILENAME_REGEX = toParamRegExp("filename", "i");
function rfc2047decode(value44) {
    if (!value44.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value44)) {
        return value44;
    }
    return value44.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text)=>{
        if (encoding === "q" || encoding === "Q") {
            text = text.replace(/_/g, " ");
            text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex)=>String.fromCharCode(parseInt(hex, 16)));
            return textDecode(charset, text);
        }
        try {
            text = atob(text);
        } catch  {}
        return textDecode(charset, text);
    });
}
function rfc2231getParam(header) {
    const matches = [];
    let match;
    while(match = FILENAME_START_ITER_REGEX.exec(header)){
        const [, ns, quote, part] = match;
        const n11 = parseInt(ns, 10);
        if (n11 in matches) {
            if (n11 === 0) {
                break;
            }
            continue;
        }
        matches[n11] = [
            quote,
            part
        ];
    }
    const parts3 = [];
    for(let n12 = 0; n12 < matches.length; ++n12){
        if (!(n12 in matches)) {
            break;
        }
        let [quote, part] = matches[n12];
        part = unquote(part);
        if (quote) {
            part = unescape(part);
            if (n12 === 0) {
                part = rfc5987decode(part);
            }
        }
        parts3.push(part);
    }
    return parts3.join("");
}
function rfc5987decode(value45) {
    const encodingEnd = value45.indexOf(`'`);
    if (encodingEnd === -1) {
        return value45;
    }
    const encoding = value45.slice(0, encodingEnd);
    const langValue = value45.slice(encodingEnd + 1);
    return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
}
function textDecode(encoding, value46) {
    if (encoding) {
        try {
            const decoder5 = new TextDecoder(encoding, {
                fatal: true
            });
            const bytes = Array.from(value46, (c12)=>c12.charCodeAt(0));
            if (bytes.every((code35)=>code35 <= 0xFF)) {
                value46 = decoder5.decode(new Uint8Array(bytes));
                needsEncodingFixup = false;
            }
        } catch  {}
    }
    return value46;
}
function getFilename(header) {
    needsEncodingFixup = true;
    let matches = FILENAME_STAR_REGEX.exec(header);
    if (matches) {
        const [, filename] = matches;
        return fixupEncoding(rfc2047decode(rfc5987decode(unescape(unquote(filename)))));
    }
    const filename = rfc2231getParam(header);
    if (filename) {
        return fixupEncoding(rfc2047decode(filename));
    }
    matches = FILENAME_REGEX.exec(header);
    if (matches) {
        const [, filename] = matches;
        return fixupEncoding(rfc2047decode(unquote(filename)));
    }
    return "";
}
const decoder1 = new TextDecoder();
const encoder1 = new TextEncoder();
const BOUNDARY_PARAM_REGEX = toParamRegExp("boundary", "i");
const NAME_PARAM_REGEX = toParamRegExp("name", "i");
function append(a11, b15) {
    const ab = new Uint8Array(a11.length + b15.length);
    ab.set(a11, 0);
    ab.set(b15, a11.length);
    return ab;
}
function isEqual(a12, b16) {
    return equals(skipLWSPChar(a12), b16);
}
async function readToStartOrEnd(body, start, end) {
    let lineResult;
    while(lineResult = await body.readLine()){
        if (isEqual(lineResult.bytes, start)) {
            return true;
        }
        if (isEqual(lineResult.bytes, end)) {
            return false;
        }
    }
    throw new errors.BadRequest("Unable to find multi-part boundary.");
}
async function* parts({ body , customContentTypes ={} , final: __final , part , maxFileSize , maxSize , outPath , prefix  }) {
    async function getFile(contentType1) {
        const ext = customContentTypes[contentType1.toLowerCase()] ?? extension(contentType1);
        if (!ext) {
            throw new errors.BadRequest(`The form contained content type "${contentType1}" which is not supported by the server.`);
        }
        if (!outPath) {
            outPath = await Deno.makeTempDir();
        }
        const filename = `${outPath}/${await getRandomFilename(prefix, ext)}`;
        const file = await Deno.open(filename, {
            write: true,
            createNew: true
        });
        return [
            filename,
            file
        ];
    }
    while(true){
        const headers = await readHeaders(body);
        const contentType2 = headers["content-type"];
        const contentDisposition = headers["content-disposition"];
        if (!contentDisposition) {
            throw new errors.BadRequest("Form data part missing content-disposition header");
        }
        if (!contentDisposition.match(/^form-data;/i)) {
            throw new errors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
        }
        const matches = NAME_PARAM_REGEX.exec(contentDisposition);
        if (!matches) {
            throw new errors.BadRequest(`Unable to determine name of form body part`);
        }
        let [, name] = matches;
        name = unquote(name);
        if (contentType2) {
            const originalName = getFilename(contentDisposition);
            let byteLength = 0;
            let file;
            let filename;
            let buf;
            if (maxSize) {
                buf = new Uint8Array();
            } else {
                const result = await getFile(contentType2);
                filename = result[0];
                file = result[1];
            }
            while(true){
                const readResult = await body.readLine(false);
                if (!readResult) {
                    throw new errors.BadRequest("Unexpected EOF reached");
                }
                const { bytes  } = readResult;
                const strippedBytes = stripEol(bytes);
                if (isEqual(strippedBytes, part) || isEqual(strippedBytes, __final)) {
                    if (file) {
                        const bytesDiff = bytes.length - strippedBytes.length;
                        if (bytesDiff) {
                            const originalBytesSize = await file.seek(-bytesDiff, Deno.SeekMode.Current);
                            await file.truncate(originalBytesSize);
                        }
                        file.close();
                    }
                    yield [
                        name,
                        {
                            content: buf,
                            contentType: contentType2,
                            name,
                            filename,
                            originalName
                        }, 
                    ];
                    if (isEqual(strippedBytes, __final)) {
                        return;
                    }
                    break;
                }
                byteLength += bytes.byteLength;
                if (byteLength > maxFileSize) {
                    if (file) {
                        file.close();
                    }
                    throw new errors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                }
                if (buf) {
                    if (byteLength > maxSize) {
                        const result = await getFile(contentType2);
                        filename = result[0];
                        file = result[1];
                        await writeAll(file, buf);
                        buf = undefined;
                    } else {
                        buf = append(buf, bytes);
                    }
                }
                if (file) {
                    await writeAll(file, bytes);
                }
            }
        } else {
            const lines = [];
            while(true){
                const readResult = await body.readLine();
                if (!readResult) {
                    throw new errors.BadRequest("Unexpected EOF reached");
                }
                const { bytes  } = readResult;
                if (isEqual(bytes, part) || isEqual(bytes, __final)) {
                    yield [
                        name,
                        lines.join("\n")
                    ];
                    if (isEqual(bytes, __final)) {
                        return;
                    }
                    break;
                }
                lines.push(decoder1.decode(bytes));
            }
        }
    }
}
class FormDataReader {
    #body;
    #boundaryFinal;
    #boundaryPart;
    #reading = false;
    constructor(contentType3, body){
        const matches = contentType3.match(BOUNDARY_PARAM_REGEX);
        if (!matches) {
            throw new errors.BadRequest(`Content type "${contentType3}" does not contain a valid boundary.`);
        }
        let [, boundary1] = matches;
        boundary1 = unquote(boundary1);
        this.#boundaryPart = encoder1.encode(`--${boundary1}`);
        this.#boundaryFinal = encoder1.encode(`--${boundary1}--`);
        this.#body = body;
    }
    async read(options = {}) {
        if (this.#reading) {
            throw new Error("Body is already being read.");
        }
        this.#reading = true;
        const { outPath , maxFileSize =10_485_760 , maxSize =0 , bufferSize =1_048_576 , customContentTypes ,  } = options;
        const body = new BufReader2(this.#body, bufferSize);
        const result = {
            fields: {}
        };
        if (!await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal)) {
            return result;
        }
        try {
            for await (const part of parts({
                body,
                customContentTypes,
                part: this.#boundaryPart,
                final: this.#boundaryFinal,
                maxFileSize,
                maxSize,
                outPath
            })){
                const [key36, value47] = part;
                if (typeof value47 === "string") {
                    result.fields[key36] = value47;
                } else {
                    if (!result.files) {
                        result.files = [];
                    }
                    result.files.push(value47);
                }
            }
        } catch (err) {
            if (err instanceof Deno.errors.PermissionDenied) {
                console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
            } else {
                throw err;
            }
        }
        return result;
    }
    async *stream(options = {}) {
        if (this.#reading) {
            throw new Error("Body is already being read.");
        }
        this.#reading = true;
        const { outPath , customContentTypes , maxFileSize =10_485_760 , maxSize =0 , bufferSize =32000 ,  } = options;
        const body = new BufReader2(this.#body, bufferSize);
        if (!await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal)) {
            return;
        }
        try {
            for await (const part of parts({
                body,
                customContentTypes,
                part: this.#boundaryPart,
                final: this.#boundaryFinal,
                maxFileSize,
                maxSize,
                outPath
            })){
                yield part;
            }
        } catch (err) {
            if (err instanceof Deno.errors.PermissionDenied) {
                console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
            } else {
                throw err;
            }
        }
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({})}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({}, newOptions)}`;
    }
}
const defaultBodyContentTypes = {
    json: [
        "json",
        "application/*+json",
        "application/csp-report"
    ],
    form: [
        "urlencoded"
    ],
    formData: [
        "multipart"
    ],
    text: [
        "text"
    ]
};
function resolveType(contentType4, contentTypes) {
    const contentTypesJson = [
        ...defaultBodyContentTypes.json,
        ...contentTypes.json ?? [], 
    ];
    const contentTypesForm = [
        ...defaultBodyContentTypes.form,
        ...contentTypes.form ?? [], 
    ];
    const contentTypesFormData = [
        ...defaultBodyContentTypes.formData,
        ...contentTypes.formData ?? [], 
    ];
    const contentTypesText = [
        ...defaultBodyContentTypes.text,
        ...contentTypes.text ?? [], 
    ];
    if (contentTypes.bytes && isMediaType(contentType4, contentTypes.bytes)) {
        return "bytes";
    } else if (isMediaType(contentType4, contentTypesJson)) {
        return "json";
    } else if (isMediaType(contentType4, contentTypesForm)) {
        return "form";
    } else if (isMediaType(contentType4, contentTypesFormData)) {
        return "form-data";
    } else if (isMediaType(contentType4, contentTypesText)) {
        return "text";
    }
    return "bytes";
}
const decoder2 = new TextDecoder();
class RequestBody {
    #body;
    #formDataReader;
    #headers;
    #jsonBodyReviver;
    #stream;
    #readAllBody;
    #readBody;
    #type;
     #exceedsLimit(limit) {
        if (!limit || limit === Infinity) {
            return false;
        }
        if (!this.#body) {
            return false;
        }
        const contentLength = this.#headers.get("content-length");
        if (!contentLength) {
            return true;
        }
        const parsed = parseInt(contentLength, 10);
        if (isNaN(parsed)) {
            return true;
        }
        return parsed > limit;
    }
     #parse(type, limit1) {
        switch(type){
            case "form":
                this.#type = "bytes";
                if (this.#exceedsLimit(limit1)) {
                    return ()=>Promise.reject(new RangeError(`Body exceeds a limit of ${limit1}.`));
                }
                return async ()=>new URLSearchParams(decoder2.decode(await this.#valuePromise()).replace(/\+/g, " "));
            case "form-data":
                this.#type = "form-data";
                return ()=>{
                    const contentType5 = this.#headers.get("content-type");
                    assert4(contentType5);
                    const readableStream = this.#body ?? new ReadableStream();
                    return this.#formDataReader ?? (this.#formDataReader = new FormDataReader(contentType5, readerFromStreamReader(readableStream.getReader())));
                };
            case "json":
                this.#type = "bytes";
                if (this.#exceedsLimit(limit1)) {
                    return ()=>Promise.reject(new RangeError(`Body exceeds a limit of ${limit1}.`));
                }
                return async ()=>JSON.parse(decoder2.decode(await this.#valuePromise()), this.#jsonBodyReviver);
            case "bytes":
                this.#type = "bytes";
                if (this.#exceedsLimit(limit1)) {
                    return ()=>Promise.reject(new RangeError(`Body exceeds a limit of ${limit1}.`));
                }
                return ()=>this.#valuePromise();
            case "text":
                this.#type = "bytes";
                if (this.#exceedsLimit(limit1)) {
                    return ()=>Promise.reject(new RangeError(`Body exceeds a limit of ${limit1}.`));
                }
                return async ()=>decoder2.decode(await this.#valuePromise());
            default:
                throw new TypeError(`Invalid body type: "${type}"`);
        }
    }
     #validateGetArgs(type1, contentTypes) {
        if (type1 === "reader" && this.#type && this.#type !== "reader") {
            throw new TypeError(`Body already consumed as "${this.#type}" and cannot be returned as a reader.`);
        }
        if (type1 === "stream" && this.#type && this.#type !== "stream") {
            throw new TypeError(`Body already consumed as "${this.#type}" and cannot be returned as a stream.`);
        }
        if (type1 === "form-data" && this.#type && this.#type !== "form-data") {
            throw new TypeError(`Body already consumed as "${this.#type}" and cannot be returned as a stream.`);
        }
        if (this.#type === "reader" && type1 !== "reader") {
            throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
        }
        if (this.#type === "stream" && type1 !== "stream") {
            throw new TypeError("Body already consumed as a stream and can only be returned as a stream.");
        }
        if (this.#type === "form-data" && type1 !== "form-data") {
            throw new TypeError("Body already consumed as form data and can only be returned as form data.");
        }
        if (type1 && Object.keys(contentTypes).length) {
            throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
        }
    }
     #valuePromise() {
        return this.#readAllBody ?? (this.#readAllBody = this.#readBody());
    }
    constructor({ body , readBody  }, headers, jsonBodyReviver){
        this.#body = body;
        this.#headers = headers;
        this.#jsonBodyReviver = jsonBodyReviver;
        this.#readBody = readBody;
    }
    get({ limit: limit2 = 10_485_760 , type: type2 , contentTypes: contentTypes1 = {}  } = {}) {
        this.#validateGetArgs(type2, contentTypes1);
        if (type2 === "reader") {
            if (!this.#body) {
                this.#type = "undefined";
                throw new TypeError(`Body is undefined and cannot be returned as "reader".`);
            }
            this.#type = "reader";
            return {
                type: type2,
                value: readerFromStreamReader(this.#body.getReader())
            };
        }
        if (type2 === "stream") {
            if (!this.#body) {
                this.#type = "undefined";
                throw new TypeError(`Body is undefined and cannot be returned as "stream".`);
            }
            this.#type = "stream";
            const streams = (this.#stream ?? this.#body).tee();
            this.#stream = streams[1];
            return {
                type: type2,
                value: streams[0]
            };
        }
        if (!this.has()) {
            this.#type = "undefined";
        } else if (!this.#type) {
            const encoding = this.#headers.get("content-encoding") ?? "identity";
            if (encoding !== "identity") {
                throw new errors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
            }
        }
        if (this.#type === "undefined" && (!type2 || type2 === "undefined")) {
            return {
                type: "undefined",
                value: undefined
            };
        }
        if (!type2) {
            const contentType6 = this.#headers.get("content-type");
            assert4(contentType6, "The Content-Type header is missing from the request");
            type2 = resolveType(contentType6, contentTypes1);
        }
        assert4(type2);
        const body = Object.create(null);
        Object.defineProperties(body, {
            type: {
                value: type2,
                configurable: true,
                enumerable: true
            },
            value: {
                get: this.#parse(type2, limit2),
                configurable: true,
                enumerable: true
            }
        });
        return body;
    }
    has() {
        return this.#body != null;
    }
}
class Request1 {
    #body;
    #proxy;
    #secure;
    #serverRequest;
    #url;
     #getRemoteAddr() {
        return this.#serverRequest.remoteAddr ?? "";
    }
    get hasBody() {
        return this.#body.has();
    }
    get headers() {
        return this.#serverRequest.headers;
    }
    get ip() {
        return (this.#proxy ? this.ips[0] : this.#getRemoteAddr()) ?? "";
    }
    get ips() {
        return this.#proxy ? (this.#serverRequest.headers.get("x-forwarded-for") ?? this.#getRemoteAddr()).split(/\s*,\s*/) : [];
    }
    get method() {
        return this.#serverRequest.method;
    }
    get secure() {
        return this.#secure;
    }
    get originalRequest() {
        return this.#serverRequest;
    }
    get url() {
        if (!this.#url) {
            const serverRequest = this.#serverRequest;
            if (!this.#proxy) {
                try {
                    if (serverRequest.rawUrl) {
                        this.#url = new URL(serverRequest.rawUrl);
                        return this.#url;
                    }
                } catch  {}
            }
            let proto;
            let host;
            if (this.#proxy) {
                proto = serverRequest.headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ?? "http";
                host = (serverRequest.headers.get("x-forwarded-host") ?? serverRequest.headers.get("host")) ?? "";
            } else {
                proto = this.#secure ? "https" : "http";
                host = serverRequest.headers.get("host") ?? "";
            }
            try {
                this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
            } catch  {
                throw new TypeError(`The server request URL of "${proto}://${host}${serverRequest.url}" is invalid.`);
            }
        }
        return this.#url;
    }
    constructor(serverRequest, { proxy: proxy1 = false , secure =false , jsonBodyReviver  } = {}){
        this.#proxy = proxy1;
        this.#secure = secure;
        this.#serverRequest = serverRequest;
        this.#body = new RequestBody(serverRequest.getBody(), serverRequest.headers, jsonBodyReviver);
    }
    accepts(...types3) {
        if (!this.#serverRequest.headers.has("Accept")) {
            return types3.length ? types3[0] : [
                "*/*"
            ];
        }
        if (types3.length) {
            return accepts(this.#serverRequest, ...types3);
        }
        return accepts(this.#serverRequest);
    }
    acceptsEncodings(...encodings) {
        if (!this.#serverRequest.headers.has("Accept-Encoding")) {
            return encodings.length ? encodings[0] : [
                "*"
            ];
        }
        if (encodings.length) {
            return acceptsEncodings(this.#serverRequest, ...encodings);
        }
        return acceptsEncodings(this.#serverRequest);
    }
    acceptsLanguages(...langs) {
        if (!this.#serverRequest.headers.get("Accept-Language")) {
            return langs.length ? langs[0] : [
                "*"
            ];
        }
        if (langs.length) {
            return acceptsLanguages(this.#serverRequest, ...langs);
        }
        return acceptsLanguages(this.#serverRequest);
    }
    body(options = {}) {
        return this.#body.get(options);
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { hasBody , headers , ip , ips , method , secure , url  } = this;
        return `${this.constructor.name} ${inspect({
            hasBody,
            headers,
            ip,
            ips,
            method,
            secure,
            url: url.toString()
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        const { hasBody , headers , ip , ips , method , secure , url  } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            hasBody,
            headers,
            ip,
            ips,
            method,
            secure,
            url
        }, newOptions)}`;
    }
}
const DomResponse = globalThis.Response ?? class MockResponse {
};
const maybeUpgradeWebSocket = "upgradeWebSocket" in Deno ? Deno.upgradeWebSocket.bind(Deno) : undefined;
class NativeRequest {
    #conn;
    #reject;
    #request;
    #requestPromise;
    #resolve;
    #resolved = false;
    #upgradeWebSocket;
    constructor(requestEvent, options = {}){
        const { conn  } = options;
        this.#conn = conn;
        this.#upgradeWebSocket = "upgradeWebSocket" in options ? options["upgradeWebSocket"] : maybeUpgradeWebSocket;
        this.#request = requestEvent.request;
        const p21 = new Promise((resolve7, reject)=>{
            this.#resolve = resolve7;
            this.#reject = reject;
        });
        this.#requestPromise = requestEvent.respondWith(p21);
    }
    get body() {
        return this.#request.body;
    }
    get donePromise() {
        return this.#requestPromise;
    }
    get headers() {
        return this.#request.headers;
    }
    get method() {
        return this.#request.method;
    }
    get remoteAddr() {
        return this.#conn?.remoteAddr?.hostname;
    }
    get request() {
        return this.#request;
    }
    get url() {
        try {
            const url = new URL(this.#request.url);
            return this.#request.url.replace(url.origin, "");
        } catch  {}
        return this.#request.url;
    }
    get rawUrl() {
        return this.#request.url;
    }
    error(reason) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        this.#reject(reason);
        this.#resolved = true;
    }
    getBody() {
        return {
            body: this.#request.body,
            readBody: async ()=>{
                const ab = await this.#request.arrayBuffer();
                return new Uint8Array(ab);
            }
        };
    }
    respond(response) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        this.#resolve(response);
        this.#resolved = true;
        return this.#requestPromise;
    }
    upgrade(options) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        if (!this.#upgradeWebSocket) {
            throw new TypeError("Upgrading web sockets not supported.");
        }
        const { response , socket  } = this.#upgradeWebSocket(this.#request, options);
        this.#resolve(response);
        this.#resolved = true;
        return socket;
    }
}
const REDIRECT_BACK = Symbol("redirect backwards");
async function convertBodyToBodyInit(body, type3, jsonBodyReplacer) {
    let result;
    if (BODY_TYPES.includes(typeof body)) {
        result = String(body);
        type3 = type3 ?? (isHtml(result) ? "html" : "text/plain");
    } else if (isReader(body)) {
        result = readableStreamFromReader(body);
    } else if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof Blob || body instanceof URLSearchParams) {
        result = body;
    } else if (body instanceof ReadableStream) {
        result = body.pipeThrough(new Uint8ArrayTransformStream());
    } else if (body instanceof FormData) {
        result = body;
        type3 = "multipart/form-data";
    } else if (isAsyncIterable(body)) {
        result = readableStreamFromAsyncIterable(body);
    } else if (body && typeof body === "object") {
        result = JSON.stringify(body, jsonBodyReplacer);
        type3 = type3 ?? "json";
    } else if (typeof body === "function") {
        const result = body.call(null);
        return convertBodyToBodyInit(await result, type3, jsonBodyReplacer);
    } else if (body) {
        throw new TypeError("Response body was set but could not be converted.");
    }
    return [
        result,
        type3
    ];
}
class Response1 {
    #body;
    #bodySet = false;
    #domResponse;
    #headers = new Headers();
    #jsonBodyReplacer;
    #request;
    #resources = [];
    #status;
    #type;
    #writable = true;
    async #getBodyInit() {
        const [body, type] = await convertBodyToBodyInit(this.body, this.type, this.#jsonBodyReplacer);
        this.type = type;
        return body;
    }
     #setContentType() {
        if (this.type) {
            const contentTypeString = contentType(this.type);
            if (contentTypeString && !this.headers.has("Content-Type")) {
                this.headers.append("Content-Type", contentTypeString);
            }
        }
    }
    get body() {
        return this.#body;
    }
    set body(value48) {
        if (!this.#writable) {
            throw new Error("The response is not writable.");
        }
        this.#bodySet = true;
        this.#body = value48;
    }
    get headers() {
        return this.#headers;
    }
    set headers(value49) {
        if (!this.#writable) {
            throw new Error("The response is not writable.");
        }
        this.#headers = value49;
    }
    get status() {
        if (this.#status) {
            return this.#status;
        }
        return this.body != null ? Status.OK : this.#bodySet ? Status.NoContent : Status.NotFound;
    }
    set status(value50) {
        if (!this.#writable) {
            throw new Error("The response is not writable.");
        }
        this.#status = value50;
    }
    get type() {
        return this.#type;
    }
    set type(value51) {
        if (!this.#writable) {
            throw new Error("The response is not writable.");
        }
        this.#type = value51;
    }
    get writable() {
        return this.#writable;
    }
    constructor(request, jsonBodyReplacer){
        this.#request = request;
        this.#jsonBodyReplacer = jsonBodyReplacer;
    }
    addResource(rid) {
        this.#resources.push(rid);
    }
    destroy(closeResources = true) {
        this.#writable = false;
        this.#body = undefined;
        this.#domResponse = undefined;
        if (closeResources) {
            for (const rid of this.#resources){
                try {
                    Deno.close(rid);
                } catch  {}
            }
        }
    }
    redirect(url, alt = "/") {
        if (url === REDIRECT_BACK) {
            url = this.#request.headers.get("Referer") ?? String(alt);
        } else if (typeof url === "object") {
            url = String(url);
        }
        this.headers.set("Location", encodeUrl(url));
        if (!this.status || !isRedirectStatus(this.status)) {
            this.status = Status.Found;
        }
        if (this.#request.accepts("html")) {
            url = encodeURI(url);
            this.type = "text/html; charset=UTF-8";
            this.body = `Redirecting to <a href="${url}">${url}</a>.`;
            return;
        }
        this.type = "text/plain; charset=UTF-8";
        this.body = `Redirecting to ${url}.`;
    }
    async toDomResponse() {
        if (this.#domResponse) {
            return this.#domResponse;
        }
        const bodyInit = await this.#getBodyInit();
        this.#setContentType();
        const { headers  } = this;
        if (!(bodyInit || headers.has("Content-Type") || headers.has("Content-Length"))) {
            headers.append("Content-Length", "0");
        }
        this.#writable = false;
        const status = this.status;
        const responseInit = {
            headers,
            status,
            statusText: STATUS_TEXT[status]
        };
        return this.#domResponse = new DomResponse(bodyInit, responseInit);
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { body , headers , status , type: type4 , writable  } = this;
        return `${this.constructor.name} ${inspect({
            body,
            headers,
            status,
            type: type4,
            writable
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        const { body , headers , status , type: type5 , writable  } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            body,
            headers,
            status,
            type: type5,
            writable
        }, newOptions)}`;
    }
}
function isFileInfo(value52) {
    return Boolean(value52 && typeof value52 === "object" && "mtime" in value52 && "size" in value52);
}
function calcStatTag(entity) {
    const mtime = entity.mtime?.getTime().toString(16) ?? "0";
    const size = entity.size.toString(16);
    return `"${size}-${mtime}"`;
}
const encoder2 = new TextEncoder();
async function calcEntityTag(entity) {
    if (entity.length === 0) {
        return `"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk="`;
    }
    if (typeof entity === "string") {
        entity = encoder2.encode(entity);
    }
    const hash = mod6.encode(await crypto.subtle.digest("SHA-1", entity)).substring(0, 27);
    return `"${entity.length.toString(16)}-${hash}"`;
}
function fstat(file) {
    if ("fstat" in Deno) {
        return Deno.fstat(file.rid);
    }
    return Promise.resolve(undefined);
}
function getEntity(context) {
    const { body  } = context.response;
    if (body instanceof Deno.FsFile) {
        return fstat(body);
    }
    if (body instanceof Uint8Array) {
        return Promise.resolve(body);
    }
    if (BODY_TYPES.includes(typeof body)) {
        return Promise.resolve(String(body));
    }
    if (isAsyncIterable(body) || isReader(body)) {
        return Promise.resolve(undefined);
    }
    if (typeof body === "object" && body !== null) {
        try {
            const bodyText = JSON.stringify(body);
            return Promise.resolve(bodyText);
        } catch  {}
    }
    return Promise.resolve(undefined);
}
async function calculate(entity, options = {}) {
    const weak = options.weak ?? isFileInfo(entity);
    const tag = isFileInfo(entity) ? calcStatTag(entity) : await calcEntityTag(entity);
    return weak ? `W/${tag}` : tag;
}
function factory(options) {
    return async function etag(context, next) {
        await next();
        if (!context.response.headers.has("ETag")) {
            const entity = await getEntity(context);
            if (entity) {
                context.response.headers.set("ETag", await calculate(entity, options));
            }
        }
    };
}
async function ifMatch(value53, entity, options = {}) {
    const etag = await calculate(entity, options);
    if (etag.startsWith("W/")) {
        return false;
    }
    if (value53.trim() === "*") {
        return true;
    }
    const tags = value53.split(/\s*,\s*/);
    return tags.includes(etag);
}
async function ifNoneMatch(value54, entity, options = {}) {
    if (value54.trim() === "*") {
        return false;
    }
    const etag = await calculate(entity, options);
    const tags = value54.split(/\s*,\s*/);
    return !tags.includes(etag);
}
const mod9 = {
    getEntity: getEntity,
    calculate: calculate,
    factory: factory,
    ifMatch: ifMatch,
    ifNoneMatch: ifNoneMatch
};
const ETAG_RE = /(?:W\/)?"[ !#-\x7E\x80-\xFF]+"/;
async function ifRange(value55, mtime, entity) {
    if (value55) {
        const matches = value55.match(ETAG_RE);
        if (matches) {
            const [match] = matches;
            if (await calculate(entity) === match) {
                return true;
            }
        } else {
            return new Date(value55).getTime() >= mtime;
        }
    }
    return false;
}
function parseRange(value56, size) {
    const ranges = [];
    const [unit, rangesStr] = value56.split("=");
    if (unit !== "bytes") {
        throw createHttpError(Status.RequestedRangeNotSatisfiable);
    }
    for (const range of rangesStr.split(/\s*,\s+/)){
        const item = range.split("-");
        if (item.length !== 2) {
            throw createHttpError(Status.RequestedRangeNotSatisfiable);
        }
        const [startStr, endStr] = item;
        let start;
        let end;
        try {
            if (startStr === "") {
                start = size - parseInt(endStr, 10) - 1;
                end = size - 1;
            } else if (endStr === "") {
                start = parseInt(startStr, 10);
                end = size - 1;
            } else {
                start = parseInt(startStr, 10);
                end = parseInt(endStr, 10);
            }
        } catch  {
            throw createHttpError();
        }
        if (start < 0 || start >= size || end < 0 || end >= size || start > end) {
            throw createHttpError(Status.RequestedRangeNotSatisfiable);
        }
        ranges.push({
            start,
            end
        });
    }
    return ranges;
}
async function readRange(file, range) {
    let length = range.end - range.start + 1;
    assert4(length);
    await file.seek(range.start, Deno.SeekMode.Start);
    const result = new Uint8Array(length);
    let off = 0;
    while(length){
        const p22 = new Uint8Array(Math.min(length, 16_640));
        const nread = await file.read(p22);
        assert4(nread !== null, "Unexpected EOF encountered when reading a range.");
        assert4(nread > 0, "Unexpected read of 0 bytes while reading a range.");
        copy2(p22, result, off);
        off += nread;
        length -= nread;
        assert4(length >= 0, "Unexpected length remaining.");
    }
    return result;
}
const encoder3 = new TextEncoder();
class MultiPartStream extends ReadableStream {
    #contentLength;
    #postscript;
    #preamble;
    constructor(file, type6, ranges, size, boundary2){
        super({
            pull: async (controller)=>{
                const range = ranges.shift();
                if (!range) {
                    controller.enqueue(this.#postscript);
                    controller.close();
                    if (!(file instanceof Uint8Array)) {
                        file.close();
                    }
                    return;
                }
                let bytes;
                if (file instanceof Uint8Array) {
                    bytes = file.subarray(range.start, range.end + 1);
                } else {
                    bytes = await readRange(file, range);
                }
                const rangeHeader = encoder3.encode(`Content-Range: ${range.start}-${range.end}/${size}\n\n`);
                controller.enqueue(concat(this.#preamble, rangeHeader, bytes));
            }
        });
        const resolvedType = contentType(type6);
        if (!resolvedType) {
            throw new TypeError(`Could not resolve media type for "${type6}"`);
        }
        this.#preamble = encoder3.encode(`\n--${boundary2}\nContent-Type: ${resolvedType}\n`);
        this.#postscript = encoder3.encode(`\n--${boundary2}--\n`);
        this.#contentLength = ranges.reduce((prev, { start , end  })=>{
            return prev + this.#preamble.length + String(start).length + String(end).length + String(size).length + 20 + (end - start);
        }, this.#postscript.length);
    }
    contentLength() {
        return this.#contentLength;
    }
}
let boundary;
function isHidden(path65) {
    const pathArr = path65.split("/");
    for (const segment of pathArr){
        if (segment[0] === "." && segment !== "." && segment !== "..") {
            return true;
        }
        return false;
    }
}
async function exists1(path66) {
    try {
        return (await Deno.stat(path66)).isFile;
    } catch  {
        return false;
    }
}
async function getEntity1(path67, mtime, stats, maxbuffer, response) {
    let body;
    let entity;
    const file = await Deno.open(path67, {
        read: true
    });
    if (stats.size < maxbuffer) {
        const buffer1 = await readAll(file);
        file.close();
        body = entity = buffer1;
    } else {
        response.addResource(file.rid);
        body = file;
        entity = {
            mtime: new Date(mtime),
            size: stats.size
        };
    }
    return [
        body,
        entity
    ];
}
async function sendRange(response, body, range, size) {
    const ranges = parseRange(range, size);
    if (ranges.length === 0) {
        throw createHttpError(Status.RequestedRangeNotSatisfiable);
    }
    response.status = Status.PartialContent;
    if (ranges.length === 1) {
        const [byteRange] = ranges;
        response.headers.set("Content-Length", String(byteRange.end - byteRange.start + 1));
        response.headers.set("Content-Range", `bytes ${byteRange.start}-${byteRange.end}/${size}`);
        if (body instanceof Uint8Array) {
            response.body = body.slice(byteRange.start, byteRange.end + 1);
        } else {
            await body.seek(byteRange.start, Deno.SeekMode.Start);
            response.body = new LimitedReader(body, byteRange.end - byteRange.start + 1);
        }
    } else {
        assert4(response.type);
        if (!boundary) {
            boundary = await getBoundary();
        }
        response.headers.set("content-type", `multipart/byteranges; boundary=${boundary}`);
        const multipartBody = new MultiPartStream(body, response.type, ranges, size, boundary);
        response.headers.set("content-length", String(multipartBody.contentLength()));
        response.body = multipartBody;
    }
}
async function send({ request , response  }, path68, options = {
    root: ""
}) {
    const { brotli =true , contentTypes: contentTypes2 = {} , extensions: extensions1 , format: format8 = true , gzip =true , hidden =false , immutable =false , index , maxbuffer =1_048_576 , maxage =0 , root ,  } = options;
    const trailingSlash = path68[path68.length - 1] === "/";
    path68 = decodeComponent(path68.substr(parse6(path68).root.length));
    if (index && trailingSlash) {
        path68 += index;
    }
    if (!hidden && isHidden(path68)) {
        throw createHttpError(403);
    }
    path68 = resolvePath(root, path68);
    let encodingExt = "";
    if (brotli && request.acceptsEncodings("br", "identity") === "br" && await exists1(`${path68}.br`)) {
        path68 = `${path68}.br`;
        response.headers.set("Content-Encoding", "br");
        response.headers.delete("Content-Length");
        encodingExt = ".br";
    } else if (gzip && request.acceptsEncodings("gzip", "identity") === "gzip" && await exists1(`${path68}.gz`)) {
        path68 = `${path68}.gz`;
        response.headers.set("Content-Encoding", "gzip");
        response.headers.delete("Content-Length");
        encodingExt = ".gz";
    }
    if (extensions1 && !/\.[^/]*$/.exec(path68)) {
        for (let ext of extensions1){
            if (!/^\./.exec(ext)) {
                ext = `.${ext}`;
            }
            if (await exists1(`${path68}${ext}`)) {
                path68 += ext;
                break;
            }
        }
    }
    let stats;
    try {
        stats = await Deno.stat(path68);
        if (stats.isDirectory) {
            if (format8 && index) {
                path68 += `/${index}`;
                stats = await Deno.stat(path68);
            } else {
                return;
            }
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            throw createHttpError(404, err.message);
        }
        if (err instanceof Error && err.message.startsWith("ENOENT:")) {
            throw createHttpError(404, err.message);
        }
        throw createHttpError(500, err instanceof Error ? err.message : "[non-error thrown]");
    }
    let mtime = null;
    if (response.headers.has("Last-Modified")) {
        mtime = new Date(response.headers.get("Last-Modified")).getTime();
    } else if (stats.mtime) {
        mtime = stats.mtime.getTime();
        mtime -= mtime % 1000;
        response.headers.set("Last-Modified", new Date(mtime).toUTCString());
    }
    if (!response.headers.has("Cache-Control")) {
        const directives = [
            `max-age=${maxage / 1000 | 0}`
        ];
        if (immutable) {
            directives.push("immutable");
        }
        response.headers.set("Cache-Control", directives.join(","));
    }
    if (!response.type) {
        response.type = encodingExt !== "" ? extname5(basename5(path68, encodingExt)) : contentTypes2[extname5(path68)] ?? extname5(path68);
    }
    let entity = null;
    let body = null;
    if (request.headers.has("If-None-Match") && mtime) {
        [body, entity] = await getEntity1(path68, mtime, stats, maxbuffer, response);
        if (!await ifNoneMatch(request.headers.get("If-None-Match"), entity)) {
            response.headers.set("ETag", await calculate(entity));
            response.status = 304;
            return path68;
        }
    }
    if (request.headers.has("If-Modified-Since") && mtime) {
        const ifModifiedSince = new Date(request.headers.get("If-Modified-Since"));
        if (ifModifiedSince.getTime() >= mtime) {
            response.status = 304;
            return path68;
        }
    }
    if (!body || !entity) {
        [body, entity] = await getEntity1(path68, mtime ?? 0, stats, maxbuffer, response);
    }
    if (request.headers.has("If-Range") && mtime && await ifRange(request.headers.get("If-Range"), mtime, entity) && request.headers.has("Range")) {
        await sendRange(response, body, request.headers.get("Range"), stats.size);
        return path68;
    }
    if (request.headers.has("Range")) {
        await sendRange(response, body, request.headers.get("Range"), stats.size);
        return path68;
    }
    response.headers.set("Content-Length", String(stats.size));
    response.body = body;
    if (!response.headers.has("ETag")) {
        response.headers.set("ETag", await calculate(entity));
    }
    if (!response.headers.has("Accept-Ranges")) {
        response.headers.set("Accept-Ranges", "bytes");
    }
    return path68;
}
const encoder4 = new TextEncoder();
class CloseEvent extends Event {
    constructor(eventInit){
        super("close", eventInit);
    }
}
class ServerSentEvent extends Event {
    #data;
    #id;
    #type;
    constructor(type7, data, eventInit = {}){
        super(type7, eventInit);
        const { replacer , space  } = eventInit;
        this.#type = type7;
        try {
            this.#data = typeof data === "string" ? data : JSON.stringify(data, replacer, space);
        } catch (e18) {
            assert4(e18 instanceof Error);
            throw new TypeError(`data could not be coerced into a serialized string.\n  ${e18.message}`);
        }
        const { id  } = eventInit;
        this.#id = id;
    }
    get data() {
        return this.#data;
    }
    get id() {
        return this.#id;
    }
    toString() {
        const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
        return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
    }
}
const RESPONSE_HEADERS = [
    [
        "Connection",
        "Keep-Alive"
    ],
    [
        "Content-Type",
        "text/event-stream"
    ],
    [
        "Cache-Control",
        "no-cache"
    ],
    [
        "Keep-Alive",
        `timeout=${Number.MAX_SAFE_INTEGER}`
    ], 
];
class SSEStreamTarget extends EventTarget {
    #closed = false;
    #context;
    #controller;
    #keepAliveId;
     #error(error7) {
        console.log("error", error7);
        this.dispatchEvent(new CloseEvent({
            cancelable: false
        }));
        const errorEvent = new ErrorEvent("error", {
            error: error7
        });
        this.dispatchEvent(errorEvent);
        this.#context.app.dispatchEvent(errorEvent);
    }
     #push(payload) {
        if (!this.#controller) {
            this.#error(new Error("The controller has not been set."));
            return;
        }
        if (this.#closed) {
            return;
        }
        this.#controller.enqueue(encoder4.encode(payload));
    }
    get closed() {
        return this.#closed;
    }
    constructor(context, { headers , keepAlive =false  } = {}){
        super();
        this.#context = context;
        context.response.body = new ReadableStream({
            start: (controller)=>{
                this.#controller = controller;
            },
            cancel: (error1)=>{
                if (error1 instanceof Error && error1.message.includes("connection closed")) {
                    this.close();
                } else {
                    this.#error(error1);
                }
            }
        });
        if (headers) {
            for (const [key37, value57] of headers){
                context.response.headers.set(key37, value57);
            }
        }
        for (const [key38, value58] of RESPONSE_HEADERS){
            context.response.headers.set(key38, value58);
        }
        this.addEventListener("close", ()=>{
            this.#closed = true;
            if (this.#keepAliveId != null) {
                clearInterval(this.#keepAliveId);
                this.#keepAliveId = undefined;
            }
            if (this.#controller) {
                try {
                    this.#controller.close();
                } catch  {}
            }
        });
        if (keepAlive) {
            const interval = typeof keepAlive === "number" ? keepAlive : 30_000;
            this.#keepAliveId = setInterval(()=>{
                this.dispatchComment("keep-alive comment");
            }, interval);
        }
    }
    close() {
        this.dispatchEvent(new CloseEvent({
            cancelable: false
        }));
        return Promise.resolve();
    }
    dispatchComment(comment) {
        this.#push(`: ${comment.split("\n").join("\n: ")}\n\n`);
        return true;
    }
    dispatchMessage(data) {
        const event = new ServerSentEvent("__message", data);
        return this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const dispatched = super.dispatchEvent(event);
        if (dispatched && event instanceof ServerSentEvent) {
            this.#push(String(event));
        }
        return dispatched;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({
            "#closed": this.#closed,
            "#context": this.#context
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            "#closed": this.#closed,
            "#context": this.#context
        }, newOptions)}`;
    }
}
class Context {
    #socket;
    #sse;
     #wrapReviverReplacer(reviver) {
        return reviver ? (key39, value59)=>reviver(key39, value59, this) : undefined;
    }
    app;
    cookies;
    get isUpgradable() {
        const upgrade = this.request.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = this.request.headers.get("sec-websocket-key");
        return typeof secKey === "string" && secKey != "";
    }
    respond;
    request;
    response;
    get socket() {
        return this.#socket;
    }
    state;
    constructor(app1, serverRequest, state2, { secure =false , jsonBodyReplacer , jsonBodyReviver  } = {}){
        this.app = app1;
        this.state = state2;
        const { proxy: proxy2  } = app1;
        this.request = new Request1(serverRequest, {
            proxy: proxy2,
            secure,
            jsonBodyReviver: this.#wrapReviverReplacer(jsonBodyReviver)
        });
        this.respond = true;
        this.response = new Response1(this.request, this.#wrapReviverReplacer(jsonBodyReplacer));
        this.cookies = new Cookies(this.request, this.response, {
            keys: this.app.keys,
            secure: this.request.secure
        });
    }
    assert(condition, errorStatus = 500, message, props) {
        if (condition) {
            return;
        }
        const err = createHttpError(errorStatus, message);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    send(options) {
        const { path: path69 = this.request.url.pathname , ...sendOptions } = options;
        return send(this, path69, sendOptions);
    }
    sendEvents(options) {
        if (!this.#sse) {
            this.#sse = new SSEStreamTarget(this, options);
        }
        return this.#sse;
    }
    throw(errorStatus, message, props) {
        const err = createHttpError(errorStatus, message);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    upgrade(options) {
        if (this.#socket) {
            return this.#socket;
        }
        if (!this.request.originalRequest.upgrade) {
            throw new TypeError("Web socket upgrades not currently supported for this type of server.");
        }
        this.#socket = this.request.originalRequest.upgrade(options);
        this.respond = false;
        return this.#socket;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { app: app2 , cookies , isUpgradable , respond , request , response , socket , state: state3 ,  } = this;
        return `${this.constructor.name} ${inspect({
            app: app2,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state: state3
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        const { app: app3 , cookies , isUpgradable , respond , request , response , socket , state: state4 ,  } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            app: app3,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state: state4
        }, newOptions)}`;
    }
}
const maybeUpgradeWebSocket1 = "upgradeWebSocket" in Deno ? Deno.upgradeWebSocket.bind(Deno) : undefined;
class HttpRequest {
    #deferred;
    #request;
    #resolved = false;
    #upgradeWebSocket;
    get remoteAddr() {
        return undefined;
    }
    get headers() {
        return this.#request.headers;
    }
    get method() {
        return this.#request.method;
    }
    get url() {
        try {
            const url = new URL(this.#request.url);
            return this.#request.url.replace(url.origin, "");
        } catch  {}
        return this.#request.url;
    }
    constructor(request, deferred1, upgradeWebSocket){
        this.#deferred = deferred1;
        this.#request = request;
        this.#upgradeWebSocket = upgradeWebSocket ?? maybeUpgradeWebSocket1;
    }
    error(reason) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        this.#deferred.reject(reason);
        this.#resolved = true;
    }
    getBody() {
        return {
            body: this.#request.body,
            readBody: async ()=>{
                const ab = await this.#request.arrayBuffer();
                return new Uint8Array(ab);
            }
        };
    }
    respond(response) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        this.#deferred.resolve(response);
        this.#resolved = true;
        return Promise.resolve();
    }
    upgrade(options) {
        if (this.#resolved) {
            throw new Error("Request already responded to.");
        }
        if (!this.#upgradeWebSocket) {
            throw new TypeError("Upgrading web sockets not supported.");
        }
        const { response , socket  } = this.#upgradeWebSocket(this.#request, options);
        this.#deferred.resolve(response);
        return socket;
    }
}
const serve = "serve" in Deno ? Deno.serve.bind(Deno) : undefined;
function hasFlash() {
    return Boolean(serve);
}
class FlashServer {
    #app;
    #closed = false;
    #controller;
    #abortController = new AbortController();
    #options;
    #servePromise;
    #stream;
    constructor(app4, options){
        if (!serve) {
            throw new Error("The flash bindings for serving HTTP are not available.");
        }
        this.#app = app4;
        this.#options = options;
    }
    async close() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        try {
            this.#controller?.close();
            this.#controller = undefined;
            this.#stream = undefined;
            this.#abortController.abort();
            if (this.#servePromise) {
                await this.#servePromise;
                this.#servePromise = undefined;
            }
        } catch  {}
    }
    listen() {
        const p23 = deferred();
        const start = (controller)=>{
            this.#controller = controller;
            const options = {
                ...this.#options,
                signal: this.#abortController.signal,
                onListen: (addr)=>p23.resolve({
                        addr
                    }),
                onError: (error8)=>{
                    this.#app.dispatchEvent(new ErrorEvent("error", {
                        error: error8
                    }));
                    return new Response("Internal server error", {
                        status: Status.InternalServerError,
                        statusText: STATUS_TEXT[Status.InternalServerError]
                    });
                }
            };
            const handler = (request)=>{
                const resolve8 = deferred();
                const flashRequest = new HttpRequest(request, resolve8);
                controller.enqueue(flashRequest);
                return resolve8;
            };
            this.#servePromise = serve(handler, options);
        };
        this.#stream = new ReadableStream({
            start
        });
        return p23;
    }
    [Symbol.asyncIterator]() {
        assert4(this.#stream, ".listen() was not called before iterating or server is closed.");
        return this.#stream[Symbol.asyncIterator]();
    }
}
const serveHttp = "serveHttp" in Deno ? Deno.serveHttp.bind(Deno) : undefined;
class HttpServer {
    #app;
    #closed = false;
    #listener;
    #httpConnections = new Set();
    #options;
    constructor(app5, options){
        if (!("serveHttp" in Deno)) {
            throw new Error("The native bindings for serving HTTP are not available.");
        }
        this.#app = app5;
        this.#options = options;
    }
    get app() {
        return this.#app;
    }
    get closed() {
        return this.#closed;
    }
    close() {
        this.#closed = true;
        if (this.#listener) {
            this.#listener.close();
            this.#listener = undefined;
        }
        for (const httpConn of this.#httpConnections){
            try {
                httpConn.close();
            } catch (error9) {
                if (!(error9 instanceof Deno.errors.BadResource)) {
                    throw error9;
                }
            }
        }
        this.#httpConnections.clear();
    }
    listen() {
        return this.#listener = isListenTlsOptions(this.#options) ? Deno.listenTls(this.#options) : Deno.listen(this.#options);
    }
     #trackHttpConnection(httpConn) {
        this.#httpConnections.add(httpConn);
    }
     #untrackHttpConnection(httpConn1) {
        this.#httpConnections.delete(httpConn1);
    }
    [Symbol.asyncIterator]() {
        const start = (controller)=>{
            const server = this;
            async function serve1(conn) {
                const httpConn2 = serveHttp(conn);
                server.#trackHttpConnection(httpConn2);
                while(true){
                    try {
                        const requestEvent = await httpConn2.nextRequest();
                        if (requestEvent === null) {
                            return;
                        }
                        const nativeRequest = new NativeRequest(requestEvent, {
                            conn
                        });
                        controller.enqueue(nativeRequest);
                        nativeRequest.donePromise.catch((error10)=>{
                            server.app.dispatchEvent(new ErrorEvent("error", {
                                error: error10
                            }));
                        });
                    } catch (error11) {
                        server.app.dispatchEvent(new ErrorEvent("error", {
                            error: error11
                        }));
                    }
                    if (server.closed) {
                        server.#untrackHttpConnection(httpConn2);
                        httpConn2.close();
                        controller.close();
                    }
                }
            }
            const listener = this.#listener;
            assert4(listener);
            async function accept() {
                while(true){
                    try {
                        const conn = await listener.accept();
                        serve1(conn);
                    } catch (error12) {
                        if (!server.closed) {
                            server.app.dispatchEvent(new ErrorEvent("error", {
                                error: error12
                            }));
                        }
                    }
                    if (server.closed) {
                        controller.close();
                        return;
                    }
                }
            }
            accept();
        };
        const stream = new ReadableStream({
            start
        });
        return stream[Symbol.asyncIterator]();
    }
}
async function compare(a13, b17) {
    const key40 = new Uint8Array(32);
    globalThis.crypto.getRandomValues(key40);
    const cryptoKey = await importKey(key40);
    const ah = await sign(a13, cryptoKey);
    const bh = await sign(b17, cryptoKey);
    return timingSafeEqual1(ah, bh);
}
class KeyStack {
    #cryptoKeys = new Map();
    #keys;
    async #toCryptoKey(key41) {
        if (!this.#cryptoKeys.has(key41)) {
            this.#cryptoKeys.set(key41, await importKey(key41));
        }
        return this.#cryptoKeys.get(key41);
    }
    get length() {
        return this.#keys.length;
    }
    constructor(keys){
        if (!(0 in keys)) {
            throw new TypeError("keys must contain at least one value");
        }
        this.#keys = keys;
    }
    async sign(data) {
        const key1 = await this.#toCryptoKey(this.#keys[0]);
        return encodeBase64Safe(await sign(data, key1));
    }
    async verify(data, digest2) {
        return await this.indexOf(data, digest2) > -1;
    }
    async indexOf(data, digest3) {
        for(let i71 = 0; i71 < this.#keys.length; i71++){
            const cryptoKey = await this.#toCryptoKey(this.#keys[i71]);
            if (await compare(digest3, encodeBase64Safe(await sign(data, cryptoKey)))) {
                return i71;
            }
        }
        return -1;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { length  } = this;
        return `${this.constructor.name} ${inspect({
            length
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        const { length  } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            length
        }, newOptions)}`;
    }
}
function compose(middleware1) {
    return function composedMiddleware(context, next) {
        let index = -1;
        async function dispatch(i72) {
            if (i72 <= index) {
                throw new Error("next() called multiple times.");
            }
            index = i72;
            let fn = middleware1[i72];
            if (i72 === middleware1.length) {
                fn = next;
            }
            if (!fn) {
                return;
            }
            await fn(context, dispatch.bind(null, i72 + 1));
        }
        return dispatch(0);
    };
}
const objectCloneMemo = new WeakMap();
function cloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, _cloneConstructor) {
    return srcBuffer.slice(srcByteOffset, srcByteOffset + srcLength);
}
function cloneValue(value60) {
    switch(typeof value60){
        case "number":
        case "string":
        case "boolean":
        case "undefined":
        case "bigint":
            return value60;
        case "object":
            {
                if (objectCloneMemo.has(value60)) {
                    return objectCloneMemo.get(value60);
                }
                if (value60 === null) {
                    return value60;
                }
                if (value60 instanceof Date) {
                    return new Date(value60.valueOf());
                }
                if (value60 instanceof RegExp) {
                    return new RegExp(value60);
                }
                if (value60 instanceof SharedArrayBuffer) {
                    return value60;
                }
                if (value60 instanceof ArrayBuffer) {
                    const cloned = cloneArrayBuffer(value60, 0, value60.byteLength, ArrayBuffer);
                    objectCloneMemo.set(value60, cloned);
                    return cloned;
                }
                if (ArrayBuffer.isView(value60)) {
                    const clonedBuffer = cloneValue(value60.buffer);
                    let length;
                    if (value60 instanceof DataView) {
                        length = value60.byteLength;
                    } else {
                        length = value60.length;
                    }
                    return new value60.constructor(clonedBuffer, value60.byteOffset, length);
                }
                if (value60 instanceof Map) {
                    const clonedMap = new Map();
                    objectCloneMemo.set(value60, clonedMap);
                    value60.forEach((v11, k2)=>{
                        clonedMap.set(cloneValue(k2), cloneValue(v11));
                    });
                    return clonedMap;
                }
                if (value60 instanceof Set) {
                    const clonedSet = new Set([
                        ...value60
                    ].map(cloneValue));
                    objectCloneMemo.set(value60, clonedSet);
                    return clonedSet;
                }
                const clonedObj = {};
                objectCloneMemo.set(value60, clonedObj);
                const sourceKeys = Object.getOwnPropertyNames(value60);
                for (const key42 of sourceKeys){
                    clonedObj[key42] = cloneValue(value60[key42]);
                }
                Reflect.setPrototypeOf(clonedObj, Reflect.getPrototypeOf(value60));
                return clonedObj;
            }
        case "symbol":
        case "function":
        default:
            throw new DOMException("Uncloneable value in stream", "DataCloneError");
    }
}
const core = Deno?.core;
const structuredClone = globalThis.structuredClone;
function sc(value61) {
    return structuredClone ? structuredClone(value61) : core ? core.deserialize(core.serialize(value61)) : cloneValue(value61);
}
function cloneState(state5) {
    const clone = {};
    for (const [key43, value62] of Object.entries(state5)){
        try {
            const clonedValue = sc(value62);
            clone[key43] = clonedValue;
        } catch  {}
    }
    return clone;
}
const ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
class ApplicationErrorEvent extends ErrorEvent {
    context;
    constructor(eventInitDict){
        super("error", eventInitDict);
        this.context = eventInitDict.context;
    }
}
function logErrorListener({ error: error13 , context  }) {
    if (error13 instanceof Error) {
        console.error(`[uncaught application error]: ${error13.name} - ${error13.message}`);
    } else {
        console.error(`[uncaught application error]\n`, error13);
    }
    if (context) {
        let url;
        try {
            url = context.request.url.toString();
        } catch  {
            url = "[malformed url]";
        }
        console.error(`\nrequest:`, {
            url,
            method: context.request.method,
            hasBody: context.request.hasBody
        });
        console.error(`response:`, {
            status: context.response.status,
            type: context.response.type,
            hasBody: !!context.response.body,
            writable: context.response.writable
        });
    }
    if (error13 instanceof Error && error13.stack) {
        console.error(`\n${error13.stack.split("\n").slice(1).join("\n")}`);
    }
}
class ApplicationListenEvent extends Event {
    hostname;
    listener;
    port;
    secure;
    serverType;
    constructor(eventInitDict){
        super("listen", eventInitDict);
        this.hostname = eventInitDict.hostname;
        this.listener = eventInitDict.listener;
        this.port = eventInitDict.port;
        this.secure = eventInitDict.secure;
        this.serverType = eventInitDict.serverType;
    }
}
class Application extends EventTarget {
    #composedMiddleware;
    #contextOptions;
    #contextState;
    #keys;
    #middleware = [];
    #serverConstructor;
    get keys() {
        return this.#keys;
    }
    set keys(keys) {
        if (!keys) {
            this.#keys = undefined;
            return;
        } else if (Array.isArray(keys)) {
            this.#keys = new KeyStack(keys);
        } else {
            this.#keys = keys;
        }
    }
    proxy;
    state;
    constructor(options = {}){
        super();
        const { state: state6 , keys , proxy: proxy3 , serverConstructor =HttpServer , contextState ="clone" , logErrors =true , ...contextOptions } = options;
        this.proxy = proxy3 ?? false;
        this.keys = keys;
        this.state = state6 ?? {};
        this.#serverConstructor = serverConstructor;
        this.#contextOptions = contextOptions;
        this.#contextState = contextState;
        if (logErrors) {
            this.addEventListener("error", logErrorListener);
        }
    }
     #getComposed() {
        if (!this.#composedMiddleware) {
            this.#composedMiddleware = compose(this.#middleware);
        }
        return this.#composedMiddleware;
    }
     #getContextState() {
        switch(this.#contextState){
            case "alias":
                return this.state;
            case "clone":
                return cloneState(this.state);
            case "empty":
                return {};
            case "prototype":
                return Object.create(this.state);
        }
    }
     #handleError(context, error14) {
        if (!(error14 instanceof Error)) {
            error14 = new Error(`non-error thrown: ${JSON.stringify(error14)}`);
        }
        const { message  } = error14;
        this.dispatchEvent(new ApplicationErrorEvent({
            context,
            message,
            error: error14
        }));
        if (!context.response.writable) {
            return;
        }
        for (const key of [
            ...context.response.headers.keys()
        ]){
            context.response.headers.delete(key);
        }
        if (error14.headers && error14.headers instanceof Headers) {
            for (const [key, value] of error14.headers){
                context.response.headers.set(key, value);
            }
        }
        context.response.type = "text";
        const status = context.response.status = Deno.errors && error14 instanceof Deno.errors.NotFound ? 404 : error14.status && typeof error14.status === "number" ? error14.status : 500;
        context.response.body = error14.expose ? error14.message : STATUS_TEXT[status];
    }
    async #handleRequest(request, secure, state7) {
        const context = new Context(this, request, this.#getContextState(), {
            secure,
            ...this.#contextOptions
        });
        let resolve;
        const handlingPromise = new Promise((res)=>resolve = res);
        state7.handling.add(handlingPromise);
        if (!state7.closing && !state7.closed) {
            try {
                await this.#getComposed()(context);
            } catch (err) {
                this.#handleError(context, err);
            }
        }
        if (context.respond === false) {
            context.response.destroy();
            resolve();
            state7.handling.delete(handlingPromise);
            return;
        }
        let closeResources = true;
        let response;
        try {
            closeResources = false;
            response = await context.response.toDomResponse();
        } catch (err) {
            this.#handleError(context, err);
            response = await context.response.toDomResponse();
        }
        assert4(response);
        try {
            await request.respond(response);
        } catch (err1) {
            this.#handleError(context, err1);
        } finally{
            context.response.destroy(closeResources);
            resolve();
            state7.handling.delete(handlingPromise);
            if (state7.closing) {
                await state7.server.close();
                state7.closed = true;
            }
        }
    }
    addEventListener(type8, listener, options) {
        super.addEventListener(type8, listener, options);
    }
    handle = async (request1, secureOrConn, secure1 = false)=>{
        if (!this.#middleware.length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        assert4(isConn(secureOrConn) || typeof secureOrConn === "undefined");
        const contextRequest = new NativeRequest({
            request: request1,
            respondWith () {
                return Promise.resolve(undefined);
            }
        }, {
            conn: secureOrConn
        });
        const context1 = new Context(this, contextRequest, this.#getContextState(), {
            secure: secure1,
            ...this.#contextOptions
        });
        try {
            await this.#getComposed()(context1);
        } catch (err) {
            this.#handleError(context1, err);
        }
        if (context1.respond === false) {
            context1.response.destroy();
            return;
        }
        try {
            const response = await context1.response.toDomResponse();
            context1.response.destroy(false);
            return response;
        } catch (err2) {
            this.#handleError(context1, err2);
            throw err2;
        }
    };
    async listen(options = {
        port: 0
    }) {
        if (!this.#middleware.length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        if (typeof options === "string") {
            const match = ADDR_REGEXP.exec(options);
            if (!match) {
                throw TypeError(`Invalid address passed: "${options}"`);
            }
            const [, hostname3, portStr] = match;
            options = {
                hostname: hostname3,
                port: parseInt(portStr, 10)
            };
        }
        options = Object.assign({
            port: 0
        }, options);
        const server = new this.#serverConstructor(this, options);
        const { signal  } = options;
        const state1 = {
            closed: false,
            closing: false,
            handling: new Set(),
            server
        };
        if (signal) {
            signal.addEventListener("abort", ()=>{
                if (!state1.handling.size) {
                    server.close();
                    state1.closed = true;
                }
                state1.closing = true;
            });
        }
        const { secure: secure2 = false  } = options;
        const serverType = server instanceof HttpServer ? "native" : server instanceof FlashServer ? "flash" : "custom";
        const listener = await server.listen();
        const { hostname: hostname4 , port: port1  } = listener.addr;
        this.dispatchEvent(new ApplicationListenEvent({
            hostname: hostname4,
            listener,
            port: port1,
            secure: secure2,
            serverType
        }));
        try {
            for await (const request2 of server){
                this.#handleRequest(request2, secure2, state1);
            }
            await Promise.all(state1.handling);
        } catch (error1) {
            const message = error1 instanceof Error ? error1.message : "Application Error";
            this.dispatchEvent(new ApplicationErrorEvent({
                message,
                error: error1
            }));
        }
    }
    use(...middleware2) {
        this.#middleware.push(...middleware2);
        this.#composedMiddleware = undefined;
        return this;
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        const { keys , proxy: proxy4 , state: state2  } = this;
        return `${this.constructor.name} ${inspect({
            "#middleware": this.#middleware,
            keys,
            proxy: proxy4,
            state: state2
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        const { keys , proxy: proxy5 , state: state3  } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            "#middleware": this.#middleware,
            keys,
            proxy: proxy5,
            state: state3
        }, newOptions)}`;
    }
}
function getQuery(ctx, { mergeParams , asMap  } = {}) {
    const result = {};
    if (mergeParams && isRouterContext(ctx)) {
        Object.assign(result, ctx.params);
    }
    for (const [key44, value63] of ctx.request.url.searchParams){
        result[key44] = value63;
    }
    return asMap ? new Map(Object.entries(result)) : result;
}
const mod10 = {
    getQuery: getQuery
};
const FORWARDED_RE = /^(,[ \\t]*)*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*([ \\t]*,([ \\t]*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*)?)*$/;
function createMatcher({ match  }) {
    return function matches(ctx) {
        if (!match) {
            return true;
        }
        if (typeof match === "string") {
            return ctx.request.url.pathname.startsWith(match);
        }
        if (match instanceof RegExp) {
            return match.test(ctx.request.url.pathname);
        }
        return match(ctx);
    };
}
async function createRequest(target, ctx, { headers: optHeaders , map , proxyHeaders =true , request: reqFn  }) {
    let path70 = ctx.request.url.pathname;
    let params;
    if (isRouterContext(ctx)) {
        params = ctx.params;
    }
    if (map && typeof map === "function") {
        path70 = map(path70, params);
    } else if (map) {
        path70 = map[path70] ?? path70;
    }
    const url = new URL(String(target));
    if (url.pathname.endsWith("/") && path70.startsWith("/")) {
        url.pathname = `${url.pathname}${path70.slice(1)}`;
    } else if (!url.pathname.endsWith("/") && !path70.startsWith("/")) {
        url.pathname = `${url.pathname}/${path70}`;
    } else {
        url.pathname = `${url.pathname}${path70}`;
    }
    url.search = ctx.request.url.search;
    const body = getBodyInit(ctx);
    const headers = new Headers(ctx.request.headers);
    if (optHeaders) {
        if (typeof optHeaders === "function") {
            optHeaders = await optHeaders(ctx);
        }
        for (const [key45, value64] of iterableHeaders(optHeaders)){
            headers.set(key45, value64);
        }
    }
    if (proxyHeaders) {
        const maybeForwarded = headers.get("forwarded");
        const ip = ctx.request.ip.startsWith("[") ? `"${ctx.request.ip}"` : ctx.request.ip;
        const host = headers.get("host");
        if (maybeForwarded && FORWARDED_RE.test(maybeForwarded)) {
            let value65 = `for=${ip}`;
            if (host) {
                value65 += `;host=${host}`;
            }
            headers.append("forwarded", value65);
        } else {
            headers.append("x-forwarded-for", ip);
            if (host) {
                headers.append("x-forwarded-host", host);
            }
        }
    }
    const init = {
        body,
        headers,
        method: ctx.request.method,
        redirect: "follow"
    };
    let request3 = new Request(url.toString(), init);
    if (reqFn) {
        request3 = await reqFn(request3);
    }
    return request3;
}
function getBodyInit(ctx) {
    if (!ctx.request.hasBody) {
        return null;
    }
    return ctx.request.body({
        type: "stream"
    }).value;
}
function iterableHeaders(headers) {
    if (headers instanceof Headers) {
        return headers.entries();
    } else if (Array.isArray(headers)) {
        return headers.values();
    } else {
        return Object.entries(headers).values();
    }
}
async function processResponse(response, ctx, { contentType: contentTypeFn , response: resFn  }) {
    if (resFn) {
        response = await resFn(response);
    }
    if (response.body) {
        ctx.response.body = response.body;
    } else {
        ctx.response.body = null;
    }
    ctx.response.status = response.status;
    for (const [key46, value66] of response.headers){
        ctx.response.headers.append(key46, value66);
    }
    if (contentTypeFn) {
        const value67 = await contentTypeFn(response.url, ctx.response.headers.get("content-type") ?? undefined);
        if (value67 != null) {
            ctx.response.headers.set("content-type", value67);
        }
    }
}
function proxy(target, options = {}) {
    const matches = createMatcher(options);
    return async function proxy(ctx, next) {
        if (!matches(ctx)) {
            return next();
        }
        const request4 = await createRequest(target, ctx, options);
        const { fetch =globalThis.fetch  } = options;
        const response = await fetch(request4);
        await processResponse(response, ctx, options);
        return next();
    };
}
function toUrl(url, params = {}, options) {
    const tokens = parse7(url);
    let replace = {};
    if (tokens.some((token)=>typeof token === "object")) {
        replace = params;
    } else {
        options = params;
    }
    const toPath = compile(url, options);
    const replaced = toPath(replace);
    if (options && options.query) {
        const url = new URL(replaced, "http://oak");
        if (typeof options.query === "string") {
            url.search = options.query;
        } else {
            url.search = String(options.query instanceof URLSearchParams ? options.query : new URLSearchParams(options.query));
        }
        return `${url.pathname}${url.search}${url.hash}`;
    }
    return replaced;
}
class Layer {
    #opts;
    #paramNames = [];
    #regexp;
    methods;
    name;
    path;
    stack;
    constructor(path71, methods, middleware3, { name , ...opts } = {}){
        this.#opts = opts;
        this.name = name;
        this.methods = [
            ...methods
        ];
        if (this.methods.includes("GET")) {
            this.methods.unshift("HEAD");
        }
        this.stack = Array.isArray(middleware3) ? middleware3.slice() : [
            middleware3
        ];
        this.path = path71;
        this.#regexp = pathToRegexp(path71, this.#paramNames, this.#opts);
    }
    clone() {
        return new Layer(this.path, this.methods, this.stack, {
            name: this.name,
            ...this.#opts
        });
    }
    match(path72) {
        return this.#regexp.test(path72);
    }
    params(captures, existingParams = {}) {
        const params = existingParams;
        for(let i73 = 0; i73 < captures.length; i73++){
            if (this.#paramNames[i73]) {
                const c13 = captures[i73];
                params[this.#paramNames[i73].name] = c13 ? decodeComponent(c13) : c13;
            }
        }
        return params;
    }
    captures(path73) {
        if (this.#opts.ignoreCaptures) {
            return [];
        }
        return path73.match(this.#regexp)?.slice(1) ?? [];
    }
    url(params = {}, options) {
        const url = this.path.replace(/\(\.\*\)/g, "");
        return toUrl(url, params, options);
    }
    param(param, fn) {
        const stack = this.stack;
        const params = this.#paramNames;
        const middleware4 = function(ctx, next) {
            const p24 = ctx.params[param];
            assert4(p24);
            return fn.call(this, p24, ctx, next);
        };
        middleware4.param = param;
        const names = params.map((p25)=>p25.name);
        const x10 = names.indexOf(param);
        if (x10 >= 0) {
            for(let i74 = 0; i74 < stack.length; i74++){
                const fn = stack[i74];
                if (!fn.param || names.indexOf(fn.param) > x10) {
                    stack.splice(i74, 0, middleware4);
                    break;
                }
            }
        }
        return this;
    }
    setPrefix(prefix) {
        if (this.path) {
            this.path = this.path !== "/" || this.#opts.strict === true ? `${prefix}${this.path}` : prefix;
            this.#paramNames = [];
            this.#regexp = pathToRegexp(this.path, this.#paramNames, this.#opts);
        }
        return this;
    }
    toJSON() {
        return {
            methods: [
                ...this.methods
            ],
            middleware: [
                ...this.stack
            ],
            paramNames: this.#paramNames.map((key47)=>key47.name),
            path: this.path,
            regexp: this.#regexp,
            options: {
                ...this.#opts
            }
        };
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({
            methods: this.methods,
            middleware: this.stack,
            options: this.#opts,
            paramNames: this.#paramNames.map((key48)=>key48.name),
            path: this.path,
            regexp: this.#regexp
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            methods: this.methods,
            middleware: this.stack,
            options: this.#opts,
            paramNames: this.#paramNames.map((key49)=>key49.name),
            path: this.path,
            regexp: this.#regexp
        }, newOptions)}`;
    }
}
class Router {
    #opts;
    #methods;
    #params = {};
    #stack = [];
     #match(path74, method) {
        const matches = {
            path: [],
            pathAndMethod: [],
            route: false
        };
        for (const route of this.#stack){
            if (route.match(path74)) {
                matches.path.push(route);
                if (route.methods.length === 0 || route.methods.includes(method)) {
                    matches.pathAndMethod.push(route);
                    if (route.methods.length) {
                        matches.route = true;
                    }
                }
            }
        }
        return matches;
    }
     #register(path111, middlewares, methods, options = {}) {
        if (Array.isArray(path111)) {
            for (const p of path111){
                this.#register(p, middlewares, methods, options);
            }
            return;
        }
        let layerMiddlewares = [];
        for (const middleware of middlewares){
            if (!middleware.router) {
                layerMiddlewares.push(middleware);
                continue;
            }
            if (layerMiddlewares.length) {
                this.#addLayer(path111, layerMiddlewares, methods, options);
                layerMiddlewares = [];
            }
            const router = middleware.router.#clone();
            for (const layer of router.#stack){
                if (!options.ignorePrefix) {
                    layer.setPrefix(path111);
                }
                if (this.#opts.prefix) {
                    layer.setPrefix(this.#opts.prefix);
                }
                this.#stack.push(layer);
            }
            for (const [param, mw] of Object.entries(this.#params)){
                router.param(param, mw);
            }
        }
        if (layerMiddlewares.length) {
            this.#addLayer(path111, layerMiddlewares, methods, options);
        }
    }
     #addLayer(path210, middlewares1, methods1, options1 = {}) {
        const { end , name , sensitive =this.#opts.sensitive , strict =this.#opts.strict , ignoreCaptures ,  } = options1;
        const route = new Layer(path210, methods1, middlewares1, {
            end,
            name,
            sensitive,
            strict,
            ignoreCaptures
        });
        if (this.#opts.prefix) {
            route.setPrefix(this.#opts.prefix);
        }
        for (const [param, mw] of Object.entries(this.#params)){
            route.param(param, mw);
        }
        this.#stack.push(route);
    }
     #route(name) {
        for (const route of this.#stack){
            if (route.name === name) {
                return route;
            }
        }
    }
     #useVerb(nameOrPath, pathOrMiddleware, middleware5, methods2) {
        let name = undefined;
        let path;
        if (typeof pathOrMiddleware === "string") {
            name = nameOrPath;
            path = pathOrMiddleware;
        } else {
            path = nameOrPath;
            middleware5.unshift(pathOrMiddleware);
        }
        this.#register(path, middleware5, methods2, {
            name
        });
    }
     #clone() {
        const router = new Router(this.#opts);
        router.#methods = router.#methods.slice();
        router.#params = {
            ...this.#params
        };
        router.#stack = this.#stack.map((layer)=>layer.clone());
        return router;
    }
    constructor(opts = {}){
        this.#opts = opts;
        this.#methods = opts.methods ?? [
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT", 
        ];
    }
    all(nameOrPath1, pathOrMiddleware1, ...middleware1) {
        this.#useVerb(nameOrPath1, pathOrMiddleware1, middleware1, [
            "DELETE",
            "GET",
            "POST",
            "PUT"
        ]);
        return this;
    }
    allowedMethods(options2 = {}) {
        const implemented = this.#methods;
        const allowedMethods = async (context2, next)=>{
            const ctx = context2;
            await next();
            if (!ctx.response.status || ctx.response.status === Status.NotFound) {
                assert4(ctx.matched);
                const allowed = new Set();
                for (const route of ctx.matched){
                    for (const method1 of route.methods){
                        allowed.add(method1);
                    }
                }
                const allowedStr = [
                    ...allowed
                ].join(", ");
                if (!implemented.includes(ctx.request.method)) {
                    if (options2.throw) {
                        throw options2.notImplemented ? options2.notImplemented() : new errors.NotImplemented();
                    } else {
                        ctx.response.status = Status.NotImplemented;
                        ctx.response.headers.set("Allowed", allowedStr);
                    }
                } else if (allowed.size) {
                    if (ctx.request.method === "OPTIONS") {
                        ctx.response.status = Status.OK;
                        ctx.response.headers.set("Allowed", allowedStr);
                    } else if (!allowed.has(ctx.request.method)) {
                        if (options2.throw) {
                            throw options2.methodNotAllowed ? options2.methodNotAllowed() : new errors.MethodNotAllowed();
                        } else {
                            ctx.response.status = Status.MethodNotAllowed;
                            ctx.response.headers.set("Allowed", allowedStr);
                        }
                    }
                }
            }
        };
        return allowedMethods;
    }
    delete(nameOrPath2, pathOrMiddleware2, ...middleware2) {
        this.#useVerb(nameOrPath2, pathOrMiddleware2, middleware2, [
            "DELETE"
        ]);
        return this;
    }
    *entries() {
        for (const route of this.#stack){
            const value68 = route.toJSON();
            yield [
                value68,
                value68
            ];
        }
    }
    forEach(callback, thisArg = null) {
        for (const route of this.#stack){
            const value69 = route.toJSON();
            callback.call(thisArg, value69, value69, this);
        }
    }
    get(nameOrPath3, pathOrMiddleware3, ...middleware3) {
        this.#useVerb(nameOrPath3, pathOrMiddleware3, middleware3, [
            "GET"
        ]);
        return this;
    }
    head(nameOrPath4, pathOrMiddleware4, ...middleware4) {
        this.#useVerb(nameOrPath4, pathOrMiddleware4, middleware4, [
            "HEAD"
        ]);
        return this;
    }
    *keys() {
        for (const route of this.#stack){
            yield route.toJSON();
        }
    }
    options(nameOrPath5, pathOrMiddleware5, ...middleware5) {
        this.#useVerb(nameOrPath5, pathOrMiddleware5, middleware5, [
            "OPTIONS"
        ]);
        return this;
    }
    param(param, middleware6) {
        this.#params[param] = middleware6;
        for (const route of this.#stack){
            route.param(param, middleware6);
        }
        return this;
    }
    patch(nameOrPath6, pathOrMiddleware6, ...middleware7) {
        this.#useVerb(nameOrPath6, pathOrMiddleware6, middleware7, [
            "PATCH"
        ]);
        return this;
    }
    post(nameOrPath7, pathOrMiddleware7, ...middleware8) {
        this.#useVerb(nameOrPath7, pathOrMiddleware7, middleware8, [
            "POST"
        ]);
        return this;
    }
    prefix(prefix) {
        prefix = prefix.replace(/\/$/, "");
        this.#opts.prefix = prefix;
        for (const route of this.#stack){
            route.setPrefix(prefix);
        }
        return this;
    }
    put(nameOrPath8, pathOrMiddleware8, ...middleware9) {
        this.#useVerb(nameOrPath8, pathOrMiddleware8, middleware9, [
            "PUT"
        ]);
        return this;
    }
    redirect(source, destination, status = Status.Found) {
        if (source[0] !== "/") {
            const s15 = this.url(source);
            if (!s15) {
                throw new RangeError(`Could not resolve named route: "${source}"`);
            }
            source = s15;
        }
        if (typeof destination === "string") {
            if (destination[0] !== "/") {
                const d3 = this.url(destination);
                if (!d3) {
                    try {
                        const url = new URL(destination);
                        destination = url;
                    } catch  {
                        throw new RangeError(`Could not resolve named route: "${source}"`);
                    }
                } else {
                    destination = d3;
                }
            }
        }
        this.all(source, async (ctx, next)=>{
            await next();
            ctx.response.redirect(destination);
            ctx.response.status = status;
        });
        return this;
    }
    routes() {
        const dispatch = (context3, next1)=>{
            const ctx1 = context3;
            let pathname;
            let method2;
            try {
                const { url: { pathname: p26  } , method: m7  } = ctx1.request;
                pathname = p26;
                method2 = m7;
            } catch (e19) {
                return Promise.reject(e19);
            }
            const path310 = (this.#opts.routerPath ?? ctx1.routerPath) ?? decodeURI(pathname);
            const matches = this.#match(path310, method2);
            if (ctx1.matched) {
                ctx1.matched.push(...matches.path);
            } else {
                ctx1.matched = [
                    ...matches.path
                ];
            }
            ctx1.router = this;
            if (!matches.route) return next1();
            const { pathAndMethod: matchedRoutes  } = matches;
            const chain = matchedRoutes.reduce((prev, route)=>[
                    ...prev,
                    (ctx, next)=>{
                        ctx.captures = route.captures(path310);
                        ctx.params = route.params(ctx.captures, ctx.params);
                        ctx.routeName = route.name;
                        return next();
                    },
                    ...route.stack, 
                ], []);
            return compose(chain)(ctx1, next1);
        };
        dispatch.router = this;
        return dispatch;
    }
    url(name1, params, options3) {
        const route = this.#route(name1);
        if (route) {
            return route.url(params, options3);
        }
    }
    use(pathOrMiddleware9, ...middleware10) {
        let path4;
        if (typeof pathOrMiddleware9 === "string" || Array.isArray(pathOrMiddleware9)) {
            path4 = pathOrMiddleware9;
        } else {
            middleware10.unshift(pathOrMiddleware9);
        }
        this.#register(path4 ?? "(.*)", middleware10, [], {
            end: false,
            ignoreCaptures: !path4,
            ignorePrefix: !path4
        });
        return this;
    }
    *values() {
        for (const route of this.#stack){
            yield route.toJSON();
        }
    }
    *[Symbol.iterator]() {
        for (const route of this.#stack){
            yield route.toJSON();
        }
    }
    static url(path5, params, options4) {
        return toUrl(path5, params, options4);
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({
            "#params": this.#params,
            "#stack": this.#stack
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options5, inspect) {
        if (depth < 0) {
            return options5.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options5, {
            depth: options5.depth === null ? null : options5.depth - 1
        });
        return `${options5.stylize(this.constructor.name, "special")} ${inspect({
            "#params": this.#params,
            "#stack": this.#stack
        }, newOptions)}`;
    }
}
function createMockApp(state8 = {}) {
    const app6 = {
        state: state8,
        use () {
            return app6;
        },
        [Symbol.for("Deno.customInspect")] () {
            return "MockApplication {}";
        },
        [Symbol.for("nodejs.util.inspect.custom")] (depth, options6, inspect) {
            if (depth < 0) {
                return options6.stylize(`[MockApplication]`, "special");
            }
            const newOptions = Object.assign({}, options6, {
                depth: options6.depth === null ? null : options6.depth - 1
            });
            return `${options6.stylize("MockApplication", "special")} ${inspect({}, newOptions)}`;
        }
    };
    return app6;
}
const mockContextState = {
    encodingsAccepted: "identity"
};
function createMockContext({ ip ="127.0.0.1" , method: method3 = "GET" , params , path: path75 = "/" , state: state9 , app: app7 = createMockApp(state9) , headers: requestHeaders  } = {}) {
    function createMockRequest() {
        const headers = new Headers(requestHeaders);
        return {
            accepts (...types4) {
                if (!headers.has("Accept")) {
                    return;
                }
                if (types4.length) {
                    return accepts({
                        headers
                    }, ...types4);
                }
                return accepts({
                    headers
                });
            },
            acceptsEncodings () {
                return mockContextState.encodingsAccepted;
            },
            headers,
            ip,
            method: method3,
            path: path75,
            search: undefined,
            searchParams: new URLSearchParams(),
            url: new URL(path75, "http://localhost/")
        };
    }
    const request5 = createMockRequest();
    const response = new Response1(request5);
    const cookies = new Cookies(request5, response);
    return {
        app: app7,
        params,
        request: request5,
        cookies,
        response,
        state: Object.assign({}, app7.state),
        assert (condition, errorStatus = 500, message, props) {
            if (condition) {
                return;
            }
            const err = createHttpError(errorStatus, message);
            if (props) {
                Object.assign(err, props);
            }
            throw err;
        },
        throw (errorStatus, message, props) {
            const err = createHttpError(errorStatus, message);
            if (props) {
                Object.assign(err, props);
            }
            throw err;
        },
        [Symbol.for("Deno.customInspect")] () {
            return `MockContext {}`;
        },
        [Symbol.for("nodejs.util.inspect.custom")] (depth, options7, inspect) {
            if (depth < 0) {
                return options7.stylize(`[MockContext]`, "special");
            }
            const newOptions = Object.assign({}, options7, {
                depth: options7.depth === null ? null : options7.depth - 1
            });
            return `${options7.stylize("MockContext", "special")} ${inspect({}, newOptions)}`;
        }
    };
}
function createMockNext() {
    return async function next() {};
}
const mod11 = {
    createMockApp: createMockApp,
    mockContextState: mockContextState,
    createMockContext: createMockContext,
    createMockNext: createMockNext
};
const mod12 = {
    Application: Application,
    Context: Context,
    Cookies: Cookies,
    HttpRequest: HttpRequest,
    FlashServer: FlashServer,
    hasFlash: hasFlash,
    HttpServerNative: HttpServer,
    proxy: proxy,
    composeMiddleware: compose,
    FormDataReader: FormDataReader,
    ifRange: ifRange,
    MultiPartStream: MultiPartStream,
    parseRange: parseRange,
    Request: Request1,
    REDIRECT_BACK: REDIRECT_BACK,
    Response: Response1,
    Router: Router,
    send: send,
    ServerSentEvent: ServerSentEvent,
    isErrorStatus: isErrorStatus,
    isRedirectStatus: isRedirectStatus,
    createHttpError: createHttpError,
    httpErrors: errors,
    HttpError: HttpError,
    isHttpError: isHttpError,
    Status: Status,
    STATUS_TEXT: STATUS_TEXT,
    helpers: mod10,
    etag: mod9,
    testing: mod11
};
const random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
const urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
const nanoid = (size = 21)=>{
    let id = "";
    const bytes = random(size);
    while(size--)id += urlAlphabet[bytes[size] & 63];
    return id;
};
function isHashedKeyAlgorithm(algorithm) {
    return typeof algorithm.hash?.name === "string";
}
function isEcKeyAlgorithm(algorithm) {
    return typeof algorithm.namedCurve === "string";
}
function verify(alg, key50) {
    if (alg === "none") {
        if (key50 !== null) throw new Error(`The alg '${alg}' does not allow a key.`);
        else return true;
    } else {
        if (!key50) throw new Error(`The alg '${alg}' demands a key.`);
        const keyAlgorithm = key50.algorithm;
        const algAlgorithm = getAlgorithm(alg);
        if (keyAlgorithm.name === algAlgorithm.name) {
            if (isHashedKeyAlgorithm(keyAlgorithm)) {
                return keyAlgorithm.hash.name === algAlgorithm.hash.name;
            } else if (isEcKeyAlgorithm(keyAlgorithm)) {
                return keyAlgorithm.namedCurve === algAlgorithm.namedCurve;
            }
        }
        return false;
    }
}
function getAlgorithm(alg) {
    switch(alg){
        case "HS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "HMAC"
            };
        case "HS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "HMAC"
            };
        case "HS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "HMAC"
            };
        case "PS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "RSA-PSS",
                saltLength: 256 >> 3
            };
        case "PS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "RSA-PSS",
                saltLength: 384 >> 3
            };
        case "PS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "RSA-PSS",
                saltLength: 512 >> 3
            };
        case "RS256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        case "RS384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        case "RS512":
            return {
                hash: {
                    name: "SHA-512"
                },
                name: "RSASSA-PKCS1-v1_5"
            };
        case "ES256":
            return {
                hash: {
                    name: "SHA-256"
                },
                name: "ECDSA",
                namedCurve: "P-256"
            };
        case "ES384":
            return {
                hash: {
                    name: "SHA-384"
                },
                name: "ECDSA",
                namedCurve: "P-384"
            };
        default:
            throw new Error(`The jwt's alg '${alg}' is not supported.`);
    }
}
const base64abc2 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode2(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i75;
    const l3 = uint8.length;
    for(i75 = 2; i75 < l3; i75 += 3){
        result += base64abc2[uint8[i75 - 2] >> 2];
        result += base64abc2[(uint8[i75 - 2] & 0x03) << 4 | uint8[i75 - 1] >> 4];
        result += base64abc2[(uint8[i75 - 1] & 0x0f) << 2 | uint8[i75] >> 6];
        result += base64abc2[uint8[i75] & 0x3f];
    }
    if (i75 === l3 + 1) {
        result += base64abc2[uint8[i75 - 2] >> 2];
        result += base64abc2[(uint8[i75 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i75 === l3) {
        result += base64abc2[uint8[i75 - 2] >> 2];
        result += base64abc2[(uint8[i75 - 2] & 0x03) << 4 | uint8[i75 - 1] >> 4];
        result += base64abc2[(uint8[i75 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode2(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i76 = 0; i76 < size; i76++){
        bytes[i76] = binString.charCodeAt(i76);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode3(data) {
    return convertBase64ToBase64url(encode2(data));
}
function decode3(b64url) {
    return decode2(convertBase64urlToBase64(b64url));
}
const mod13 = {
    addPaddingToBase64url: addPaddingToBase64url,
    encode: encode3,
    decode: decode3
};
const encoder5 = new TextEncoder();
async function verify1(signature, key51, alg, signingInput) {
    return key51 === null ? signature.length === 0 : await crypto.subtle.verify(getAlgorithm(alg), key51, signature, encoder5.encode(signingInput));
}
const decoder3 = new TextDecoder();
function isExpired(exp, leeway) {
    return exp + leeway < Date.now() / 1000;
}
function isTooEarly(nbf, leeway) {
    return nbf - leeway > Date.now() / 1000;
}
function isObject(obj) {
    return obj !== null && typeof obj === "object" && Array.isArray(obj) === false;
}
function is3Tuple(arr) {
    return arr.length === 3;
}
function hasInvalidTimingClaims(...claimValues) {
    return claimValues.some((claimValue)=>claimValue !== undefined ? typeof claimValue !== "number" : false);
}
function decode4(jwt) {
    try {
        const arr = jwt.split(".").map(mod13.decode).map((uint8Array, index)=>index === 0 || index === 1 ? JSON.parse(decoder3.decode(uint8Array)) : uint8Array);
        if (is3Tuple(arr)) return arr;
        else throw new Error();
    } catch  {
        throw Error("The serialization of the jwt is invalid.");
    }
}
function validate([header, payload1, signature], { expLeeway =1 , nbfLeeway =1  } = {}) {
    if (typeof header?.alg !== "string") {
        throw new Error(`The jwt's 'alg' header parameter value must be a string.`);
    }
    if (isObject(payload1)) {
        if (hasInvalidTimingClaims(payload1.exp, payload1.nbf)) {
            throw new Error(`The jwt has an invalid 'exp' or 'nbf' claim.`);
        }
        if (typeof payload1.exp === "number" && isExpired(payload1.exp, expLeeway)) {
            throw RangeError("The jwt is expired.");
        }
        if (typeof payload1.nbf === "number" && isTooEarly(payload1.nbf, nbfLeeway)) {
            throw RangeError("The jwt is used too early.");
        }
        return {
            header,
            payload: payload1,
            signature
        };
    } else {
        throw new Error(`The jwt claims set is not a JSON object.`);
    }
}
async function verify2(jwt, key52, options8) {
    const { header , payload: payload2 , signature  } = validate(decode4(jwt), options8);
    if (verify(header.alg, key52)) {
        if (!await verify1(signature, key52, header.alg, jwt.slice(0, jwt.lastIndexOf(".")))) {
            throw new Error("The jwt's signature does not match the verification signature.");
        }
        return payload2;
    } else {
        throw new Error(`The jwt's alg '${header.alg}' does not match the key's algorithm.`);
    }
}
function createSigningInput(header, payload3) {
    return `${mod13.encode(encoder5.encode(JSON.stringify(header)))}.${mod13.encode(encoder5.encode(JSON.stringify(payload3)))}`;
}
async function create(alg, key53, signingInput) {
    return key53 === null ? "" : mod13.encode(new Uint8Array(await crypto.subtle.sign(getAlgorithm(alg), key53, encoder5.encode(signingInput))));
}
async function create1(header, payload4, key54) {
    if (verify(header.alg, key54)) {
        const signingInput = createSigningInput(header, payload4);
        const signature = await create(header.alg, key54, signingInput);
        return `${signingInput}.${signature}`;
    } else {
        throw new Error(`The jwt's alg '${header.alg}' does not match the key's algorithm.`);
    }
}
function getNumericDate(exp) {
    return Math.round((exp instanceof Date ? exp.getTime() : Date.now() + exp * 1000) / 1000);
}
const mod14 = {
    encoder: encoder5,
    decoder: decoder3,
    decode: decode4,
    validate: validate,
    verify: verify2,
    create: create1,
    getNumericDate: getNumericDate
};
class DenoStdInternalError2 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert5(expr, msg21 = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg21);
    }
}
function copy3(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_READ1 = 32 * 1024;
const MAX_SIZE1 = 2 ** 32 - 2;
class Buffer1 {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options9 = {
        copy: true
    }) {
        if (options9.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n13) {
        if (n13 === 0) {
            this.reset();
            return;
        }
        if (n13 < 0 || n13 > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n13);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
     #tryGrowByReslice(n14) {
        const l = this.#buf.byteLength;
        if (n14 <= this.capacity - l) {
            this.#reslice(l + n14);
            return l;
        }
        return -1;
    }
     #reslice(len8) {
        assert5(len8 <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len8);
    }
    readSync(p27) {
        if (this.empty()) {
            this.reset();
            if (p27.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy3(this.#buf.subarray(this.#off), p27);
        this.#off += nread;
        return nread;
    }
    read(p28) {
        const rr = this.readSync(p28);
        return Promise.resolve(rr);
    }
    writeSync(p29) {
        const m8 = this.#grow(p29.byteLength);
        return copy3(p29, this.#buf, m8);
    }
    write(p30) {
        const n1 = this.writeSync(p30);
        return Promise.resolve(n1);
    }
     #grow(n21) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n21);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n21 <= Math.floor(c / 2) - m) {
            copy3(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n21 > MAX_SIZE1) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n21, MAX_SIZE1));
            copy3(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n21, MAX_SIZE1));
        return m;
    }
    grow(n3) {
        if (n3 < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m9 = this.#grow(n3);
        this.#reslice(m9);
    }
    async readFrom(r13) {
        let n4 = 0;
        const tmp = new Uint8Array(MIN_READ1);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ1;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r13.read(buf);
            if (nread === null) {
                return n4;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n4 += nread;
        }
    }
    readFromSync(r14) {
        let n5 = 0;
        const tmp = new Uint8Array(MIN_READ1);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ1;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r14.readSync(buf);
            if (nread === null) {
                return n5;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n5 += nread;
        }
    }
}
const DEFAULT_BUF_SIZE = 4096;
const MIN_BUF_SIZE3 = 16;
const CR4 = "\r".charCodeAt(0);
const LF4 = "\n".charCodeAt(0);
class BufferFullError3 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError2 extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader3 {
    buf;
    rd;
    r = 0;
    w = 0;
    eof = false;
    static create(r15, size = 4096) {
        return r15 instanceof BufReader3 ? r15 : new BufReader3(r15, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE3;
        }
        this._reset(new Uint8Array(size), rd);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i77 = 100; i77 > 0; i77--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert5(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r16) {
        this._reset(this.buf, r16);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p31) {
        let rr = p31.byteLength;
        if (p31.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p31.byteLength >= this.buf.byteLength) {
                const rr = await this.rd.read(p31);
                const nread = rr ?? 0;
                assert5(nread >= 0, "negative read");
                return rr;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert5(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copy3(this.buf.subarray(this.r, this.w), p31, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p32) {
        let bytesRead = 0;
        while(bytesRead < p32.length){
            try {
                const rr = await this.read(p32.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError2();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = p32.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e20 = new PartialReadError2();
                    e20.partial = p32.subarray(0, bytesRead);
                    e20.stack = err.stack;
                    e20.message = err.message;
                    e20.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p32;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c14 = this.buf[this.r];
        this.r++;
        return c14;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer2 = await this.readSlice(delim.charCodeAt(0));
        if (buffer2 === null) return null;
        return new TextDecoder().decode(buffer2);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF4);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError2) {
                partial = err.partial;
                assert5(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError3)) {
                throw err;
            }
            partial = err.partial;
            if (!this.eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR4) {
                assert5(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF4) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR4) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s16 = 0;
        let slice;
        while(true){
            let i78 = this.buf.subarray(this.r + s16, this.w).indexOf(delim);
            if (i78 >= 0) {
                i78 += s16;
                slice = this.buf.subarray(this.r, this.r + i78 + 1);
                this.r += i78 + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError3(oldbuf);
            }
            s16 = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e21 = new PartialReadError2();
                    e21.partial = slice;
                    e21.stack = err.stack;
                    e21.message = err.message;
                    e21.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n6 && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = this.buf.subarray(this.r, this.w);
                } else if (err instanceof Error) {
                    const e22 = new PartialReadError2();
                    e22.partial = this.buf.subarray(this.r, this.w);
                    e22.stack = err.stack;
                    e22.message = err.message;
                    e22.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n6 && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n6) {
            throw new BufferFullError3(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n6);
    }
}
class AbstractBufBase2 {
    buf;
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter2 extends AbstractBufBase2 {
    static create(writer, size = 4096) {
        return writer instanceof BufWriter2 ? writer : new BufWriter2(writer, size);
    }
    constructor(writer, size = 4096){
        super();
        this.writer = writer;
        if (size <= 0) {
            size = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size);
    }
    reset(w6) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w6;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p33 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p33.length){
                nwritten += await this.writer.write(p33.subarray(nwritten));
            }
        } catch (e23) {
            if (e23 instanceof Error) {
                this.err = e23;
            }
            throw e23;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e24) {
                    if (e24 instanceof Error) {
                        this.err = e24;
                    }
                    throw e24;
                }
            } else {
                numBytesWritten = copy3(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy3(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
    writer;
}
class BufWriterSync2 extends AbstractBufBase2 {
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync2 ? writer : new BufWriterSync2(writer, size);
    }
    constructor(writer, size = 4096){
        super();
        this.writer = writer;
        if (size <= 0) {
            size = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size);
    }
    reset(w7) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w7;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p34 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p34.length){
                nwritten += this.writer.writeSync(p34.subarray(nwritten));
            }
        } catch (e25) {
            if (e25 instanceof Error) {
                this.err = e25;
            }
            throw e25;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e26) {
                    if (e26 instanceof Error) {
                        this.err = e26;
                    }
                    throw e26;
                }
            } else {
                numBytesWritten = copy3(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy3(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
    writer;
}
function readableStreamFromIterable(iterable) {
    const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
    return new ReadableStream({
        async pull (controller) {
            const { value: value70 , done  } = await iterator.next();
            if (done) {
                controller.close();
            } else {
                controller.enqueue(value70);
            }
        },
        async cancel (reason) {
            if (typeof iterator.throw == "function") {
                try {
                    await iterator.throw(reason);
                } catch  {}
            }
        }
    });
}
class TransformChunkSizes extends TransformStream {
    constructor(outChunkSize){
        const buffer3 = new Buffer1();
        buffer3.grow(outChunkSize);
        const outChunk = new Uint8Array(outChunkSize);
        super({
            start () {},
            async transform (chunk, controller) {
                buffer3.write(chunk);
                while(buffer3.length >= outChunkSize){
                    const readFromBuffer = await buffer3.read(outChunk);
                    if (readFromBuffer !== outChunkSize) {
                        throw new Error(`Unexpectedly read ${readFromBuffer} bytes from transform buffer when trying to read ${outChunkSize} bytes.`);
                    }
                    controller.enqueue(outChunk);
                }
            },
            flush (controller) {
                if (buffer3.length) {
                    controller.enqueue(buffer3.bytes());
                }
            }
        });
    }
}
function parse9(xml) {
    xml = xml.trim();
    xml = xml.replace(/<!--[\s\S]*?-->/g, "");
    return document();
    function document() {
        return {
            declaration: declaration(),
            root: tag()
        };
    }
    function declaration() {
        const m10 = match(/^<\?xml\s*/);
        if (!m10) return;
        const node = {
            attributes: {}
        };
        while(!(eos() || is("?>"))){
            const attr = attribute();
            if (!attr) return node;
            node.attributes[attr.name] = attr.value;
        }
        match(/\?>\s*/);
        return node;
    }
    function tag() {
        const m11 = match(/^<([\w-:.]+)\s*/);
        if (!m11) return;
        const node = {
            name: m11[1],
            attributes: {},
            children: []
        };
        while(!(eos() || is(">") || is("?>") || is("/>"))){
            const attr = attribute();
            if (!attr) return node;
            node.attributes[attr.name] = attr.value;
        }
        if (match(/^\s*\/>\s*/)) {
            return node;
        }
        match(/\??>\s*/);
        node.content = content();
        let child;
        while(child = tag()){
            node.children.push(child);
        }
        match(/^<\/[\w-:.]+>\s*/);
        return node;
    }
    function content() {
        const m12 = match(/^([^<]*)/);
        if (m12) return m12[1];
        return "";
    }
    function attribute() {
        const m13 = match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
        if (!m13) return;
        return {
            name: m13[1],
            value: strip(m13[2])
        };
    }
    function strip(val) {
        return val.replace(/^['"]|['"]$/g, "");
    }
    function match(re) {
        const m14 = xml.match(re);
        if (!m14) return;
        xml = xml.slice(m14[0].length);
        return m14;
    }
    function eos() {
        return 0 == xml.length;
    }
    function is(prefix) {
        return 0 == xml.indexOf(prefix);
    }
}
class DenoS3LiteClientError extends Error {
    constructor(message){
        super(message);
    }
}
class InvalidArgumentError extends DenoS3LiteClientError {
}
class InvalidEndpointError extends DenoS3LiteClientError {
}
class InvalidBucketNameError extends DenoS3LiteClientError {
}
class InvalidObjectNameError extends DenoS3LiteClientError {
}
class AccessKeyRequiredError extends DenoS3LiteClientError {
}
class SecretKeyRequiredError extends DenoS3LiteClientError {
}
class ServerError extends DenoS3LiteClientError {
    statusCode;
    code;
    key;
    bucketName;
    resource;
    region;
    constructor(statusCode, code36, message, otherData = {}){
        super(message);
        this.statusCode = statusCode;
        this.code = code36;
        this.key = otherData.key;
        this.bucketName = otherData.bucketName;
        this.resource = otherData.resource;
        this.region = otherData.region;
    }
}
async function parseServerError(response) {
    try {
        const xmlParsed = parse9(await response.text());
        const errorRoot = xmlParsed.root;
        if (errorRoot?.name !== "Error") {
            throw new Error("Invalid root, expected <Error>");
        }
        const code37 = errorRoot.children.find((c15)=>c15.name === "Code")?.content ?? "UnknownErrorCode";
        const message = errorRoot.children.find((c16)=>c16.name === "Message")?.content ?? "The error message could not be determined.";
        const key55 = errorRoot.children.find((c17)=>c17.name === "Key")?.content;
        const bucketName = errorRoot.children.find((c18)=>c18.name === "BucketName")?.content;
        const resource = errorRoot.children.find((c19)=>c19.name === "Resource")?.content;
        const region = errorRoot.children.find((c20)=>c20.name === "Region")?.content;
        return new ServerError(response.status, code37, message, {
            key: key55,
            bucketName,
            resource,
            region
        });
    } catch  {
        return new ServerError(response.status, "UnrecognizedError", `Error: Unexpected response code ${response.status} ${response.statusText}. Unable to parse response as XML.`);
    }
}
const mod15 = {
    DenoS3LiteClientError: DenoS3LiteClientError,
    InvalidArgumentError: InvalidArgumentError,
    InvalidEndpointError: InvalidEndpointError,
    InvalidBucketNameError: InvalidBucketNameError,
    InvalidObjectNameError: InvalidObjectNameError,
    AccessKeyRequiredError: AccessKeyRequiredError,
    SecretKeyRequiredError: SecretKeyRequiredError,
    ServerError: ServerError,
    parseServerError: parseServerError
};
function isValidPort(port2) {
    if (typeof port2 !== "number" || isNaN(port2)) {
        return false;
    }
    if (port2 <= 0) {
        return false;
    }
    return port2 >= 1 && port2 <= 65535;
}
function isValidBucketName(bucket) {
    if (typeof bucket !== "string") {
        return false;
    }
    if (bucket.length < 3 || bucket.length > 63) {
        return false;
    }
    if (bucket.indexOf("..") > -1) {
        return false;
    }
    if (bucket.match(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/)) {
        return false;
    }
    if (bucket.match(/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/)) {
        return true;
    }
    return false;
}
function isValidObjectName(objectName) {
    if (!isValidPrefix(objectName)) return false;
    if (objectName.length === 0) return false;
    return true;
}
function isValidPrefix(prefix) {
    if (typeof prefix !== "string") return false;
    if (prefix.length > 1024) return false;
    return true;
}
function bin2hex(binary) {
    return Array.from(binary).map((b18)=>b18.toString(16).padStart(2, "0")).join("");
}
function sanitizeETag(etag = "") {
    const replaceChars = {
        '"': "",
        "&quot;": "",
        "&#34;": "",
        "&QUOT;": "",
        "&#x00022": ""
    };
    return etag.replace(/^("|&quot;|&#34;)|("|&quot;|&#34;)$/g, (m15)=>replaceChars[m15]);
}
function getVersionId(headers) {
    return headers.get("x-amz-version-id") ?? null;
}
function makeDateLong(date) {
    date = date || new Date();
    const dateStr = date.toISOString();
    return dateStr.substr(0, 4) + dateStr.substr(5, 2) + dateStr.substr(8, 5) + dateStr.substr(14, 2) + dateStr.substr(17, 2) + "Z";
}
function makeDateShort(date) {
    date = date || new Date();
    const dateStr = date.toISOString();
    return dateStr.substr(0, 4) + dateStr.substr(5, 2) + dateStr.substr(8, 2);
}
function getScope(region, date) {
    return `${makeDateShort(date)}/${region}/s3/aws4_request`;
}
async function sha256digestHex(data) {
    if (!(data instanceof Uint8Array)) {
        data = new TextEncoder().encode(data);
    }
    return bin2hex(new Uint8Array(await crypto.subtle.digest("SHA-256", data)));
}
class ObjectUploader extends WritableStream {
    getResult;
    constructor({ client , bucketName , objectName , partSize , metadata  }){
        let result;
        let nextPartNumber = 1;
        let uploadId;
        const etags = [];
        const partsPromises = [];
        super({
            start () {},
            async write (chunk, _controller) {
                const method4 = "PUT";
                const partNumber = nextPartNumber++;
                try {
                    if (partNumber == 1 && chunk.length < partSize) {
                        const response = await client.makeRequest({
                            method: method4,
                            headers: new Headers({
                                ...metadata,
                                "Content-Length": String(chunk.length)
                            }),
                            bucketName,
                            objectName,
                            payload: chunk
                        });
                        result = {
                            etag: sanitizeETag(response.headers.get("etag") ?? undefined),
                            versionId: getVersionId(response.headers)
                        };
                        return;
                    }
                    if (partNumber === 1) {
                        uploadId = (await initiateNewMultipartUpload({
                            client,
                            bucketName,
                            objectName,
                            metadata
                        })).uploadId;
                    }
                    const partPromise = client.makeRequest({
                        method: method4,
                        query: {
                            partNumber: partNumber.toString(),
                            uploadId
                        },
                        headers: new Headers({
                            "Content-Length": String(chunk.length)
                        }),
                        bucketName: bucketName,
                        objectName: objectName,
                        payload: chunk
                    });
                    partPromise.then((response)=>{
                        let etag = response.headers.get("etag") ?? "";
                        if (etag) {
                            etag = etag.replace(/^"/, "").replace(/"$/, "");
                        }
                        etags.push({
                            part: partNumber,
                            etag
                        });
                    });
                    partsPromises.push(partPromise);
                } catch (err) {
                    throw err;
                }
            },
            async close () {
                if (result) {} else if (uploadId) {
                    await Promise.all(partsPromises);
                    etags.sort((a14, b19)=>a14.part > b19.part ? 1 : -1);
                    result = await completeMultipartUpload({
                        client,
                        bucketName,
                        objectName,
                        uploadId,
                        etags
                    });
                } else {
                    throw new Error("Stream was closed without uploading any data.");
                }
            }
        });
        this.getResult = ()=>{
            if (result === undefined) {
                throw new Error("Result is not ready. await the stream first.");
            }
            return result;
        };
    }
}
async function initiateNewMultipartUpload(options10) {
    const method5 = "POST";
    const headers = new Headers(options10.metadata);
    const query = "uploads";
    const response = await options10.client.makeRequest({
        method: method5,
        bucketName: options10.bucketName,
        objectName: options10.objectName,
        query,
        headers,
        returnBody: true
    });
    const responseText = await response.text();
    const root = parse9(responseText).root;
    if (!root || root.name !== "InitiateMultipartUploadResult") {
        throw new Error(`Unexpected response: ${responseText}`);
    }
    const uploadId = root.children.find((c21)=>c21.name === "UploadId")?.content;
    if (!uploadId) {
        throw new Error(`Unable to get UploadId from response: ${responseText}`);
    }
    return {
        uploadId
    };
}
async function completeMultipartUpload({ client , bucketName , objectName , uploadId , etags  }) {
    const payload5 = `
    <CompleteMultipartUpload xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
        ${etags.map((et1)=>`  <Part><PartNumber>${et1.part}</PartNumber><ETag>${et1.etag}</ETag></Part>`).join("\n")}
    </CompleteMultipartUpload>
  `;
    const response = await client.makeRequest({
        method: "POST",
        bucketName,
        objectName,
        query: `uploadId=${encodeURIComponent(uploadId)}`,
        payload: new TextEncoder().encode(payload5),
        returnBody: true
    });
    const responseText = await response.text();
    const root = parse9(responseText).root;
    if (!root || root.name !== "CompleteMultipartUploadResult") {
        throw new Error(`Unexpected response: ${responseText}`);
    }
    const etagRaw = root.children.find((c22)=>c22.name === "ETag")?.content;
    if (!etagRaw) throw new Error(`Unable to get ETag from response: ${responseText}`);
    const versionId = getVersionId(response.headers);
    return {
        etag: sanitizeETag(etagRaw),
        versionId
    };
}
const signV4Algorithm = "AWS4-HMAC-SHA256";
async function signV4(request6) {
    if (!request6.accessKey) {
        throw new AccessKeyRequiredError("accessKey is required for signing");
    }
    if (!request6.secretKey) {
        throw new SecretKeyRequiredError("secretKey is required for signing");
    }
    const sha256sum = request6.headers.get("x-amz-content-sha256");
    if (sha256sum === null) {
        throw new Error("Internal S3 client error - expected x-amz-content-sha256 header, but it's missing.");
    }
    const signedHeaders = getHeadersToSign(request6.headers);
    const canonicalRequest = getCanonicalRequest(request6.method, request6.path, request6.headers, signedHeaders, sha256sum);
    const stringToSign = await getStringToSign(canonicalRequest, request6.date, request6.region);
    const signingKey = await getSigningKey(request6.date, request6.region, request6.secretKey);
    const credential = getCredential(request6.accessKey, request6.region, request6.date);
    const signature = bin2hex(await sha256hmac(signingKey, stringToSign)).toLowerCase();
    return `${signV4Algorithm} Credential=${credential}, SignedHeaders=${signedHeaders.join(";").toLowerCase()}, Signature=${signature}`;
}
function getHeadersToSign(headers) {
    const ignoredHeaders = [
        "authorization",
        "content-length",
        "content-type",
        "user-agent", 
    ];
    const headersToSign = [];
    for (const key56 of headers.keys()){
        if (ignoredHeaders.includes(key56.toLowerCase())) {
            continue;
        }
        headersToSign.push(key56);
    }
    headersToSign.sort();
    return headersToSign;
}
function getCanonicalRequest(method6, path76, headers, headersToSign, payloadHash) {
    const headersArray = headersToSign.reduce((acc, headerKey)=>{
        const val = `${headers.get(headerKey)}`.replace(/ +/g, " ");
        acc.push(`${headerKey.toLowerCase()}:${val}`);
        return acc;
    }, []);
    const requestResource = path76.split("?")[0];
    let requestQuery = path76.split("?")[1];
    if (requestQuery) {
        requestQuery = requestQuery.split("&").sort().map((element)=>element.indexOf("=") === -1 ? element + "=" : element).join("&");
    } else {
        requestQuery = "";
    }
    const canonical = [];
    canonical.push(method6.toUpperCase());
    canonical.push(requestResource);
    canonical.push(requestQuery);
    canonical.push(headersArray.join("\n") + "\n");
    canonical.push(headersToSign.join(";").toLowerCase());
    canonical.push(payloadHash);
    return canonical.join("\n");
}
async function getStringToSign(canonicalRequest, requestDate, region) {
    const hash = await sha256digestHex(canonicalRequest);
    const scope = getScope(region, requestDate);
    const stringToSign = [];
    stringToSign.push(signV4Algorithm);
    stringToSign.push(makeDateLong(requestDate));
    stringToSign.push(scope);
    stringToSign.push(hash);
    return stringToSign.join("\n");
}
async function getSigningKey(date, region, secretKey) {
    const dateLine = makeDateShort(date);
    const hmac1 = await sha256hmac("AWS4" + secretKey, dateLine);
    const hmac2 = await sha256hmac(hmac1, region);
    const hmac3 = await sha256hmac(hmac2, "s3");
    return await sha256hmac(hmac3, "aws4_request");
}
function getCredential(accessKey, region, requestDate) {
    return `${accessKey}/${getScope(region, requestDate)}`;
}
async function sha256hmac(secretKey, data) {
    const enc = new TextEncoder();
    const keyObject = await crypto.subtle.importKey("raw", secretKey instanceof Uint8Array ? secretKey : enc.encode(secretKey), {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, false, [
        "sign",
        "verify"
    ]);
    const signature = await crypto.subtle.sign("HMAC", keyObject, data instanceof Uint8Array ? data : enc.encode(data));
    return new Uint8Array(signature);
}
const metadataKeys = [
    "Content-Type",
    "Cache-Control",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Expires",
    "x-amz-acl",
    "x-amz-grant-full-control",
    "x-amz-grant-read",
    "x-amz-grant-read-acp",
    "x-amz-grant-write-acp",
    "x-amz-server-side-encryption",
    "x-amz-storage-class",
    "x-amz-website-redirect-location",
    "x-amz-server-side-encryption-customer-algorithm",
    "x-amz-server-side-encryption-customer-key",
    "x-amz-server-side-encryption-customer-key-MD5",
    "x-amz-server-side-encryption-aws-kms-key-id",
    "x-amz-server-side-encryption-context",
    "x-amz-server-side-encryption-bucket-key-enabled",
    "x-amz-request-payer",
    "x-amz-tagging",
    "x-amz-object-lock-mode",
    "x-amz-object-lock-retain-until-date",
    "x-amz-object-lock-legal-hold",
    "x-amz-expected-bucket-owner", 
];
const minimumPartSize = 5 * 1024 * 1024;
const maximumPartSize = 5 * 1024 * 1024 * 1024;
const maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024;
class Client {
    host;
    port;
    protocol;
    accessKey;
    #secretKey;
    defaultBucket;
    region;
    userAgent = "deno-s3-lite-client";
    pathStyle;
    constructor(params){
        if (params.useSSL === undefined) {
            params.useSSL = true;
        }
        if (typeof params.endPoint !== "string" || params.endPoint.length === 0 || params.endPoint.indexOf("/") !== -1) {
            throw new InvalidEndpointError(`Invalid endPoint : ${params.endPoint}`);
        }
        if (params.port !== undefined && !isValidPort(params.port)) {
            throw new InvalidArgumentError(`Invalid port : ${params.port}`);
        }
        this.port = params.port ?? (params.useSSL ? 443 : 80);
        this.host = params.endPoint.toLowerCase() + (params.port ? `:${params.port}` : "");
        this.protocol = params.useSSL ? "https:" : "http:";
        this.accessKey = params.accessKey;
        this.#secretKey = params.secretKey;
        this.pathStyle = params.pathStyle ?? true;
        this.defaultBucket = params.bucket;
        this.region = params.region;
    }
    getBucketName(options11) {
        const bucketName = options11?.bucketName ?? this.defaultBucket;
        if (bucketName === undefined || !isValidBucketName(bucketName)) {
            throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
        }
        return bucketName;
    }
    async makeRequest({ method: method7 , payload: payload6 , ...options12 }) {
        const date = new Date();
        const bucketName = this.getBucketName(options12);
        const headers = options12.headers ?? new Headers();
        const host = this.pathStyle ? this.host : `${bucketName}.${this.host}`;
        const queryAsString = typeof options12.query === "object" ? new URLSearchParams(options12.query).toString().replace("+", "%20") : options12.query;
        const path77 = (this.pathStyle ? `/${bucketName}/${options12.objectName}` : `/${options12.objectName}`) + (queryAsString ? `?${queryAsString}` : "");
        const statusCode = options12.statusCode ?? 200;
        if (method7 === "POST" || method7 === "PUT" || method7 === "DELETE") {
            if (payload6 === undefined) {
                payload6 = new Uint8Array();
            } else if (typeof payload6 === "string") {
                payload6 = new TextEncoder().encode(payload6);
            }
            headers.set("Content-Length", String(payload6.length));
        } else if (payload6) {
            throw new Error(`Unexpected payload on ${method7} request.`);
        }
        const sha256sum = await sha256digestHex(payload6 ?? new Uint8Array());
        headers.set("host", host);
        headers.set("x-amz-date", makeDateLong(date));
        headers.set("x-amz-content-sha256", sha256sum);
        headers.set("authorization", await signV4({
            headers,
            method: method7,
            path: path77,
            accessKey: this.accessKey,
            secretKey: this.#secretKey,
            region: this.region,
            date
        }));
        const fullUrl = `${this.protocol}//${host}${path77}`;
        const response = await fetch(fullUrl, {
            method: method7,
            headers,
            body: payload6
        });
        if (response.status !== statusCode) {
            if (response.status >= 400) {
                const error15 = await parseServerError(response);
                throw error15;
            } else {
                throw new ServerError(response.status, "UnexpectedStatusCode", `Unexpected response code from the server (expected ${statusCode}, got ${response.status} ${response.statusText}).`);
            }
        }
        if (!options12.returnBody) {
            await response.body?.getReader().read();
        }
        return response;
    }
    async deleteObject(objectName, options13 = {}) {
        const bucketName = this.getBucketName(options13);
        if (!isValidObjectName(objectName)) {
            throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
        }
        const query = options13.versionId ? {
            versionId: options13.versionId
        } : {};
        const headers = new Headers();
        if (options13.governanceBypass) {
            headers.set("X-Amz-Bypass-Governance-Retention", "true");
        }
        await this.makeRequest({
            method: "DELETE",
            bucketName,
            objectName,
            headers,
            query,
            statusCode: 204
        });
    }
    async exists(objectName, options14) {
        try {
            await this.statObject(objectName, options14);
            return true;
        } catch (err) {
            if (err instanceof ServerError && err.statusCode === 404) {
                return false;
            }
            throw err;
        }
    }
    getObject(objectName, options15) {
        return this.getPartialObject(objectName, {
            ...options15,
            offset: 0,
            length: 0
        });
    }
    async getPartialObject(objectName, { offset , length , ...options16 }) {
        const bucketName = this.getBucketName(options16);
        if (!isValidObjectName(objectName)) {
            throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
        }
        const headers = new Headers();
        let statusCode = 200;
        if (offset || length) {
            let range = "";
            if (offset) {
                range = `bytes=${+offset}-`;
            } else {
                range = "bytes=0-";
                offset = 0;
            }
            if (length) {
                range += `${+length + offset - 1}`;
            }
            headers.set("Range", range);
            statusCode = 206;
        }
        const query = options16.versionId ? {
            versionId: options16.versionId
        } : undefined;
        return await this.makeRequest({
            method: "GET",
            bucketName,
            objectName,
            headers,
            query,
            statusCode,
            returnBody: true
        });
    }
    async *listObjects(options17 = {}) {
        for await (const result of this.listObjectsGrouped({
            ...options17,
            delimiter: ""
        })){
            if (result.type === "Object") {
                yield result;
            } else {
                throw new Error(`Unexpected result from listObjectsGrouped(): ${result}`);
            }
        }
    }
    async *listObjectsGrouped(options18) {
        const bucketName = this.getBucketName(options18);
        let continuationToken = "";
        const pageSize = options18.pageSize ?? 1_000;
        if (pageSize < 1 || pageSize > 1_000) {
            throw new InvalidArgumentError("pageSize must be between 1 and 1,000.");
        }
        let resultCount = 0;
        while(true){
            const maxKeys = options18.maxResults ? Math.min(pageSize, options18.maxResults - resultCount) : pageSize;
            if (maxKeys === 0) {
                return;
            }
            const pageResponse = await this.makeRequest({
                method: "GET",
                bucketName,
                objectName: "",
                query: {
                    "list-type": "2",
                    prefix: options18.prefix ?? "",
                    delimiter: options18.delimiter,
                    "max-keys": String(maxKeys),
                    ...continuationToken ? {
                        "continuation-token": continuationToken
                    } : {}
                },
                returnBody: true
            });
            const responseText = await pageResponse.text();
            const root = parse9(responseText).root;
            if (!root || root.name !== "ListBucketResult") {
                throw new Error(`Unexpected response: ${responseText}`);
            }
            const commonPrefixesElement = root.children.find((c23)=>c23.name === "CommonPrefixes");
            const toYield = [];
            if (commonPrefixesElement) {
                for (const prefixElement of commonPrefixesElement.children){
                    toYield.push({
                        type: "CommonPrefix",
                        prefix: prefixElement.content ?? ""
                    });
                    resultCount++;
                }
            }
            for (const objectElement of root.children.filter((c24)=>c24.name === "Contents")){
                toYield.push({
                    type: "Object",
                    key: objectElement.children.find((c25)=>c25.name === "Key")?.content ?? "",
                    etag: sanitizeETag(objectElement.children.find((c26)=>c26.name === "ETag")?.content ?? ""),
                    size: parseInt(objectElement.children.find((c27)=>c27.name === "Size")?.content ?? "", 10),
                    lastModified: new Date(objectElement.children.find((c28)=>c28.name === "LastModified")?.content ?? "invalid")
                });
                resultCount++;
            }
            toYield.sort((a15, b20)=>{
                const aStr = a15.type === "Object" ? a15.key : a15.prefix;
                const bStr = b20.type === "Object" ? b20.key : b20.prefix;
                return aStr > bStr ? 1 : aStr < bStr ? -1 : 0;
            });
            for (const entry of toYield){
                yield entry;
            }
            const isTruncated = root.children.find((c29)=>c29.name === "IsTruncated")?.content === "true";
            if (isTruncated) {
                const nextContinuationToken = root.children.find((c30)=>c30.name === "NextContinuationToken")?.content;
                if (!nextContinuationToken) {
                    throw new Error("Unexpectedly missing continuation token, but server said there are more results.");
                }
                continuationToken = nextContinuationToken;
            } else {
                return;
            }
        }
    }
    async putObject(objectName, streamOrData, options19) {
        const bucketName = this.getBucketName(options19);
        if (!isValidObjectName(objectName)) {
            throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
        }
        let size;
        let stream;
        if (typeof streamOrData === "string") {
            const binaryData = new TextEncoder().encode(streamOrData);
            stream = readableStreamFromIterable([
                binaryData
            ]);
            size = binaryData.length;
        } else if (streamOrData instanceof Uint8Array) {
            stream = readableStreamFromIterable([
                streamOrData
            ]);
            size = streamOrData.byteLength;
        } else if (streamOrData instanceof ReadableStream) {
            stream = streamOrData;
        } else {
            throw new InvalidArgumentError(`Invalid stream/data type provided.`);
        }
        if (options19?.size !== undefined) {
            if (size !== undefined && options19?.size !== size) {
                throw new InvalidArgumentError(`size was specified (${options19.size}) but doesn't match auto-detected size (${size}).`);
            }
            if (typeof size !== "number" || size < 0 || isNaN(size)) {
                throw new InvalidArgumentError(`invalid size specified: ${options19.size}`);
            } else {
                size = options19.size;
            }
        }
        const partSize = options19?.partSize ?? this.calculatePartSize(size);
        if (partSize < minimumPartSize) {
            throw new InvalidArgumentError(`Part size should be greater than 5MB`);
        } else if (partSize > maximumPartSize) {
            throw new InvalidArgumentError(`Part size should be less than 6MB`);
        }
        const chunker = new TransformChunkSizes(partSize);
        const uploader = new ObjectUploader({
            client: this,
            bucketName,
            objectName,
            partSize,
            metadata: options19?.metadata ?? {}
        });
        await stream.pipeThrough(chunker).pipeTo(uploader);
        return uploader.getResult();
    }
    calculatePartSize(size) {
        if (size === undefined) {
            size = maxObjectSize;
        }
        if (size > maxObjectSize) {
            throw new TypeError(`size should not be more than ${maxObjectSize}`);
        }
        let partSize = 64 * 1024 * 1024;
        while(true){
            if (partSize * 10_000 > size) {
                return partSize;
            }
            partSize += 16 * 1024 * 1024;
        }
    }
    async statObject(objectName, options20) {
        const bucketName = this.getBucketName(options20);
        if (!isValidObjectName(objectName)) {
            throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
        }
        const query = {};
        if (options20?.versionId) {
            query.versionId = options20.versionId;
        }
        const response = await this.makeRequest({
            method: "HEAD",
            bucketName,
            objectName,
            query
        });
        const metadata = {};
        for (const header of metadataKeys){
            if (response.headers.has(header)) {
                metadata[header] = response.headers.get(header);
            }
        }
        response.headers.forEach((_value, key57)=>{
            if (key57.startsWith("x-amz-meta-")) {
                metadata[key57] = response.headers.get(key57);
            }
        });
        return {
            type: "Object",
            key: objectName,
            size: parseInt(response.headers.get("content-length") ?? "", 10),
            metadata,
            lastModified: new Date(response.headers.get("Last-Modified") ?? "error: missing last modified"),
            versionId: response.headers.get("x-amz-version-id") || null,
            etag: sanitizeETag(response.headers.get("ETag") ?? "")
        };
    }
}
const mod16 = {
    S3Client: Client,
    S3Errors: mod15
};
const uintToBuf = (num)=>{
    const buf = new ArrayBuffer(8);
    const arr = new Uint8Array(buf);
    let acc = num;
    for(let i1 = 7; i1 >= 0; i1--){
        if (acc === 0) break;
        arr[i1] = acc & 255;
        acc -= arr[i1];
        acc /= 256;
    }
    return buf;
};
const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function n(t1, n1, e1, r1) {
    let i2, s1, o1;
    const h1 = n1 || [
        0
    ], u1 = (e1 = e1 || 0) >>> 3, w1 = -1 === r1 ? 3 : 0;
    for(i2 = 0; i2 < t1.length; i2 += 1)o1 = i2 + u1, s1 = o1 >>> 2, h1.length <= s1 && h1.push(0), h1[s1] |= t1[i2] << 8 * (w1 + r1 * (o1 % 4));
    return {
        value: h1,
        binLen: 8 * t1.length + e1
    };
}
function e(e2, r2, i3) {
    switch(r2){
        case "UTF8":
        case "UTF16BE":
        case "UTF16LE":
            break;
        default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
    }
    switch(e2){
        case "HEX":
            return function(t2, n22, e3) {
                return function(t3, n3, e4, r3) {
                    let i4, s2, o2, h2;
                    if (0 != t3.length % 2) throw new Error("String of HEX type must be in byte increments");
                    const u2 = n3 || [
                        0
                    ], w2 = (e4 = e4 || 0) >>> 3, c1 = -1 === r3 ? 3 : 0;
                    for(i4 = 0; i4 < t3.length; i4 += 2){
                        if (s2 = parseInt(t3.substr(i4, 2), 16), isNaN(s2)) throw new Error("String of HEX type contains invalid characters");
                        for(h2 = (i4 >>> 1) + w2, o2 = h2 >>> 2; u2.length <= o2;)u2.push(0);
                        u2[o2] |= s2 << 8 * (c1 + r3 * (h2 % 4));
                    }
                    return {
                        value: u2,
                        binLen: 4 * t3.length + e4
                    };
                }(t2, n22, e3, i3);
            };
        case "TEXT":
            return function(t4, n4, e5) {
                return function(t5, n5, e6, r4, i5) {
                    let s3, o3, h3, u3, w3, c2, f1, a1, l1 = 0;
                    const A1 = e6 || [
                        0
                    ], E1 = (r4 = r4 || 0) >>> 3;
                    if ("UTF8" === n5) for(f1 = -1 === i5 ? 3 : 0, h3 = 0; h3 < t5.length; h3 += 1)for(s3 = t5.charCodeAt(h3), o3 = [], 128 > s3 ? o3.push(s3) : 2048 > s3 ? (o3.push(192 | s3 >>> 6), o3.push(128 | 63 & s3)) : 55296 > s3 || 57344 <= s3 ? o3.push(224 | s3 >>> 12, 128 | s3 >>> 6 & 63, 128 | 63 & s3) : (h3 += 1, s3 = 65536 + ((1023 & s3) << 10 | 1023 & t5.charCodeAt(h3)), o3.push(240 | s3 >>> 18, 128 | s3 >>> 12 & 63, 128 | s3 >>> 6 & 63, 128 | 63 & s3)), u3 = 0; u3 < o3.length; u3 += 1){
                        for(c2 = l1 + E1, w3 = c2 >>> 2; A1.length <= w3;)A1.push(0);
                        A1[w3] |= o3[u3] << 8 * (f1 + i5 * (c2 % 4)), l1 += 1;
                    }
                    else for(f1 = -1 === i5 ? 2 : 0, a1 = "UTF16LE" === n5 && 1 !== i5 || "UTF16LE" !== n5 && 1 === i5, h3 = 0; h3 < t5.length; h3 += 1){
                        for(s3 = t5.charCodeAt(h3), !0 === a1 && (u3 = 255 & s3, s3 = u3 << 8 | s3 >>> 8), c2 = l1 + E1, w3 = c2 >>> 2; A1.length <= w3;)A1.push(0);
                        A1[w3] |= s3 << 8 * (f1 + i5 * (c2 % 4)), l1 += 2;
                    }
                    return {
                        value: A1,
                        binLen: 8 * l1 + r4
                    };
                }(t4, r2, n4, e5, i3);
            };
        case "B64":
            return function(n6, e7, r5) {
                return function(n7, e8, r6, i6) {
                    let s4, o4, h4, u4, w4, c3, f2, a2 = 0;
                    const l2 = e8 || [
                        0
                    ], A2 = (r6 = r6 || 0) >>> 3, E2 = -1 === i6 ? 3 : 0, H1 = n7.indexOf("=");
                    if (-1 === n7.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                    if (n7 = n7.replace(/=/g, ""), -1 !== H1 && H1 < n7.length) throw new Error("Invalid '=' found in base-64 string");
                    for(o4 = 0; o4 < n7.length; o4 += 4){
                        for(w4 = n7.substr(o4, 4), u4 = 0, h4 = 0; h4 < w4.length; h4 += 1)s4 = t.indexOf(w4.charAt(h4)), u4 |= s4 << 18 - 6 * h4;
                        for(h4 = 0; h4 < w4.length - 1; h4 += 1){
                            for(f2 = a2 + A2, c3 = f2 >>> 2; l2.length <= c3;)l2.push(0);
                            l2[c3] |= (u4 >>> 16 - 8 * h4 & 255) << 8 * (E2 + i6 * (f2 % 4)), a2 += 1;
                        }
                    }
                    return {
                        value: l2,
                        binLen: 8 * a2 + r6
                    };
                }(n6, e7, r5, i3);
            };
        case "BYTES":
            return function(t6, n8, e9) {
                return function(t7, n9, e10, r7) {
                    let i7, s5, o5, h5;
                    const u5 = n9 || [
                        0
                    ], w5 = (e10 = e10 || 0) >>> 3, c4 = -1 === r7 ? 3 : 0;
                    for(s5 = 0; s5 < t7.length; s5 += 1)i7 = t7.charCodeAt(s5), h5 = s5 + w5, o5 = h5 >>> 2, u5.length <= o5 && u5.push(0), u5[o5] |= i7 << 8 * (c4 + r7 * (h5 % 4));
                    return {
                        value: u5,
                        binLen: 8 * t7.length + e10
                    };
                }(t6, n8, e9, i3);
            };
        case "ARRAYBUFFER":
            try {
                new ArrayBuffer(0);
            } catch (t8) {
                throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(t9, e11, r8) {
                return function(t10, e12, r9, i8) {
                    return n(new Uint8Array(t10), e12, r9, i8);
                }(t9, e11, r8, i3);
            };
        case "UINT8ARRAY":
            try {
                new Uint8Array(0);
            } catch (t11) {
                throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(t12, e13, r10) {
                return n(t12, e13, r10, i3);
            };
        default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
    }
}
function r(n10, e14, r11, i9) {
    switch(n10){
        case "HEX":
            return function(t13) {
                return function(t14, n11, e15, r12) {
                    let i10, s6, o6 = "";
                    const h6 = n11 / 8, u6 = -1 === e15 ? 3 : 0;
                    for(i10 = 0; i10 < h6; i10 += 1)s6 = t14[i10 >>> 2] >>> 8 * (u6 + e15 * (i10 % 4)), o6 += "0123456789abcdef".charAt(s6 >>> 4 & 15) + "0123456789abcdef".charAt(15 & s6);
                    return r12.outputUpper ? o6.toUpperCase() : o6;
                }(t13, e14, r11, i9);
            };
        case "B64":
            return function(n12) {
                return function(n13, e16, r13, i11) {
                    let s7, o7, h7, u7, w6, c5 = "";
                    const f3 = e16 / 8, a3 = -1 === r13 ? 3 : 0;
                    for(s7 = 0; s7 < f3; s7 += 3)for(u7 = s7 + 1 < f3 ? n13[s7 + 1 >>> 2] : 0, w6 = s7 + 2 < f3 ? n13[s7 + 2 >>> 2] : 0, h7 = (n13[s7 >>> 2] >>> 8 * (a3 + r13 * (s7 % 4)) & 255) << 16 | (u7 >>> 8 * (a3 + r13 * ((s7 + 1) % 4)) & 255) << 8 | w6 >>> 8 * (a3 + r13 * ((s7 + 2) % 4)) & 255, o7 = 0; o7 < 4; o7 += 1)c5 += 8 * s7 + 6 * o7 <= e16 ? t.charAt(h7 >>> 6 * (3 - o7) & 63) : i11.b64Pad;
                    return c5;
                }(n12, e14, r11, i9);
            };
        case "BYTES":
            return function(t15) {
                return function(t16, n14, e17) {
                    let r14, i12, s8 = "";
                    const o8 = n14 / 8, h8 = -1 === e17 ? 3 : 0;
                    for(r14 = 0; r14 < o8; r14 += 1)i12 = t16[r14 >>> 2] >>> 8 * (h8 + e17 * (r14 % 4)) & 255, s8 += String.fromCharCode(i12);
                    return s8;
                }(t15, e14, r11);
            };
        case "ARRAYBUFFER":
            try {
                new ArrayBuffer(0);
            } catch (t17) {
                throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(t18) {
                return function(t19, n15, e18) {
                    let r15;
                    const i13 = n15 / 8, s9 = new ArrayBuffer(i13), o9 = new Uint8Array(s9), h9 = -1 === e18 ? 3 : 0;
                    for(r15 = 0; r15 < i13; r15 += 1)o9[r15] = t19[r15 >>> 2] >>> 8 * (h9 + e18 * (r15 % 4)) & 255;
                    return s9;
                }(t18, e14, r11);
            };
        case "UINT8ARRAY":
            try {
                new Uint8Array(0);
            } catch (t20) {
                throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(t21) {
                return function(t22, n161, e19) {
                    let r16;
                    const i14 = n161 / 8, s10 = -1 === e19 ? 3 : 0, o10 = new Uint8Array(i14);
                    for(r16 = 0; r16 < i14; r16 += 1)o10[r16] = t22[r16 >>> 2] >>> 8 * (s10 + e19 * (r16 % 4)) & 255;
                    return o10;
                }(t21, e14, r11);
            };
        default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
    }
}
const i = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
], s = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
], o = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
], h = "Chosen SHA variant is not supported";
function u(t23, n17) {
    let e20, r17;
    const i15 = t23.binLen >>> 3, s11 = n17.binLen >>> 3, o11 = i15 << 3, h10 = 4 - i15 << 3;
    if (i15 % 4 != 0) {
        for(e20 = 0; e20 < s11; e20 += 4)r17 = i15 + e20 >>> 2, t23.value[r17] |= n17.value[e20 >>> 2] << o11, t23.value.push(0), t23.value[r17 + 1] |= n17.value[e20 >>> 2] >>> h10;
        return (t23.value.length << 2) - 4 >= s11 + i15 && t23.value.pop(), {
            value: t23.value,
            binLen: t23.binLen + n17.binLen
        };
    }
    return {
        value: t23.value.concat(n17.value),
        binLen: t23.binLen + n17.binLen
    };
}
function w(t24) {
    const n18 = {
        outputUpper: !1,
        b64Pad: "=",
        outputLen: -1
    }, e21 = t24 || {}, r18 = "Output length must be a multiple of 8";
    if (n18.outputUpper = e21.outputUpper || !1, e21.b64Pad && (n18.b64Pad = e21.b64Pad), e21.outputLen) {
        if (e21.outputLen % 8 != 0) throw new Error(r18);
        n18.outputLen = e21.outputLen;
    } else if (e21.shakeLen) {
        if (e21.shakeLen % 8 != 0) throw new Error(r18);
        n18.outputLen = e21.shakeLen;
    }
    if ("boolean" != typeof n18.outputUpper) throw new Error("Invalid outputUpper formatting option");
    if ("string" != typeof n18.b64Pad) throw new Error("Invalid b64Pad formatting option");
    return n18;
}
function c(t25, n19, r19, i16) {
    const s12 = t25 + " must include a value and format";
    if (!n19) {
        if (!i16) throw new Error(s12);
        return i16;
    }
    if (void 0 === n19.value || !n19.format) throw new Error(s12);
    return e(n19.format, n19.encoding || "UTF8", r19)(n19.value);
}
class f {
    constructor(t26, n20, e22){
        const r20 = e22 || {};
        if (this.t = n20, this.i = r20.encoding || "UTF8", this.numRounds = r20.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
        this.s = t26, this.o = [], this.h = 0, this.u = !1, this.l = 0, this.A = !1, this.H = [], this.S = [];
    }
    update(t27) {
        let n21, e23 = 0;
        const r21 = this.p >>> 5, i17 = this.m(t27, this.o, this.h), s13 = i17.binLen, o12 = i17.value, h11 = s13 >>> 5;
        for(n21 = 0; n21 < h11; n21 += r21)e23 + this.p <= s13 && (this.C = this.R(o12.slice(n21, n21 + r21), this.C), e23 += this.p);
        this.l += e23, this.o = o12.slice(e23 >>> 5), this.h = s13 % this.p, this.u = !0;
    }
    getHash(t28, n22) {
        let e24, i18, s14 = this.U;
        const o13 = w(n22);
        if (this.v) {
            if (-1 === o13.outputLen) throw new Error("Output length must be specified in options");
            s14 = o13.outputLen;
        }
        const h12 = r(t28, s14, this.K, o13);
        if (this.A && this.T) return h12(this.T(o13));
        for(i18 = this.F(this.o.slice(), this.h, this.l, this.g(this.C), s14), e24 = 1; e24 < this.numRounds; e24 += 1)this.v && s14 % 32 != 0 && (i18[i18.length - 1] &= 16777215 >>> 24 - s14 % 32), i18 = this.F(i18, s14, 0, this.B(this.s), s14);
        return h12(i18);
    }
    setHMACKey(t29, n23, r22) {
        if (!this.L) throw new Error("Variant does not support HMAC");
        if (this.u) throw new Error("Cannot set MAC key after calling update");
        const i19 = e(n23, (r22 || {}).encoding || "UTF8", this.K);
        this.M(i19(t29));
    }
    M(t30) {
        const n24 = this.p >>> 3, e25 = n24 / 4 - 1;
        let r23;
        if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
        if (this.A) throw new Error("MAC key already set");
        for(n24 < t30.binLen / 8 && (t30.value = this.F(t30.value, t30.binLen, 0, this.B(this.s), this.U)); t30.value.length <= e25;)t30.value.push(0);
        for(r23 = 0; r23 <= e25; r23 += 1)this.H[r23] = 909522486 ^ t30.value[r23], this.S[r23] = 1549556828 ^ t30.value[r23];
        this.C = this.R(this.H, this.C), this.l = this.p, this.A = !0;
    }
    getHMAC(t31, n25) {
        const e26 = w(n25);
        return r(t31, this.U, this.K, e26)(this.k());
    }
    k() {
        let t32;
        if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
        const n26 = this.F(this.o.slice(), this.h, this.l, this.g(this.C), this.U);
        return t32 = this.R(this.S, this.B(this.s)), t32 = this.F(n26, this.U, this.p, t32, this.U), t32;
    }
}
function a(t33, n27) {
    return t33 << n27 | t33 >>> 32 - n27;
}
function l(t34, n28) {
    return t34 >>> n28 | t34 << 32 - n28;
}
function A(t35, n29) {
    return t35 >>> n29;
}
function E(t36, n30, e27) {
    return t36 ^ n30 ^ e27;
}
function H(t37, n31, e28) {
    return t37 & n31 ^ ~t37 & e28;
}
function S(t38, n321, e29) {
    return t38 & n321 ^ t38 & e29 ^ n321 & e29;
}
function b(t39) {
    return l(t39, 2) ^ l(t39, 13) ^ l(t39, 22);
}
function p(t40, n33) {
    const e30 = (65535 & t40) + (65535 & n33);
    return (65535 & (t40 >>> 16) + (n33 >>> 16) + (e30 >>> 16)) << 16 | 65535 & e30;
}
function d(t41, n34, e31, r24) {
    const i20 = (65535 & t41) + (65535 & n34) + (65535 & e31) + (65535 & r24);
    return (65535 & (t41 >>> 16) + (n34 >>> 16) + (e31 >>> 16) + (r24 >>> 16) + (i20 >>> 16)) << 16 | 65535 & i20;
}
function m(t42, n35, e32, r25, i21) {
    const s15 = (65535 & t42) + (65535 & n35) + (65535 & e32) + (65535 & r25) + (65535 & i21);
    return (65535 & (t42 >>> 16) + (n35 >>> 16) + (e32 >>> 16) + (r25 >>> 16) + (i21 >>> 16) + (s15 >>> 16)) << 16 | 65535 & s15;
}
function C(t43) {
    return l(t43, 7) ^ l(t43, 18) ^ A(t43, 3);
}
function y(t44) {
    return l(t44, 6) ^ l(t44, 11) ^ l(t44, 25);
}
function R(t) {
    return [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ];
}
function U(t45, n36) {
    let e33, r26, i22, s16, o14, h13, u8;
    const w7 = [];
    for(e33 = n36[0], r26 = n36[1], i22 = n36[2], s16 = n36[3], o14 = n36[4], u8 = 0; u8 < 80; u8 += 1)w7[u8] = u8 < 16 ? t45[u8] : a(w7[u8 - 3] ^ w7[u8 - 8] ^ w7[u8 - 14] ^ w7[u8 - 16], 1), h13 = u8 < 20 ? m(a(e33, 5), H(r26, i22, s16), o14, 1518500249, w7[u8]) : u8 < 40 ? m(a(e33, 5), E(r26, i22, s16), o14, 1859775393, w7[u8]) : u8 < 60 ? m(a(e33, 5), S(r26, i22, s16), o14, 2400959708, w7[u8]) : m(a(e33, 5), E(r26, i22, s16), o14, 3395469782, w7[u8]), o14 = s16, s16 = i22, i22 = a(r26, 30), r26 = e33, e33 = h13;
    return n36[0] = p(e33, n36[0]), n36[1] = p(r26, n36[1]), n36[2] = p(i22, n36[2]), n36[3] = p(s16, n36[3]), n36[4] = p(o14, n36[4]), n36;
}
function v(t46, n37, e34, r27) {
    let i23;
    const s17 = 15 + (n37 + 65 >>> 9 << 4), o15 = n37 + e34;
    for(; t46.length <= s17;)t46.push(0);
    for(t46[n37 >>> 5] |= 128 << 24 - n37 % 32, t46[s17] = 4294967295 & o15, t46[s17 - 1] = o15 / 4294967296 | 0, i23 = 0; i23 < t46.length; i23 += 16)r27 = U(t46.slice(i23, i23 + 16), r27);
    return r27;
}
class K extends f {
    constructor(t47, n38, r28){
        if ("SHA-1" !== t47) throw new Error(h);
        super(t47, n38, r28);
        const i24 = r28 || {};
        this.L = !0, this.T = this.k, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = U, this.g = function(t48) {
            return t48.slice();
        }, this.B = R, this.F = v, this.C = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.p = 512, this.U = 160, this.v = !1, i24.hmacKey && this.M(c("hmacKey", i24.hmacKey, this.K));
    }
}
function T(t49) {
    let n39;
    return n39 = "SHA-224" == t49 ? s.slice() : o.slice(), n39;
}
function F(t50, n40) {
    let e35, r29, s18, o16, h14, u9, w8, c6, f4, a4, E3;
    const R1 = [];
    for(e35 = n40[0], r29 = n40[1], s18 = n40[2], o16 = n40[3], h14 = n40[4], u9 = n40[5], w8 = n40[6], c6 = n40[7], E3 = 0; E3 < 64; E3 += 1)R1[E3] = E3 < 16 ? t50[E3] : d(l(U1 = R1[E3 - 2], 17) ^ l(U1, 19) ^ A(U1, 10), R1[E3 - 7], C(R1[E3 - 15]), R1[E3 - 16]), f4 = m(c6, y(h14), H(h14, u9, w8), i[E3], R1[E3]), a4 = p(b(e35), S(e35, r29, s18)), c6 = w8, w8 = u9, u9 = h14, h14 = p(o16, f4), o16 = s18, s18 = r29, r29 = e35, e35 = p(f4, a4);
    var U1;
    return n40[0] = p(e35, n40[0]), n40[1] = p(r29, n40[1]), n40[2] = p(s18, n40[2]), n40[3] = p(o16, n40[3]), n40[4] = p(h14, n40[4]), n40[5] = p(u9, n40[5]), n40[6] = p(w8, n40[6]), n40[7] = p(c6, n40[7]), n40;
}
class g extends f {
    constructor(t51, n41, r30){
        if ("SHA-224" !== t51 && "SHA-256" !== t51) throw new Error(h);
        super(t51, n41, r30);
        const i25 = r30 || {};
        this.T = this.k, this.L = !0, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = F, this.g = function(t52) {
            return t52.slice();
        }, this.B = T, this.F = function(n42, e36, r31, i26) {
            return function(t53, n43, e37, r32, i27) {
                let s19, o17;
                const h15 = 15 + (n43 + 65 >>> 9 << 4), u10 = n43 + e37;
                for(; t53.length <= h15;)t53.push(0);
                for(t53[n43 >>> 5] |= 128 << 24 - n43 % 32, t53[h15] = 4294967295 & u10, t53[h15 - 1] = u10 / 4294967296 | 0, s19 = 0; s19 < t53.length; s19 += 16)r32 = F(t53.slice(s19, s19 + 16), r32);
                return o17 = "SHA-224" === i27 ? [
                    r32[0],
                    r32[1],
                    r32[2],
                    r32[3],
                    r32[4],
                    r32[5],
                    r32[6]
                ] : r32, o17;
            }(n42, e36, r31, i26, t51);
        }, this.C = T(t51), this.p = 512, this.U = "SHA-224" === t51 ? 224 : 256, this.v = !1, i25.hmacKey && this.M(c("hmacKey", i25.hmacKey, this.K));
    }
}
class B {
    constructor(t54, n44){
        this.Y = t54, this.N = n44;
    }
}
function L(t55, n45) {
    let e38;
    return n45 > 32 ? (e38 = 64 - n45, new B(t55.N << n45 | t55.Y >>> e38, t55.Y << n45 | t55.N >>> e38)) : 0 !== n45 ? (e38 = 32 - n45, new B(t55.Y << n45 | t55.N >>> e38, t55.N << n45 | t55.Y >>> e38)) : t55;
}
function M(t56, n46) {
    let e39;
    return n46 < 32 ? (e39 = 32 - n46, new B(t56.Y >>> n46 | t56.N << e39, t56.N >>> n46 | t56.Y << e39)) : (e39 = 64 - n46, new B(t56.N >>> n46 | t56.Y << e39, t56.Y >>> n46 | t56.N << e39));
}
function k(t57, n47) {
    return new B(t57.Y >>> n47, t57.N >>> n47 | t57.Y << 32 - n47);
}
function Y(t58, n48, e40) {
    return new B(t58.Y & n48.Y ^ t58.Y & e40.Y ^ n48.Y & e40.Y, t58.N & n48.N ^ t58.N & e40.N ^ n48.N & e40.N);
}
function N(t59) {
    const n49 = M(t59, 28), e41 = M(t59, 34), r33 = M(t59, 39);
    return new B(n49.Y ^ e41.Y ^ r33.Y, n49.N ^ e41.N ^ r33.N);
}
function I(t60, n50) {
    let e42, r34;
    e42 = (65535 & t60.N) + (65535 & n50.N), r34 = (t60.N >>> 16) + (n50.N >>> 16) + (e42 >>> 16);
    const i28 = (65535 & r34) << 16 | 65535 & e42;
    e42 = (65535 & t60.Y) + (65535 & n50.Y) + (r34 >>> 16), r34 = (t60.Y >>> 16) + (n50.Y >>> 16) + (e42 >>> 16);
    return new B((65535 & r34) << 16 | 65535 & e42, i28);
}
function X(t61, n51, e43, r35) {
    let i29, s20;
    i29 = (65535 & t61.N) + (65535 & n51.N) + (65535 & e43.N) + (65535 & r35.N), s20 = (t61.N >>> 16) + (n51.N >>> 16) + (e43.N >>> 16) + (r35.N >>> 16) + (i29 >>> 16);
    const o18 = (65535 & s20) << 16 | 65535 & i29;
    i29 = (65535 & t61.Y) + (65535 & n51.Y) + (65535 & e43.Y) + (65535 & r35.Y) + (s20 >>> 16), s20 = (t61.Y >>> 16) + (n51.Y >>> 16) + (e43.Y >>> 16) + (r35.Y >>> 16) + (i29 >>> 16);
    return new B((65535 & s20) << 16 | 65535 & i29, o18);
}
function z(t62, n52, e44, r36, i30) {
    let s21, o19;
    s21 = (65535 & t62.N) + (65535 & n52.N) + (65535 & e44.N) + (65535 & r36.N) + (65535 & i30.N), o19 = (t62.N >>> 16) + (n52.N >>> 16) + (e44.N >>> 16) + (r36.N >>> 16) + (i30.N >>> 16) + (s21 >>> 16);
    const h16 = (65535 & o19) << 16 | 65535 & s21;
    s21 = (65535 & t62.Y) + (65535 & n52.Y) + (65535 & e44.Y) + (65535 & r36.Y) + (65535 & i30.Y) + (o19 >>> 16), o19 = (t62.Y >>> 16) + (n52.Y >>> 16) + (e44.Y >>> 16) + (r36.Y >>> 16) + (i30.Y >>> 16) + (s21 >>> 16);
    return new B((65535 & o19) << 16 | 65535 & s21, h16);
}
function x(t63, n53) {
    return new B(t63.Y ^ n53.Y, t63.N ^ n53.N);
}
function _(t64) {
    const n54 = M(t64, 19), e45 = M(t64, 61), r37 = k(t64, 6);
    return new B(n54.Y ^ e45.Y ^ r37.Y, n54.N ^ e45.N ^ r37.N);
}
function O(t65) {
    const n55 = M(t65, 1), e46 = M(t65, 8), r38 = k(t65, 7);
    return new B(n55.Y ^ e46.Y ^ r38.Y, n55.N ^ e46.N ^ r38.N);
}
function P(t66) {
    const n56 = M(t66, 14), e47 = M(t66, 18), r39 = M(t66, 41);
    return new B(n56.Y ^ e47.Y ^ r39.Y, n56.N ^ e47.N ^ r39.N);
}
const V = [
    new B(i[0], 3609767458),
    new B(i[1], 602891725),
    new B(i[2], 3964484399),
    new B(i[3], 2173295548),
    new B(i[4], 4081628472),
    new B(i[5], 3053834265),
    new B(i[6], 2937671579),
    new B(i[7], 3664609560),
    new B(i[8], 2734883394),
    new B(i[9], 1164996542),
    new B(i[10], 1323610764),
    new B(i[11], 3590304994),
    new B(i[12], 4068182383),
    new B(i[13], 991336113),
    new B(i[14], 633803317),
    new B(i[15], 3479774868),
    new B(i[16], 2666613458),
    new B(i[17], 944711139),
    new B(i[18], 2341262773),
    new B(i[19], 2007800933),
    new B(i[20], 1495990901),
    new B(i[21], 1856431235),
    new B(i[22], 3175218132),
    new B(i[23], 2198950837),
    new B(i[24], 3999719339),
    new B(i[25], 766784016),
    new B(i[26], 2566594879),
    new B(i[27], 3203337956),
    new B(i[28], 1034457026),
    new B(i[29], 2466948901),
    new B(i[30], 3758326383),
    new B(i[31], 168717936),
    new B(i[32], 1188179964),
    new B(i[33], 1546045734),
    new B(i[34], 1522805485),
    new B(i[35], 2643833823),
    new B(i[36], 2343527390),
    new B(i[37], 1014477480),
    new B(i[38], 1206759142),
    new B(i[39], 344077627),
    new B(i[40], 1290863460),
    new B(i[41], 3158454273),
    new B(i[42], 3505952657),
    new B(i[43], 106217008),
    new B(i[44], 3606008344),
    new B(i[45], 1432725776),
    new B(i[46], 1467031594),
    new B(i[47], 851169720),
    new B(i[48], 3100823752),
    new B(i[49], 1363258195),
    new B(i[50], 3750685593),
    new B(i[51], 3785050280),
    new B(i[52], 3318307427),
    new B(i[53], 3812723403),
    new B(i[54], 2003034995),
    new B(i[55], 3602036899),
    new B(i[56], 1575990012),
    new B(i[57], 1125592928),
    new B(i[58], 2716904306),
    new B(i[59], 442776044),
    new B(i[60], 593698344),
    new B(i[61], 3733110249),
    new B(i[62], 2999351573),
    new B(i[63], 3815920427),
    new B(3391569614, 3928383900),
    new B(3515267271, 566280711),
    new B(3940187606, 3454069534),
    new B(4118630271, 4000239992),
    new B(116418474, 1914138554),
    new B(174292421, 2731055270),
    new B(289380356, 3203993006),
    new B(460393269, 320620315),
    new B(685471733, 587496836),
    new B(852142971, 1086792851),
    new B(1017036298, 365543100),
    new B(1126000580, 2618297676),
    new B(1288033470, 3409855158),
    new B(1501505948, 4234509866),
    new B(1607167915, 987167468),
    new B(1816402316, 1246189591)
];
function Z(t67) {
    return "SHA-384" === t67 ? [
        new B(3418070365, s[0]),
        new B(1654270250, s[1]),
        new B(2438529370, s[2]),
        new B(355462360, s[3]),
        new B(1731405415, s[4]),
        new B(41048885895, s[5]),
        new B(3675008525, s[6]),
        new B(1203062813, s[7])
    ] : [
        new B(o[0], 4089235720),
        new B(o[1], 2227873595),
        new B(o[2], 4271175723),
        new B(o[3], 1595750129),
        new B(o[4], 2917565137),
        new B(o[5], 725511199),
        new B(o[6], 4215389547),
        new B(o[7], 327033209)
    ];
}
function j(t68, n57) {
    let e48, r40, i31, s22, o20, h17, u11, w9, c7, f5, a5, l3;
    const A3 = [];
    for(e48 = n57[0], r40 = n57[1], i31 = n57[2], s22 = n57[3], o20 = n57[4], h17 = n57[5], u11 = n57[6], w9 = n57[7], a5 = 0; a5 < 80; a5 += 1)a5 < 16 ? (l3 = 2 * a5, A3[a5] = new B(t68[l3], t68[l3 + 1])) : A3[a5] = X(_(A3[a5 - 2]), A3[a5 - 7], O(A3[a5 - 15]), A3[a5 - 16]), c7 = z(w9, P(o20), (H2 = h17, S1 = u11, new B((E4 = o20).Y & H2.Y ^ ~E4.Y & S1.Y, E4.N & H2.N ^ ~E4.N & S1.N)), V[a5], A3[a5]), f5 = I(N(e48), Y(e48, r40, i31)), w9 = u11, u11 = h17, h17 = o20, o20 = I(s22, c7), s22 = i31, i31 = r40, r40 = e48, e48 = I(c7, f5);
    var E4, H2, S1;
    return n57[0] = I(e48, n57[0]), n57[1] = I(r40, n57[1]), n57[2] = I(i31, n57[2]), n57[3] = I(s22, n57[3]), n57[4] = I(o20, n57[4]), n57[5] = I(h17, n57[5]), n57[6] = I(u11, n57[6]), n57[7] = I(w9, n57[7]), n57;
}
class q extends f {
    constructor(t69, n58, r41){
        if ("SHA-384" !== t69 && "SHA-512" !== t69) throw new Error(h);
        super(t69, n58, r41);
        const i32 = r41 || {};
        this.T = this.k, this.L = !0, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = j, this.g = function(t70) {
            return t70.slice();
        }, this.B = Z, this.F = function(n59, e49, r42, i33) {
            return function(t71, n60, e50, r43, i34) {
                let s23, o21;
                const h18 = 31 + (n60 + 129 >>> 10 << 5), u12 = n60 + e50;
                for(; t71.length <= h18;)t71.push(0);
                for(t71[n60 >>> 5] |= 128 << 24 - n60 % 32, t71[h18] = 4294967295 & u12, t71[h18 - 1] = u12 / 4294967296 | 0, s23 = 0; s23 < t71.length; s23 += 32)r43 = j(t71.slice(s23, s23 + 32), r43);
                return o21 = "SHA-384" === i34 ? [
                    (r43 = r43)[0].Y,
                    r43[0].N,
                    r43[1].Y,
                    r43[1].N,
                    r43[2].Y,
                    r43[2].N,
                    r43[3].Y,
                    r43[3].N,
                    r43[4].Y,
                    r43[4].N,
                    r43[5].Y,
                    r43[5].N
                ] : [
                    r43[0].Y,
                    r43[0].N,
                    r43[1].Y,
                    r43[1].N,
                    r43[2].Y,
                    r43[2].N,
                    r43[3].Y,
                    r43[3].N,
                    r43[4].Y,
                    r43[4].N,
                    r43[5].Y,
                    r43[5].N,
                    r43[6].Y,
                    r43[6].N,
                    r43[7].Y,
                    r43[7].N
                ], o21;
            }(n59, e49, r42, i33, t69);
        }, this.C = Z(t69), this.p = 1024, this.U = "SHA-384" === t69 ? 384 : 512, this.v = !1, i32.hmacKey && this.M(c("hmacKey", i32.hmacKey, this.K));
    }
}
const D = [
    new B(0, 1),
    new B(0, 32898),
    new B(2147483648, 32906),
    new B(2147483648, 2147516416),
    new B(0, 32907),
    new B(0, 2147483649),
    new B(2147483648, 2147516545),
    new B(2147483648, 32777),
    new B(0, 138),
    new B(0, 136),
    new B(0, 2147516425),
    new B(0, 2147483658),
    new B(0, 2147516555),
    new B(2147483648, 139),
    new B(2147483648, 32905),
    new B(2147483648, 32771),
    new B(2147483648, 32770),
    new B(2147483648, 128),
    new B(0, 32778),
    new B(2147483648, 2147483658),
    new B(2147483648, 2147516545),
    new B(2147483648, 32896),
    new B(0, 2147483649),
    new B(2147483648, 2147516424)
], G = [
    [
        0,
        36,
        3,
        41,
        18
    ],
    [
        1,
        44,
        10,
        45,
        2
    ],
    [
        62,
        6,
        43,
        15,
        61
    ],
    [
        28,
        55,
        25,
        21,
        56
    ],
    [
        27,
        20,
        39,
        8,
        14
    ]
];
function J(t) {
    let n61;
    const e51 = [];
    for(n61 = 0; n61 < 5; n61 += 1)e51[n61] = [
        new B(0, 0),
        new B(0, 0),
        new B(0, 0),
        new B(0, 0),
        new B(0, 0)
    ];
    return e51;
}
function Q(t72) {
    let n62;
    const e52 = [];
    for(n62 = 0; n62 < 5; n62 += 1)e52[n62] = t72[n62].slice();
    return e52;
}
function W(t73, n63) {
    let e53, r44, i35, s24;
    const o22 = [], h19 = [];
    if (null !== t73) for(r44 = 0; r44 < t73.length; r44 += 2)n63[(r44 >>> 1) % 5][(r44 >>> 1) / 5 | 0] = x(n63[(r44 >>> 1) % 5][(r44 >>> 1) / 5 | 0], new B(t73[r44 + 1], t73[r44]));
    for(e53 = 0; e53 < 24; e53 += 1){
        for(s24 = J(), r44 = 0; r44 < 5; r44 += 1)o22[r44] = (u13 = n63[r44][0], w10 = n63[r44][1], c8 = n63[r44][2], f6 = n63[r44][3], a6 = n63[r44][4], new B(u13.Y ^ w10.Y ^ c8.Y ^ f6.Y ^ a6.Y, u13.N ^ w10.N ^ c8.N ^ f6.N ^ a6.N));
        for(r44 = 0; r44 < 5; r44 += 1)h19[r44] = x(o22[(r44 + 4) % 5], L(o22[(r44 + 1) % 5], 1));
        for(r44 = 0; r44 < 5; r44 += 1)for(i35 = 0; i35 < 5; i35 += 1)n63[r44][i35] = x(n63[r44][i35], h19[r44]);
        for(r44 = 0; r44 < 5; r44 += 1)for(i35 = 0; i35 < 5; i35 += 1)s24[i35][(2 * r44 + 3 * i35) % 5] = L(n63[r44][i35], G[r44][i35]);
        for(r44 = 0; r44 < 5; r44 += 1)for(i35 = 0; i35 < 5; i35 += 1)n63[r44][i35] = x(s24[r44][i35], new B(~s24[(r44 + 1) % 5][i35].Y & s24[(r44 + 2) % 5][i35].Y, ~s24[(r44 + 1) % 5][i35].N & s24[(r44 + 2) % 5][i35].N));
        n63[0][0] = x(n63[0][0], D[e53]);
    }
    var u13, w10, c8, f6, a6;
    return n63;
}
function $(t74) {
    let n64, e54, r45 = 0;
    const i36 = [
        0,
        0
    ], s25 = [
        4294967295 & t74,
        t74 / 4294967296 & 2097151
    ];
    for(n64 = 6; n64 >= 0; n64--)e54 = s25[n64 >> 2] >>> 8 * n64 & 255, 0 === e54 && 0 === r45 || (i36[r45 + 1 >> 2] |= e54 << 8 * (r45 + 1), r45 += 1);
    return r45 = 0 !== r45 ? r45 : 1, i36[0] |= r45, {
        value: r45 + 1 > 4 ? i36 : [
            i36[0]
        ],
        binLen: 8 + 8 * r45
    };
}
function tt(t75) {
    return u($(t75.binLen), t75);
}
function nt(t76, n65) {
    let e55, r46 = $(n65);
    r46 = u(r46, t76);
    const i37 = n65 >>> 2, s26 = (i37 - r46.value.length % i37) % i37;
    for(e55 = 0; e55 < s26; e55++)r46.value.push(0);
    return r46.value;
}
class et extends f {
    constructor(t77, n66, r47){
        let i38 = 6, s27 = 0;
        super(t77, n66, r47);
        const o23 = r47 || {};
        if (1 !== this.numRounds) {
            if (o23.kmacKey || o23.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === this.s || "CSHAKE256" === this.s) throw new Error("Cannot set numRounds for CSHAKE variants");
        }
        switch(this.K = 1, this.m = e(this.t, this.i, this.K), this.R = W, this.g = Q, this.B = J, this.C = J(), this.v = !1, t77){
            case "SHA3-224":
                this.p = s27 = 1152, this.U = 224, this.L = !0, this.T = this.k;
                break;
            case "SHA3-256":
                this.p = s27 = 1088, this.U = 256, this.L = !0, this.T = this.k;
                break;
            case "SHA3-384":
                this.p = s27 = 832, this.U = 384, this.L = !0, this.T = this.k;
                break;
            case "SHA3-512":
                this.p = s27 = 576, this.U = 512, this.L = !0, this.T = this.k;
                break;
            case "SHAKE128":
                i38 = 31, this.p = s27 = 1344, this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "SHAKE256":
                i38 = 31, this.p = s27 = 1088, this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "KMAC128":
                i38 = 4, this.p = s27 = 1344, this.I(r47), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
                break;
            case "KMAC256":
                i38 = 4, this.p = s27 = 1088, this.I(r47), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
                break;
            case "CSHAKE128":
                this.p = s27 = 1344, i38 = this._(r47), this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "CSHAKE256":
                this.p = s27 = 1088, i38 = this._(r47), this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            default:
                throw new Error(h);
        }
        this.F = function(t78, n67, e, r48, o24) {
            return function(t79, n68, e, r49, i39, s28, o25) {
                let h20, u14, w11 = 0;
                const c9 = [], f7 = i39 >>> 5, a7 = n68 >>> 5;
                for(h20 = 0; h20 < a7 && n68 >= i39; h20 += f7)r49 = W(t79.slice(h20, h20 + f7), r49), n68 -= i39;
                for(t79 = t79.slice(h20), n68 %= i39; t79.length < f7;)t79.push(0);
                for(h20 = n68 >>> 3, t79[h20 >> 2] ^= s28 << h20 % 4 * 8, t79[f7 - 1] ^= 2147483648, r49 = W(t79, r49); 32 * c9.length < o25 && (u14 = r49[w11 % 5][w11 / 5 | 0], c9.push(u14.N), !(32 * c9.length >= o25));)c9.push(u14.Y), w11 += 1, 0 == 64 * w11 % i39 && (W(null, r49), w11 = 0);
                return c9;
            }(t78, n67, 0, r48, s27, i38, o24);
        }, o23.hmacKey && this.M(c("hmacKey", o23.hmacKey, this.K));
    }
    _(t80, n69) {
        const e56 = function(t81) {
            const n70 = t81 || {};
            return {
                funcName: c("funcName", n70.funcName, 1, {
                    value: [],
                    binLen: 0
                }),
                customization: c("Customization", n70.customization, 1, {
                    value: [],
                    binLen: 0
                })
            };
        }(t80 || {});
        n69 && (e56.funcName = n69);
        const r50 = u(tt(e56.funcName), tt(e56.customization));
        if (0 !== e56.customization.binLen || 0 !== e56.funcName.binLen) {
            const t82 = nt(r50, this.p >>> 3);
            for(let n71 = 0; n71 < t82.length; n71 += this.p >>> 5)this.C = this.R(t82.slice(n71, n71 + (this.p >>> 5)), this.C), this.l += this.p;
            return 4;
        }
        return 31;
    }
    I(t84) {
        const n72 = function(t85) {
            const n73 = t85 || {};
            return {
                kmacKey: c("kmacKey", n73.kmacKey, 1),
                funcName: {
                    value: [
                        1128353099
                    ],
                    binLen: 32
                },
                customization: c("Customization", n73.customization, 1, {
                    value: [],
                    binLen: 0
                })
            };
        }(t84 || {});
        this._(t84, n72.funcName);
        const e57 = nt(tt(n72.kmacKey), this.p >>> 3);
        for(let t83 = 0; t83 < e57.length; t83 += this.p >>> 5)this.C = this.R(e57.slice(t83, t83 + (this.p >>> 5)), this.C), this.l += this.p;
        this.A = !0;
    }
    X(t86) {
        const n74 = u({
            value: this.o.slice(),
            binLen: this.h
        }, function(t87) {
            let n75, e58, r51 = 0;
            const i40 = [
                0,
                0
            ], s29 = [
                4294967295 & t87,
                t87 / 4294967296 & 2097151
            ];
            for(n75 = 6; n75 >= 0; n75--)e58 = s29[n75 >> 2] >>> 8 * n75 & 255, 0 === e58 && 0 === r51 || (i40[r51 >> 2] |= e58 << 8 * r51, r51 += 1);
            return r51 = 0 !== r51 ? r51 : 1, i40[r51 >> 2] |= r51 << 8 * r51, {
                value: r51 + 1 > 4 ? i40 : [
                    i40[0]
                ],
                binLen: 8 + 8 * r51
            };
        }(t86.outputLen));
        return this.F(n74.value, n74.binLen, this.l, this.g(this.C), t86.outputLen);
    }
}
class jsSHA {
    constructor(t88, n76, e59){
        if ("SHA-1" == t88) this.O = new K(t88, n76, e59);
        else if ("SHA-224" == t88 || "SHA-256" == t88) this.O = new g(t88, n76, e59);
        else if ("SHA-384" == t88 || "SHA-512" == t88) this.O = new q(t88, n76, e59);
        else {
            if ("SHA3-224" != t88 && "SHA3-256" != t88 && "SHA3-384" != t88 && "SHA3-512" != t88 && "SHAKE128" != t88 && "SHAKE256" != t88 && "CSHAKE128" != t88 && "CSHAKE256" != t88 && "KMAC128" != t88 && "KMAC256" != t88) throw new Error(h);
            this.O = new et(t88, n76, e59);
        }
    }
    update(t89) {
        this.O.update(t89);
    }
    getHash(t90, n77) {
        return this.O.getHash(t90, n77);
    }
    setHMACKey(t91, n78, e60) {
        this.O.setHMACKey(t91, n78, e60);
    }
    getHMAC(t92, n79) {
        return this.O.getHMAC(t92, n79);
    }
}
const globalScope = (()=>{
    if (typeof globalThis === "object") return globalThis;
    else {
        Object.defineProperty(Object.prototype, "__GLOBALTHIS__", {
            get () {
                return this;
            },
            configurable: true
        });
        try {
            if (typeof __GLOBALTHIS__ !== "undefined") return __GLOBALTHIS__;
        } finally{
            delete Object.prototype.__GLOBALTHIS__;
        }
    }
    if (typeof self !== "undefined") return self;
    else if (typeof window !== "undefined") return window;
    else if (typeof global !== "undefined") return global;
    return undefined;
})();
const isNode = Object.prototype.toString.call(globalScope.process) === "[object process]";
const nodeRequire = isNode ? eval("require") : ()=>{};
const NodeCrypto$2 = isNode ? nodeRequire("crypto") : undefined;
const OPENSSL_TO_JSSHA_ALGO = {
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512",
    "SHA3-224": "SHA3-224",
    "SHA3-256": "SHA3-256",
    "SHA3-384": "SHA3-384",
    "SHA3-512": "SHA3-512"
};
const hmacDigest = (algorithm, key58, message)=>{
    if (isNode) {
        const hmac = NodeCrypto$2.createHmac(algorithm, globalScope.Buffer.from(key58));
        hmac.update(globalScope.Buffer.from(message));
        return hmac.digest().buffer;
    } else {
        const variant = OPENSSL_TO_JSSHA_ALGO[algorithm.toUpperCase()];
        if (typeof variant === "undefined") {
            throw new TypeError("Unknown hash function");
        }
        const hmac = new jsSHA(variant, "ARRAYBUFFER");
        hmac.setHMACKey(key58, "ARRAYBUFFER");
        hmac.update(message);
        return hmac.getHMAC("ARRAYBUFFER");
    }
};
const pad = (num, digits)=>{
    let prefix = "";
    let repeat = digits - String(num).length;
    while(repeat-- > 0)prefix += "0";
    return `${prefix}${num}`;
};
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
const base32ToBuf = (str20)=>{
    let end = str20.length;
    while(str20[end - 1] === "=")--end;
    const cstr = (end < str20.length ? str20.substring(0, end) : str20).toUpperCase();
    const buf = new ArrayBuffer(cstr.length * 5 / 8 | 0);
    const arr = new Uint8Array(buf);
    let bits = 0;
    let value71 = 0;
    let index = 0;
    for(let i41 = 0; i41 < cstr.length; i41++){
        const idx = ALPHABET.indexOf(cstr[i41]);
        if (idx === -1) throw new TypeError(`Invalid character found: ${cstr[i41]}`);
        value71 = value71 << 5 | idx;
        bits += 5;
        if (bits >= 8) {
            bits -= 8;
            arr[index++] = value71 >>> bits;
        }
    }
    return buf;
};
const base32FromBuf = (buf)=>{
    const arr = new Uint8Array(buf);
    let bits = 0;
    let value72 = 0;
    let str21 = "";
    for(let i42 = 0; i42 < arr.length; i42++){
        value72 = value72 << 8 | arr[i42];
        bits += 8;
        while(bits >= 5){
            str21 += ALPHABET[value72 >>> bits - 5 & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        str21 += ALPHABET[value72 << 5 - bits & 31];
    }
    return str21;
};
const hexToBuf = (str22)=>{
    const buf = new ArrayBuffer(str22.length / 2);
    const arr = new Uint8Array(buf);
    for(let i43 = 0; i43 < str22.length; i43 += 2){
        arr[i43 / 2] = parseInt(str22.substr(i43, 2), 16);
    }
    return buf;
};
const hexFromBuf = (buf)=>{
    const arr = new Uint8Array(buf);
    let str23 = "";
    for(let i44 = 0; i44 < arr.length; i44++){
        const hex = arr[i44].toString(16);
        if (hex.length === 1) str23 += "0";
        str23 += hex;
    }
    return str23.toUpperCase();
};
const latin1ToBuf = (str24)=>{
    const buf = new ArrayBuffer(str24.length);
    const arr = new Uint8Array(buf);
    for(let i45 = 0; i45 < str24.length; i45++){
        arr[i45] = str24.charCodeAt(i45) & 0xff;
    }
    return buf;
};
const latin1FromBuf = (buf)=>{
    const arr = new Uint8Array(buf);
    let str25 = "";
    for(let i46 = 0; i46 < arr.length; i46++){
        str25 += String.fromCharCode(arr[i46]);
    }
    return str25;
};
const ENCODER = globalScope.TextEncoder ? new globalScope.TextEncoder("utf-8") : null;
const DECODER = globalScope.TextDecoder ? new globalScope.TextDecoder("utf-8") : null;
const utf8ToBuf = (str26)=>{
    if (!ENCODER) {
        throw new Error("Encoding API not available");
    }
    return ENCODER.encode(str26).buffer;
};
const utf8FromBuf = (buf)=>{
    if (!DECODER) {
        throw new Error("Encoding API not available");
    }
    return DECODER.decode(buf);
};
const NodeCrypto$1 = isNode ? nodeRequire("crypto") : undefined;
const randomBytes = (size)=>{
    if (isNode) {
        return NodeCrypto$1.randomBytes(size).buffer;
    } else {
        if (!globalScope.crypto || !globalScope.crypto.getRandomValues) {
            throw new Error("Cryptography API not available");
        }
        return globalScope.crypto.getRandomValues(new Uint8Array(size)).buffer;
    }
};
class Secret {
    constructor(){
        let { buffer: buffer4 , size =20  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.buffer = typeof buffer4 === "undefined" ? randomBytes(size) : buffer4;
    }
    static fromLatin1(str27) {
        return new Secret({
            buffer: latin1ToBuf(str27)
        });
    }
    static fromUTF8(str28) {
        return new Secret({
            buffer: utf8ToBuf(str28)
        });
    }
    static fromBase32(str29) {
        return new Secret({
            buffer: base32ToBuf(str29)
        });
    }
    static fromHex(str30) {
        return new Secret({
            buffer: hexToBuf(str30)
        });
    }
    get latin1() {
        Object.defineProperty(this, "latin1", {
            enumerable: true,
            value: latin1FromBuf(this.buffer)
        });
        return this.latin1;
    }
    get utf8() {
        Object.defineProperty(this, "utf8", {
            enumerable: true,
            value: utf8FromBuf(this.buffer)
        });
        return this.utf8;
    }
    get base32() {
        Object.defineProperty(this, "base32", {
            enumerable: true,
            value: base32FromBuf(this.buffer)
        });
        return this.base32;
    }
    get hex() {
        Object.defineProperty(this, "hex", {
            enumerable: true,
            value: hexFromBuf(this.buffer)
        });
        return this.hex;
    }
}
const NodeCrypto = isNode ? nodeRequire("crypto") : undefined;
const timingSafeEqual2 = (a8, b1)=>{
    if (isNode) {
        return NodeCrypto.timingSafeEqual(globalScope.Buffer.from(a8), globalScope.Buffer.from(b1));
    } else {
        if (a8.length !== b1.length) {
            throw new TypeError("Input strings must have the same length");
        }
        let i47 = -1;
        let out = 0;
        while(++i47 < a8.length){
            out |= a8.charCodeAt(i47) ^ b1.charCodeAt(i47);
        }
        return out === 0;
    }
};
class HOTP {
    static get defaults() {
        return {
            issuer: "",
            label: "OTPAuth",
            algorithm: "SHA1",
            digits: 6,
            counter: 0,
            window: 1
        };
    }
    constructor(){
        let { issuer =HOTP.defaults.issuer , label =HOTP.defaults.label , secret: secret1 = new Secret() , algorithm =HOTP.defaults.algorithm , digits =HOTP.defaults.digits , counter =HOTP.defaults.counter  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.issuer = issuer;
        this.label = label;
        this.secret = typeof secret1 === "string" ? Secret.fromBase32(secret1) : secret1;
        this.algorithm = algorithm.toUpperCase();
        this.digits = digits;
        this.counter = counter;
    }
    static generate(_ref) {
        let { secret: secret2 , algorithm =HOTP.defaults.algorithm , digits =HOTP.defaults.digits , counter =HOTP.defaults.counter  } = _ref;
        const digest4 = new Uint8Array(hmacDigest(algorithm, secret2.buffer, uintToBuf(counter)));
        const offset = digest4[digest4.byteLength - 1] & 15;
        const otp = ((digest4[offset] & 127) << 24 | (digest4[offset + 1] & 255) << 16 | (digest4[offset + 2] & 255) << 8 | digest4[offset + 3] & 255) % 10 ** digits;
        return pad(otp, digits);
    }
    generate() {
        let { counter =this.counter++  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return HOTP.generate({
            secret: this.secret,
            algorithm: this.algorithm,
            digits: this.digits,
            counter
        });
    }
    static validate(_ref2) {
        let { token , secret: secret3 , algorithm , digits , counter =HOTP.defaults.counter , window =HOTP.defaults.window  } = _ref2;
        if (token.length !== digits) return null;
        let delta = null;
        for(let i48 = counter - window; i48 <= counter + window; ++i48){
            const generatedToken = HOTP.generate({
                secret: secret3,
                algorithm,
                digits,
                counter: i48
            });
            if (timingSafeEqual2(token, generatedToken)) {
                delta = i48 - counter;
            }
        }
        return delta;
    }
    validate(_ref3) {
        let { token , counter =this.counter , window  } = _ref3;
        return HOTP.validate({
            token,
            secret: this.secret,
            algorithm: this.algorithm,
            digits: this.digits,
            counter,
            window
        });
    }
    toString() {
        const e61 = encodeURIComponent;
        return "otpauth://hotp/" + `${this.issuer.length > 0 ? `${e61(this.issuer)}:${e61(this.label)}?issuer=${e61(this.issuer)}&` : `${e61(this.label)}?`}` + `secret=${e61(this.secret.base32)}&` + `algorithm=${e61(this.algorithm)}&` + `digits=${e61(this.digits)}&` + `counter=${e61(this.counter)}`;
    }
}
class TOTP {
    static get defaults() {
        return {
            issuer: "",
            label: "OTPAuth",
            algorithm: "SHA1",
            digits: 6,
            period: 30,
            window: 1
        };
    }
    constructor(){
        let { issuer =TOTP.defaults.issuer , label =TOTP.defaults.label , secret: secret4 = new Secret() , algorithm =TOTP.defaults.algorithm , digits =TOTP.defaults.digits , period =TOTP.defaults.period  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.issuer = issuer;
        this.label = label;
        this.secret = typeof secret4 === "string" ? Secret.fromBase32(secret4) : secret4;
        this.algorithm = algorithm.toUpperCase();
        this.digits = digits;
        this.period = period;
    }
    static generate(_ref) {
        let { secret: secret5 , algorithm , digits , period =TOTP.defaults.period , timestamp =Date.now()  } = _ref;
        return HOTP.generate({
            secret: secret5,
            algorithm,
            digits,
            counter: Math.floor(timestamp / 1000 / period)
        });
    }
    generate() {
        let { timestamp =Date.now()  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return TOTP.generate({
            secret: this.secret,
            algorithm: this.algorithm,
            digits: this.digits,
            period: this.period,
            timestamp
        });
    }
    static validate(_ref2) {
        let { token , secret: secret6 , algorithm , digits , period =TOTP.defaults.period , timestamp =Date.now() , window  } = _ref2;
        return HOTP.validate({
            token,
            secret: secret6,
            algorithm,
            digits,
            counter: Math.floor(timestamp / 1000 / period),
            window
        });
    }
    validate(_ref3) {
        let { token , timestamp , window  } = _ref3;
        return TOTP.validate({
            token,
            secret: this.secret,
            algorithm: this.algorithm,
            digits: this.digits,
            period: this.period,
            timestamp,
            window
        });
    }
    toString() {
        const e62 = encodeURIComponent;
        return "otpauth://totp/" + `${this.issuer.length > 0 ? `${e62(this.issuer)}:${e62(this.label)}?issuer=${e62(this.issuer)}&` : `${e62(this.label)}?`}` + `secret=${e62(this.secret.base32)}&` + `algorithm=${e62(this.algorithm)}&` + `digits=${e62(this.digits)}&` + `period=${e62(this.period)}`;
    }
}
const OTPURI_REGEX = /^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;
const SECRET_REGEX = /^[2-7A-Z]+=*$/i;
const ALGORITHM_REGEX = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;
const INTEGER_REGEX = /^[+-]?\d+$/;
const POSITIVE_INTEGER_REGEX = /^\+?[1-9]\d*$/;
class URI {
    static parse(uri) {
        let uriGroups;
        try {
            uriGroups = uri.match(OTPURI_REGEX);
        } catch (error) {}
        if (!Array.isArray(uriGroups)) {
            throw new URIError("Invalid URI format");
        }
        const uriType = uriGroups[1].toLowerCase();
        const uriLabel = uriGroups[2].split(/(?::|%3A) *(.+)/i, 2).map(decodeURIComponent);
        const uriParams = uriGroups[3].split("&").reduce((acc, cur)=>{
            const pairArr = cur.split(/=(.*)/, 2).map(decodeURIComponent);
            const pairKey = pairArr[0].toLowerCase();
            const pairVal = pairArr[1];
            const pairAcc = acc;
            pairAcc[pairKey] = pairVal;
            return pairAcc;
        }, {});
        let OTP;
        const config = {};
        if (uriType === "hotp") {
            OTP = HOTP;
            if (typeof uriParams.counter !== "undefined" && INTEGER_REGEX.test(uriParams.counter)) {
                config.counter = parseInt(uriParams.counter, 10);
            } else {
                throw new TypeError("Missing or invalid 'counter' parameter");
            }
        } else if (uriType === "totp") {
            OTP = TOTP;
            if (typeof uriParams.period !== "undefined") {
                if (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {
                    config.period = parseInt(uriParams.period, 10);
                } else {
                    throw new TypeError("Invalid 'period' parameter");
                }
            }
        } else {
            throw new TypeError("Unknown OTP type");
        }
        if (uriLabel.length === 2) {
            config.label = uriLabel[1];
            config.issuer = uriLabel[0];
        } else {
            config.label = uriLabel[0];
            if (typeof uriParams.issuer !== "undefined") {
                config.issuer = uriParams.issuer;
            }
        }
        if (typeof uriParams.secret !== "undefined" && SECRET_REGEX.test(uriParams.secret)) {
            config.secret = uriParams.secret;
        } else {
            throw new TypeError("Missing or invalid 'secret' parameter");
        }
        if (typeof uriParams.algorithm !== "undefined") {
            if (ALGORITHM_REGEX.test(uriParams.algorithm)) {
                config.algorithm = uriParams.algorithm;
            } else {
                throw new TypeError("Invalid 'algorithm' parameter");
            }
        }
        if (typeof uriParams.digits !== "undefined") {
            if (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {
                config.digits = parseInt(uriParams.digits, 10);
            } else {
                throw new TypeError("Invalid 'digits' parameter");
            }
        }
        return new OTP(config);
    }
    static stringify(otp) {
        if (otp instanceof HOTP || otp instanceof TOTP) {
            return otp.toString();
        }
        throw new TypeError("Invalid 'HOTP/TOTP' object");
    }
}
const version = "8.0.2";
const mod17 = {
    HOTP: HOTP,
    Secret: Secret,
    TOTP: TOTP,
    URI: URI,
    version: version
};
const importMeta = {
    url: "https://raw.githubusercontent.com/andre-dietrich/denomailer/main/client/worker/worker.ts",
    main: false
};
class SMTPWorker {
    id = 1;
    #timeout;
    constructor(config){
        this.#config = config;
        this.#timeout = config.pool.timeout;
    }
    #w;
    #idleTO = null;
    #idleMode2 = false;
    #noCon = true;
    #config;
    #resolver = new Map();
     #startup() {
        this.#w = new Worker(new URL("./worker-file.ts", importMeta.url), {
            type: "module",
            deno: {
                permissions: {
                    net: "inherit",
                    read: true
                },
                namespace: true
            }
        });
        this.#w.addEventListener("message", (ev)=>{
            if (typeof ev.data === "object") {
                if ("err" in ev.data) {
                    this.#resolver.get(ev.data.__ret)?.rej(ev.data.err);
                }
                if ("res" in ev.data) {
                    this.#resolver.get(ev.data.__ret)?.res(ev.data.res);
                }
                this.#resolver.delete(ev.data.__ret);
                return;
            }
            if (ev.data) {
                this.#stopIdle();
            } else {
                if (this.#idleMode2) {
                    this.#cleanup();
                } else {
                    this.#startIdle();
                }
            }
        });
        this.#w.postMessage({
            __setup: {
                ...this.#config,
                client: {
                    ...this.#config.client,
                    preprocessors: []
                }
            }
        });
        this.#noCon = false;
    }
     #startIdle() {
        console.log("started idle");
        if (this.#idleTO) {
            return;
        }
        this.#idleTO = setTimeout(()=>{
            console.log("idle mod 2");
            this.#idleMode2 = true;
            this.#w.postMessage({
                __check_idle: true
            });
        }, this.#timeout);
    }
     #stopIdle() {
        if (this.#idleTO) {
            clearTimeout(this.#idleTO);
        }
        this.#idleMode2 = false;
        this.#idleTO = null;
    }
     #cleanup() {
        console.log("killed");
        this.#w.terminate();
        this.#stopIdle();
    }
    send(mail) {
        const myID = this.id;
        this.id++;
        this.#stopIdle();
        if (this.#noCon) {
            this.#startup();
        }
        this.#w.postMessage({
            __mail: myID,
            mail
        });
        return new Promise((res, rej)=>{
            this.#resolver.set(myID, {
                res,
                rej
            });
        });
    }
    close() {
        if (this.#w) this.#w.terminate();
        if (this.#idleTO) {
            clearTimeout(this.#idleTO);
        }
    }
}
class SMTPWorkerPool {
    pool = [];
    constructor(config){
        for(let i79 = 0; i79 < config.pool.size; i79++){
            this.pool.push(new SMTPWorker(config));
        }
    }
    #lastUsed = -1;
    send(mail) {
        this.#lastUsed = (this.#lastUsed + 1) % this.pool.length;
        return this.pool[this.#lastUsed].send(mail);
    }
    close() {
        this.pool.forEach((v12)=>v12.close());
    }
}
class DenoStdInternalError3 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert6(expr, msg22 = "") {
    if (!expr) {
        throw new DenoStdInternalError3(msg22);
    }
}
function concat1(...buf) {
    let length = 0;
    for (const b21 of buf){
        length += b21.length;
    }
    const output = new Uint8Array(length);
    let index = 0;
    for (const b1 of buf){
        output.set(b1, index);
        index += b1.length;
    }
    return output;
}
function copy4(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE4 = 16;
const CR5 = "\r".charCodeAt(0);
const LF5 = "\n".charCodeAt(0);
class BufferFullError4 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError3 extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader4 {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r52, size = 4096) {
        return r52 instanceof BufReader4 ? r52 : new BufReader4(r52, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE4;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i80 = 100; i80 > 0; i80--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert6(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r53) {
        this.#reset(this.#buf, r53);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p35) {
        let rr = p35.byteLength;
        if (p35.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p35.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p35);
                const nread = rr ?? 0;
                assert6(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert6(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy4(this.#buf.subarray(this.#r, this.#w), p35, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p36) {
        let bytesRead = 0;
        while(bytesRead < p36.length){
            try {
                const rr = await this.read(p36.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError3();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError3) {
                    err.partial = p36.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e63 = new PartialReadError3();
                    e63.partial = p36.subarray(0, bytesRead);
                    e63.stack = err.stack;
                    e63.message = err.message;
                    e63.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p36;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c31 = this.#buf[this.#r];
        this.#r++;
        return c31;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer5 = await this.readSlice(delim.charCodeAt(0));
        if (buffer5 === null) return null;
        return new TextDecoder().decode(buffer5);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF5);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError3) {
                partial = err.partial;
                assert6(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError4)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR5) {
                assert6(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF5) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR5) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s30 = 0;
        let slice;
        while(true){
            let i81 = this.#buf.subarray(this.#r + s30, this.#w).indexOf(delim);
            if (i81 >= 0) {
                i81 += s30;
                slice = this.#buf.subarray(this.#r, this.#r + i81 + 1);
                this.#r += i81 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError4(oldbuf);
            }
            s30 = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError3) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e64 = new PartialReadError3();
                    e64.partial = slice;
                    e64.stack = err.stack;
                    e64.message = err.message;
                    e64.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError3) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e65 = new PartialReadError3();
                    e65.partial = this.#buf.subarray(this.#r, this.#w);
                    e65.stack = err.stack;
                    e65.message = err.message;
                    e65.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError4(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase3 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter3 extends AbstractBufBase3 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter3 ? writer : new BufWriter3(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w12) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w12;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p37 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p37.length){
                nwritten += await this.#writer.write(p37.subarray(nwritten));
            }
        } catch (e66) {
            if (e66 instanceof Error) {
                this.err = e66;
            }
            throw e66;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e67) {
                    if (e67 instanceof Error) {
                        this.err = e67;
                    }
                    throw e67;
                }
            } else {
                numBytesWritten = copy4(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy4(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync3 extends AbstractBufBase3 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync3 ? writer : new BufWriterSync3(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w13) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w13;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p38 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p38.length){
                nwritten += this.#writer.writeSync(p38.subarray(nwritten));
            }
        } catch (e68) {
            if (e68 instanceof Error) {
                this.err = e68;
            }
            throw e68;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e69) {
                    if (e69 instanceof Error) {
                        this.err = e69;
                    }
                    throw e69;
                }
            } else {
                numBytesWritten = copy4(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy4(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const CHAR_SPACE = " ".charCodeAt(0);
const CHAR_TAB = "\t".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const WHITESPACES = [
    CHAR_SPACE,
    CHAR_TAB
];
const decoder4 = new TextDecoder();
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
function str(buf) {
    return !buf ? "" : decoder4.decode(buf);
}
class TextProtoReader {
    constructor(r54){
        this.r = r54;
    }
    async readLine() {
        const s31 = await this.readLineSlice();
        return s31 === null ? null : str(s31);
    }
    async readMIMEHeader() {
        const m16 = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (WHITESPACES.includes(buf[0])) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (WHITESPACES.includes(buf[0])) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m16;
            let i82 = kv.indexOf(CHAR_COLON);
            if (i82 < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
            }
            const key59 = str(kv.subarray(0, i82));
            if (key59 == "") {
                continue;
            }
            i82++;
            while(i82 < kv.byteLength && WHITESPACES.includes(kv[i82])){
                i82++;
            }
            const value73 = str(kv.subarray(i82)).replace(invalidHeaderCharRegex, encodeURI);
            try {
                m16.append(key59, value73);
            } catch  {}
        }
    }
    async readLineSlice() {
        let line = new Uint8Array(0);
        let r55 = null;
        do {
            r55 = await this.r.readLine();
            if (r55 !== null && this.skipSpace(r55.line) !== 0) {
                line = concat1(line, r55.line);
            }
        }while (r55 !== null && r55.more)
        return r55 === null ? null : line;
    }
    skipSpace(l4) {
        let n80 = 0;
        for (const val of l4){
            if (!WHITESPACES.includes(val)) {
                n80++;
            }
        }
        return n80;
    }
    r;
}
const base64abc3 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode4(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i83;
    const l5 = uint8.length;
    for(i83 = 2; i83 < l5; i83 += 3){
        result += base64abc3[uint8[i83 - 2] >> 2];
        result += base64abc3[(uint8[i83 - 2] & 0x03) << 4 | uint8[i83 - 1] >> 4];
        result += base64abc3[(uint8[i83 - 1] & 0x0f) << 2 | uint8[i83] >> 6];
        result += base64abc3[uint8[i83] & 0x3f];
    }
    if (i83 === l5 + 1) {
        result += base64abc3[uint8[i83 - 2] >> 2];
        result += base64abc3[(uint8[i83 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i83 === l5) {
        result += base64abc3[uint8[i83 - 2] >> 2];
        result += base64abc3[(uint8[i83 - 2] & 0x03) << 4 | uint8[i83 - 1] >> 4];
        result += base64abc3[(uint8[i83 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
const encoder6 = new TextEncoder();
class SMTPConnection {
    secure;
    conn;
    #reader;
    #writer;
    constructor(config){
        this.config = config;
        this.secure = false;
        this.conn = null;
        this.#reader = null;
        this.#writer = null;
        this.ready = this.#connect();
    }
    ready;
    async close() {
        await this.ready;
        if (!this.conn) {
            return;
        }
        await this.conn.close();
    }
    setupConnection(conn) {
        this.conn = conn;
        const reader1 = new BufReader4(this.conn);
        this.#writer = new BufWriter3(this.conn);
        this.#reader = new TextProtoReader(reader1);
    }
    async #connect() {
        if (this.config.connection.tls) {
            this.conn = await Deno.connectTls({
                hostname: this.config.connection.hostname,
                port: this.config.connection.port
            });
            this.secure = true;
        } else {
            this.conn = await Deno.connect({
                hostname: this.config.connection.hostname,
                port: this.config.connection.port
            });
        }
        this.setupConnection(this.conn);
    }
    assertCode(cmd, code38, msg23) {
        if (!cmd) {
            throw new Error(`invalid cmd`);
        }
        if (cmd.code !== code38) {
            throw new Error(msg23 || cmd.code + ": " + cmd.args);
        }
    }
    async readCmd() {
        if (!this.#reader) {
            return null;
        }
        const result = [];
        while(result.length === 0 || result.at(-1) && result.at(-1).at(3) === "-"){
            result.push(await this.#reader.readLine());
        }
        const nonNullResult = result.at(-1) === null ? result.slice(0, result.length - 1) : result;
        if (nonNullResult.length === 0) return null;
        const code39 = parseInt(nonNullResult[0].slice(0, 3));
        const data = nonNullResult.map((v13)=>v13.slice(4).trim());
        if (this.config.debug.log) {
            nonNullResult.forEach((v14)=>console.log(v14));
        }
        return {
            code: code39,
            args: data
        };
    }
    async writeCmd(...args14) {
        if (!this.#writer) {
            return null;
        }
        if (this.config.debug.log) {
            console.table(args14);
        }
        const data = encoder6.encode([
            ...args14
        ].join(" ") + "\r\n");
        await this.#writer.write(data);
        await this.#writer.flush();
    }
    async writeCmdBinary(...args15) {
        if (!this.#writer) {
            return null;
        }
        if (this.config.debug.log) {
            console.table(args15.map(()=>"Uint8Attay"));
        }
        for(let i84 = 0; i84 < args15.length; i84++){
            await this.#writer.write(args15[i84]);
        }
        await this.#writer.flush();
    }
    config;
}
const CommandCode = {
    READY: 220,
    AUTHO_SUCCESS: 235,
    OK: 250,
    BEGIN_DATA: 354,
    FAIL: 554
};
class QUE {
    running = false;
    #que = [];
    idle = Promise.resolve();
    #idbleCB;
    que() {
        if (!this.running) {
            this.running = true;
            this.idle = new Promise((res)=>{
                this.#idbleCB = res;
            });
            return Promise.resolve();
        }
        return new Promise((res)=>{
            this.#que.push(res);
        });
    }
    next() {
        if (this.#que.length === 0) {
            this.running = false;
            if (this.#idbleCB) this.#idbleCB();
            return;
        }
        this.#que[0]();
        this.#que.splice(0, 1);
    }
}
class SMTPClient {
    #connection;
    #que;
    constructor(config){
        this.config = config;
        this.#que = new QUE();
        this.#supportedFeatures = new Set();
        const c32 = new SMTPConnection(config);
        this.#connection = c32;
        const self = this;
        this.#ready = (async ()=>{
            c32.ready.then(()=>{
                self.#prepareConnection().catch((err)=>{
                    console.warn("prepare connection error:", err);
                });
            }).catch((err)=>{
                console.warn("connection ready error:", err);
            });
        })();
    }
    #ready;
    close() {
        return this.#connection.close();
    }
    get isSending() {
        return this.#que.running;
    }
    get idle() {
        return this.#que.idle;
    }
    async send(config) {
        await this.#ready;
        try {
            await this.#que.que();
            await this.#connection.writeCmd("MAIL", "FROM:", `<${config.from.mail}>`);
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            for(let i85 = 0; i85 < config.to.length; i85++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.to[i85].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            for(let i1 = 0; i1 < config.cc.length; i1++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.cc[i1].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            for(let i2 = 0; i2 < config.bcc.length; i2++){
                await this.#connection.writeCmd("RCPT", "TO:", `<${config.bcc[i2].mail}>`);
                this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            }
            await this.#connection.writeCmd("DATA");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.BEGIN_DATA);
            await this.#connection.writeCmd("Subject: ", config.subject);
            await this.#connection.writeCmd("From: ", `${config.from.name} <${config.from.mail}>`);
            if (config.to.length > 0) {
                await this.#connection.writeCmd("To: ", config.to.map((m17)=>`${m17.name} <${m17.mail}>`).join(";"));
            }
            if (config.cc.length > 0) {
                await this.#connection.writeCmd("Cc: ", config.cc.map((m18)=>`${m18.name} <${m18.mail}>`).join(";"));
            }
            await this.#connection.writeCmd("Date: ", config.date);
            const obj = Object.entries(config.headers);
            for(let i3 = 0; i3 < obj.length; i3++){
                const [name2, value74] = obj[i3];
                await this.#connection.writeCmd(name2 + ": ", value74);
            }
            if (config.inReplyTo) {
                await this.#connection.writeCmd("InReplyTo: ", config.inReplyTo);
            }
            if (config.references) {
                await this.#connection.writeCmd("Refrences: ", config.references);
            }
            if (config.replyTo) {
                await this.#connection.writeCmd("ReplyTo: ", `${config.replyTo.name} <${config.replyTo.name}>`);
            }
            if (config.priority) {
                await this.#connection.writeCmd("Priority:", config.priority);
            }
            await this.#connection.writeCmd("MIME-Version: 1.0");
            let boundaryAdditionAtt = 100;
            config.mimeContent.map((v15)=>v15.content).join("\n").replace(new RegExp("--attachment([0-9]+)", "g"), (_, numb)=>{
                boundaryAdditionAtt += parseInt(numb, 10);
                return "";
            });
            config.attachments.map((v16)=>{
                return v16.content;
            }).join("\n").replace(new RegExp("--attachment([0-9]+)", "g"), (_, numb)=>{
                boundaryAdditionAtt += parseInt(numb, 10);
                return "";
            });
            const attachmentBoundary = `attachment${boundaryAdditionAtt}`;
            await this.#connection.writeCmd(`Content-Type: multipart/mixed; boundary=${attachmentBoundary}`, "\r\n");
            await this.#connection.writeCmd(`--${attachmentBoundary}`);
            let boundaryAddition = 100;
            config.mimeContent.map((v17)=>v17.content).join("\n").replace(new RegExp("--message([0-9]+)", "g"), (_, numb)=>{
                boundaryAddition += parseInt(numb, 10);
                return "";
            });
            const messageBoundary = `message${boundaryAddition}`;
            await this.#connection.writeCmd(`Content-Type: multipart/alternative; boundary=${messageBoundary}`, "\r\n");
            for(let i4 = 0; i4 < config.mimeContent.length; i4++){
                await this.#connection.writeCmd(`--${messageBoundary}`);
                await this.#connection.writeCmd("Content-Type: " + config.mimeContent[i4].mimeType);
                if (config.mimeContent[i4].transferEncoding) {
                    await this.#connection.writeCmd(`Content-Transfer-Encoding: ${config.mimeContent[i4].transferEncoding}` + "\r\n");
                } else {
                    await this.#connection.writeCmd("");
                }
                await this.#connection.writeCmd(config.mimeContent[i4].content, "\r\n");
            }
            await this.#connection.writeCmd(`--${messageBoundary}--\r\n`);
            for(let i5 = 0; i5 < config.attachments.length; i5++){
                const attachment = config.attachments[i5];
                await this.#connection.writeCmd(`--${attachmentBoundary}`);
                await this.#connection.writeCmd("Content-Type:", attachment.contentType + ";", "name=" + attachment.filename);
                if (attachment.contentID) {
                    await this.#connection.writeCmd(`Content-ID: <${attachment.contentID}>`);
                }
                await this.#connection.writeCmd("Content-Disposition: attachment; filename=" + attachment.filename);
                if (attachment.encoding === "base64") {
                    await this.#connection.writeCmd("Content-Transfer-Encoding: base64", "\r\n");
                    for(let line = 0; line < Math.ceil(attachment.content.length / 75); line++){
                        const lineOfBase64 = attachment.content.slice(line * 75, (line + 1) * 75);
                        await this.#connection.writeCmd(lineOfBase64);
                    }
                    await this.#connection.writeCmd("\r\n");
                } else if (attachment.encoding === "text") {
                    await this.#connection.writeCmd("Content-Transfer-Encoding: quoted-printable", "\r\n");
                    await this.#connection.writeCmd(attachment.content, "\r\n");
                }
            }
            await this.#connection.writeCmd(`--${attachmentBoundary}--\r\n`);
            await this.#connection.writeCmd(".\r\n");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.OK);
            await this.#cleanup();
            this.#que.next();
        } catch (ex) {
            await this.#cleanup();
            this.#que.next();
            throw ex;
        }
    }
    async #prepareConnection() {
        this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.READY);
        await this.#connection.writeCmd("EHLO", this.config.connection.hostname);
        const cmd1 = await this.#connection.readCmd();
        if (!cmd1) throw new Error("Unexpected empty response");
        if (typeof cmd1.args === "string") {
            this.#supportedFeatures.add(cmd1.args);
        } else {
            cmd1.args.forEach((cmd2)=>{
                this.#supportedFeatures.add(cmd2);
            });
        }
        if (this.#supportedFeatures.has("STARTTLS") && !this.config.debug.noStartTLS) {
            await this.#connection.writeCmd("STARTTLS");
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.READY);
            const conn = await Deno.startTls(this.#connection.conn, {
                hostname: this.config.connection.hostname
            });
            this.#connection.setupConnection(conn);
            this.#connection.secure = true;
            await this.#connection.writeCmd("EHLO", this.config.connection.hostname);
            await this.#connection.readCmd();
        }
        if (!this.config.debug.allowUnsecure && !this.#connection.secure) {
            this.#connection.close();
            this.#connection = null;
            throw new Error("Connection is not secure! Don't send authentication over non secure connection!");
        }
        if (this.config.connection.auth) {
            await this.#connection.writeCmd("AUTH", "LOGIN");
            this.#connection.assertCode(await this.#connection.readCmd(), 334);
            await this.#connection.writeCmd(btoa(this.config.connection.auth.username));
            this.#connection.assertCode(await this.#connection.readCmd(), 334);
            await this.#connection.writeCmd(btoa(this.config.connection.auth.password));
            this.#connection.assertCode(await this.#connection.readCmd(), CommandCode.AUTHO_SUCCESS);
        }
        await this.#cleanup();
    }
    #supportedFeatures;
    async #cleanup() {
        this.#connection.writeCmd("NOOP");
        while(true){
            const cmd = await this.#connection.readCmd();
            if (cmd && cmd.code === 250) return;
        }
    }
    config;
}
function resolveClientOptions(config) {
    return {
        debug: {
            log: config.debug?.log ?? false,
            allowUnsecure: config.debug?.allowUnsecure ?? false,
            encodeLB: config.debug?.encodeLB ?? false,
            noStartTLS: config.debug?.noStartTLS ?? false
        },
        connection: {
            hostname: config.connection.hostname,
            port: config.connection.port ?? (config.connection.tls ? 465 : 25),
            tls: config.connection.tls ?? false,
            auth: config.connection.auth
        },
        pool: config.pool ? config.pool === true ? {
            size: 2,
            timeout: 60000
        } : {
            size: config.pool.size ?? 2,
            timeout: config.pool.timeout ?? 60000
        } : undefined,
        client: {
            warning: config.client?.warning ?? "log",
            preprocessors: config.client?.preprocessors ?? []
        }
    };
}
const encoder7 = new TextEncoder();
function quotedPrintableEncode(data, encLB = false) {
    data.replaceAll("=", "=3D");
    if (!encLB) {
        data = data.replaceAll(" \r\n", "=20\r\n").replaceAll(" \n", "=20\n");
    }
    const encodedData = Array.from(data).map((ch)=>{
        const encodedChar = encoder7.encode(ch);
        if (encodedChar.length === 1) {
            const code40 = encodedChar[0];
            if (code40 >= 32 && code40 <= 126 && code40 !== 61) return ch;
            if (!encLB && (code40 === 10 || code40 === 13)) return ch;
            if (code40 === 9) return ch;
        }
        let enc = "";
        encodedChar.forEach((i86)=>{
            let c33 = i86.toString(16);
            if (c33.length === 1) c33 = "0" + c33;
            enc += `=${c33}`;
        });
        return enc;
    }).join("");
    let ret = "";
    const lines = Math.ceil(encodedData.length / 74) - 1;
    let offset = 0;
    for(let i1 = 0; i1 < lines; i1++){
        let old = encodedData.slice(i1 * 74 + offset, (i1 + 1) * 74);
        offset = 0;
        if (old.at(-1) === "=") {
            old = old.slice(0, old.length - 1);
            offset = -1;
        }
        if (old.at(-2) === "=") {
            old = old.slice(0, old.length - 2);
            offset = -2;
        }
        if (old.endsWith("\r") || old.endsWith("\n")) {
            ret += old;
        } else {
            ret += `${old}=\r\n`;
        }
    }
    ret += encodedData.slice(lines * 74);
    return ret;
}
function hasNonAsciiCharacters(str31) {
    return /[^\u0000-\u007f]/.test(str31);
}
function quotedPrintableEncodeInline(data) {
    if (hasNonAsciiCharacters(data) || data.startsWith("=?")) {
        return `=?utf-8?Q?${quotedPrintableEncode(data)}?=`;
    }
    return data;
}
function resolveAttachment(attachment) {
    if (attachment.encoding === "binary") {
        return {
            filename: attachment.filename,
            contentType: attachment.contentType,
            encoding: "base64",
            content: encode4(attachment.content)
        };
    } else {
        return attachment;
    }
}
function resolveContent({ text , html , mimeContent  }) {
    const newContent = [
        ...mimeContent ?? []
    ];
    if (text === "auto" && html) {
        text = html.replace(/<head((.|\n|\r)*?)<\/head>/g, "").replace(/<style((.|\n|\r)*?)<\/style>/g, "").replace(/<[^>]+>/g, "");
    }
    if (text) {
        newContent.push({
            mimeType: 'text/plain; charset="utf-8"',
            content: quotedPrintableEncode(text),
            transferEncoding: "quoted-printable"
        });
    }
    if (html) {
        newContent.push({
            mimeType: 'text/html; charset="utf-8"',
            content: quotedPrintableEncode(html),
            transferEncoding: "quoted-printable"
        });
    }
    return newContent;
}
function isSingleMail(mail) {
    return /^(([^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9\-]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,})|(<[^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,}>)|([^<>]+ <[^<>()\[\]\\,;:\s@"]+@[a-zA-Z0-9]+\.([a-zA-Z0-9\-]+\.)*[a-zA-Z]{2,}>))$/.test(mail);
}
function parseSingleEmail(mail) {
    if (typeof mail !== "string") {
        return {
            mail: mail.mail,
            name: quotedPrintableEncodeInline(mail.name ?? "")
        };
    }
    const mailSplitRe = /^([^<]*)<([^>]+)>\s*$/;
    const res = mailSplitRe.exec(mail);
    if (!res) {
        return {
            mail,
            name: ""
        };
    }
    const [_, name3, email] = res;
    return {
        name: quotedPrintableEncodeInline(name3.trim()),
        mail: email.trim()
    };
}
function parseMailList(list) {
    if (typeof list === "string") return [
        parseSingleEmail(list)
    ];
    if (Array.isArray(list)) return list.map((v18)=>parseSingleEmail(v18));
    if ("mail" in list) {
        return [
            {
                mail: list.mail,
                name: quotedPrintableEncodeInline(list.name ?? "")
            }
        ];
    }
    return Object.entries(list).map(([name4, mail])=>({
            name: quotedPrintableEncodeInline(name4),
            mail
        }));
}
function validateEmailList(list) {
    const ok = [];
    const bad = [];
    list.forEach((mail)=>{
        if (isSingleMail(mail.mail)) {
            ok.push(mail);
        } else {
            bad.push(mail);
        }
    });
    return {
        ok,
        bad
    };
}
function validateHeaders(headers) {
    return !(Object.keys(headers).some((v19)=>v19.includes("\n") || v19.includes("\r")) || Object.values(headers).some((v20)=>v20.includes("\n") || v20.includes("\r")));
}
function resolveSendConfig(config) {
    const { to , cc =[] , bcc =[] , from , date =new Date().toUTCString().split(",")[1].slice(1) , subject , content , mimeContent , html , inReplyTo , replyTo , references , priority , attachments , internalTag , headers ,  } = config;
    return {
        to: parseMailList(to),
        cc: parseMailList(cc),
        bcc: parseMailList(bcc),
        from: parseSingleEmail(from),
        date,
        mimeContent: resolveContent({
            mimeContent,
            html,
            text: content
        }),
        replyTo: replyTo ? parseSingleEmail(replyTo) : undefined,
        inReplyTo,
        subject: quotedPrintableEncodeInline(subject),
        attachments: attachments ? attachments.map((attachment)=>resolveAttachment(attachment)) : [],
        references,
        priority,
        internalTag,
        headers: headers ?? {}
    };
}
function validateConfig(config, client) {
    const errors1 = [];
    const warn = [];
    if (!isSingleMail(config.from.mail)) {
        errors1.push(`The specified from adress is not a valid email adress.`);
    }
    if (config.replyTo && !isSingleMail(config.replyTo.mail)) {
        errors1.push(`The specified replyTo adress is not a valid email adress.`);
    }
    const valTo = validateEmailList(config.to);
    if (valTo.bad.length > 0) {
        config.to = valTo.ok;
        valTo.bad.forEach((m19)=>{
            warn.push(`TO Email ${m19.mail} is not valid!`);
        });
    }
    const valCc = validateEmailList(config.cc);
    if (valCc.bad.length > 0) {
        config.to = valCc.ok;
        valCc.bad.forEach((m20)=>{
            warn.push(`CC Email ${m20.mail} is not valid!`);
        });
    }
    const valBcc = validateEmailList(config.bcc);
    if (valBcc.bad.length > 0) {
        config.to = valBcc.ok;
        valBcc.bad.forEach((m21)=>{
            warn.push(`BCC Email ${m21.mail} is not valid!`);
        });
    }
    if (config.to.length + config.cc.length + config.bcc.length === 0) {
        errors1.push(`No valid emails provided!`);
    }
    if (config.mimeContent.length === 0) {
        errors1.push(`No content provided!`);
    }
    if (!config.mimeContent.some((v21)=>v21.mimeType.includes("text/html") || v21.mimeType.includes("text/plain"))) {
        warn.push("You should provide at least html or text content!");
    }
    if (!validateHeaders(config.headers)) {
        errors1.push(`Headers are not allowed to include linebreaks!`);
    }
    if (client.client.warning === "log" && warn.length > 0) {
        console.warn(warn.join("\n"));
    }
    if (client.client.warning === "error") {
        errors1.push(...warn);
    }
    if (errors1.length > 0) {
        throw new Error(errors1.join("\n"));
    }
    return config;
}
class SMTPHandler {
    #internalClient;
    #clientConfig;
    constructor(config){
        const resolvedConfig = resolveClientOptions(config);
        resolvedConfig.client.preprocessors.push(validateConfig);
        this.#clientConfig = resolvedConfig;
        if (resolvedConfig.debug.log) {
            console.log("used resolved config");
            console.log(".debug");
            console.table(resolvedConfig.debug);
            console.log(".connection");
            console.table({
                ...resolvedConfig.connection,
                ...resolvedConfig.connection.auth ? {
                    auth: JSON.stringify(resolvedConfig.connection.auth)
                } : {}
            });
            console.log(".pool");
            console.table(resolvedConfig.pool);
        }
        const Client1 = resolvedConfig.pool ? resolvedConfig.pool.size > 1 ? SMTPWorkerPool : SMTPWorker : SMTPClient;
        this.#internalClient = new Client1(resolvedConfig);
    }
    send(config) {
        let resolvedConfig = resolveSendConfig(config);
        for(let i87 = 0; i87 < this.#clientConfig.client.preprocessors.length; i87++){
            const cb = this.#clientConfig.client.preprocessors[i87];
            resolvedConfig = cb(resolvedConfig, this.#clientConfig);
        }
        return this.#internalClient.send(resolvedConfig);
    }
    close() {
        return this.#internalClient.close();
    }
}
const args = mod5.parse(Deno.args);
function getArg(name5) {
    return args[name5] || args[name5.toLowerCase().replaceAll('_', '-')] || Deno.env.get("EDRYS_" + name5);
}
const address = getArg("ADDRESS") ?? "localhost:8000";
const secret = getArg("SECRET") ?? "secret";
if (secret == 'secret') mod.warning("For production, please specify a unique --secret to generate a secret private key. Currently using default.");
const totp_window = parseInt(getArg("TOTP_WINDOW"));
const serve_path = getArg("SERVE_PATH") ?? `./static`;
const config_class_creators = (getArg("CONFIG_CLASS_CREATORS_CSV") ?? "*").split(",");
getArg("HTTPS_CERT_FILE") ?? undefined;
getArg("HTTPS_KEY_FILE") ?? undefined;
const log_level = getArg("LOG_LEVEL") ?? "DEBUG";
const smtp_tls = getArg("SMTP_TLS") == "true";
const smtp_hostname = getArg("SMTP_HOST") ?? "";
const smtp_port = Number(getArg("SMTP_PORT") ?? "0");
const smtp_username = getArg("SMTP_USERNAME") ?? "";
const smtp_password = getArg("SMTP_PASSWORD") ?? "";
const smtp_from = getArg("SMTP_FROM") ?? "";
const data_engine = getArg("DATA_ENGINE") ?? "file";
const data_file_path = getArg("DATA_FILE_PATH") ?? ".edrys";
const data_s3_endpoint = getArg("DATA_S3_ENDPOINT") ?? "";
const data_s3_port = Number(getArg("DATA_S3_PORT") ?? "443");
const data_s3_use_ssl = getArg("DATA_S3_USE_SSL") == "true";
const data_s3_region = getArg("DATA_S3_REGION") ?? "";
const data_s3_access_key = getArg("DATA_S3_ACCESS_KEY") ?? "";
const data_s3_secret_key = getArg("DATA_S3_SECRET_KEY") ?? "";
const data_s3_bucket = getArg("DATA_S3_BUCKET") ?? "";
const frontend_address = getArg("FRONTEND_ADDRESS") ?? address;
const config_default_modules = JSON.parse(getArg("CONFIG_DEFAULT_MODULES_JSON") ?? "null") ?? [
    {
        url: "https://edrys-org.github.io/module-reference/",
        config: '',
        studentConfig: '',
        teacherConfig: '',
        stationConfig: '',
        width: "full",
        height: "tall"
    }, 
];
const jwt_lifetime_days = Number(getArg("JWT_LIFETIME_DAYS") ?? "30");
const jwt_keys_path = getArg("JWT_KEYS_PATH") ?? false;
const limit_msg_len = Number(getArg("LIMIT_MSG_LEN") ?? '10000');
const limit_state_len = Number(getArg("LIMIT_STATE_LEN") ?? '999000');
let ready = false;
let s3c;
const inMemoryStorage = {};
if (data_engine == "s3") {
    if (data_s3_endpoint == "" || data_s3_port == 0 || data_s3_region == "" || data_s3_access_key == "" || data_s3_secret_key == "" || data_s3_bucket == "") {
        throw new Error("Invalid Data S3 config");
    }
    s3c = new mod16.S3Client({
        endPoint: data_s3_endpoint,
        port: data_s3_port,
        useSSL: data_s3_use_ssl,
        region: data_s3_region,
        accessKey: data_s3_access_key,
        secretKey: data_s3_secret_key,
        bucket: data_s3_bucket,
        pathStyle: true
    });
} else if (data_engine == "file") {
    await mod4.ensureDir(data_file_path);
}
ready = true;
async function read(folder, file) {
    const path78 = `${data_file_path}/${folder}/${file}.json`;
    if (data_engine == "s3") {
        const res = await s3c.getObject(path78);
        if (res.status == 200) {
            return res.json();
        } else {
            throw new Error(`S3 Error (${res.status})`);
        }
    } else if (data_engine == "file") {
        await mod4.ensureDir(`${data_file_path}/${folder}`);
        return JSON.parse(await Deno.readTextFile(path78));
    } else {
        if (path78 in inMemoryStorage) return JSON.parse(inMemoryStorage[path78]);
        else throw new Error(`Not found: ${path78}`);
    }
}
async function write(folder, file, value75) {
    const text = JSON.stringify(value75);
    const path79 = `${data_file_path}/${folder}/${file}.json`;
    if (data_engine == "s3") {
        if (text == undefined) {
            return await s3c.deleteObject(path79);
        }
        await s3c.putObject(path79, text);
    } else if (data_engine == "file") {
        await mod4.ensureDir(`${data_file_path}/${folder}`);
        if (text == undefined) {
            return await Deno.remove(path79);
        }
        await Deno.writeTextFile(path79, text);
    } else {
        if (text == undefined) {
            delete inMemoryStorage[path79];
        } else {
            inMemoryStorage[path79] = text;
        }
    }
}
function setToValue(obj, pathArr, value76) {
    let i88 = 0;
    for(i88 = 0; i88 < pathArr.length - 1; i88++){
        obj = obj[pathArr[i88]];
        if (!obj[pathArr[i88 + 1]]) {
            obj[pathArr[i88 + 1]] = {};
        }
    }
    obj[pathArr[i88]] = value76;
    if (value76 === null) delete obj[pathArr[i88]];
}
var RoleName;
(function(RoleName1) {
    RoleName1["Student"] = "student";
    RoleName1["Teacher"] = "teacher";
})(RoleName || (RoleName = {}));
var ReservedRoomNames;
(function(ReservedRoomNames1) {
    ReservedRoomNames1["Lobby"] = "Lobby";
    ReservedRoomNames1["TeachersLounge"] = "Teacher's Lounge";
    ReservedRoomNames1["StationX"] = "Station *";
})(ReservedRoomNames || (ReservedRoomNames = {}));
function can_create_class(e70) {
    return config_class_creators.includes("*") || config_class_creators.includes(`*@${e70.split("@")[1]}`) || config_class_creators.filter((p39)=>p39.includes("/")).some((p40)=>new RegExp(p40, "g").test(e70)) || config_class_creators.includes(e70);
}
function validate_class(c34) {
    return typeof c34.id == "string" && typeof c34.dateCreated == "number" && validate_email(c34.createdBy) && validate_name(c34.name) && typeof c34.members == "object" && Object.entries(c34.members).every((e71)=>Object.values(RoleName).includes(e71[0])) && Object.entries(c34.members).every((e72)=>e72[1].every((v22, _i, _a)=>validate_email(v22))) && Array.isArray(c34.modules) && c34.modules.every((v23, _i, _a)=>validate_module(v23));
}
function validate_user(u15) {
    return validate_email(u15.email) && typeof u15.dateCreated == "number" && validate_human_name(u15.displayName) && u15.memberships.every((m22)=>validate_url(m22.instance) && typeof m22.class_id == "string" && validate_name(m22.class_name) && Object.values(RoleName).includes(m22.role));
}
function validate_email(e73) {
    return /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(e73);
}
function validate_name(n81) {
    return typeof n81 == "string" && /^([A-Za-z0-9 ]{1,100})$/.test(n81);
}
function validate_human_name(n82) {
    return typeof n82 == "string" && /^[^§¡@£%§¶^&*€#±!_+¢•ªº«\\/<>?$:;|=.,]{1,50}$/.test(n82);
}
function validate_url(u16) {
    try {
        new URL(u16);
        return true;
    } catch (_error) {
        return false;
    }
}
function validate_module(m23) {
    return validate_url(m23.url) && [
        "full",
        "half",
        "third"
    ].includes(m23.width) && [
        "tall",
        "medium",
        "short"
    ].includes(m23.height);
}
function validate_live_state(s32) {
    return JSON.stringify(s32).length < limit_state_len;
}
function validate_message(message, role) {
    return message.subject.length < 1000 && (message.body.length < limit_msg_len || role == RoleName.Teacher) && validate_url(message.module);
}
async function get_class_and_role(class_id, user_id) {
    try {
        if (!class_id) {
            return undefined;
        }
        const class_ = await read("classes", class_id);
        if (!class_) {
            return undefined;
        }
        if (class_.members.student?.includes(user_id)) {
            return [
                class_,
                RoleName.Student
            ];
        } else if (class_.members.teacher?.includes(user_id)) {
            return [
                class_,
                RoleName.Teacher
            ];
        } else {
            return undefined;
        }
    } catch (_error) {
        return undefined;
    }
}
let smtpClient;
let jwt_public_key;
let jwt_private_key;
if (smtp_hostname == "" || smtp_port == 0 || smtp_username == "" || smtp_password == "" || smtp_from == "") {
    smtpClient = {
        send: async function(params) {
            await new Promise((resolve9)=>setTimeout(resolve9, 1000));
            console.log("Email sent", params);
        }
    };
} else {
    smtpClient = new SMTPHandler({
        connection: {
            hostname: smtp_hostname,
            port: smtp_port,
            tls: smtp_tls,
            auth: {
                username: smtp_username,
                password: smtp_password
            }
        }
    });
}
if (jwt_keys_path) {
    jwt_private_key = await crypto.subtle.importKey("pkcs8", mod1.decode(await Deno.readTextFile(`${jwt_keys_path}/jwt_private_key`)), {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-512"
    }, true, [
        "sign"
    ]);
    jwt_public_key = await crypto.subtle.importKey("spki", mod1.decode(await Deno.readTextFile(`${jwt_keys_path}/jwt_public_key`)), {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-512"
    }, true, [
        "verify"
    ]);
} else {
    jwt_private_key = await crypto.subtle.importKey("raw", new TextEncoder().encode(secret), {
        name: "HMAC",
        hash: "SHA-512"
    }, true, [
        "sign",
        "verify"
    ]);
}
async function sendToken(email) {
    ensureEmailValid(email);
    const token = getTotp(email).generate();
    await smtpClient.send({
        from: smtp_from,
        to: email,
        subject: "Your Edrys secret code",
        content: `Use this secret code in the Edrys app: ${token}`,
        html: `Use this secret code in the Edrys app: <em>${token}</em>`
    });
}
async function verifyToken(token, email) {
    ensureEmailValid(email);
    ensureTokenValid(token, email);
    return [
        await ensureUserExists(email),
        await mod14.create({
            alg: jwt_public_key ? "RS512" : "HS512",
            typ: "JWT"
        }, {
            sub: normaliseEmail(email),
            iat: new Date().getTime(),
            exp: new Date().setDate(new Date().getDate() + jwt_lifetime_days)
        }, jwt_private_key), 
    ];
}
async function ensureUserExists(email) {
    if (!ready) {
        throw new Error(`Error ensuring user exists, data module not ready (${email})`);
    }
    try {
        await read("users", email);
        return false;
    } catch (_error) {
        let displayName = email.trim().split("@")[0].replaceAll(/[^A-Za-z ]+/g, " ").slice(0, 99);
        displayName = displayName.length <= 1 ? "New User" : displayName;
        await write("users", normaliseEmail(email), {
            email: normaliseEmail(email),
            displayName: displayName,
            dateCreated: new Date().getTime(),
            memberships: []
        });
        return true;
    }
}
function ensureTokenValid(token, email) {
    const res = getTotp(email).validate({
        token: token,
        window: totp_window >= 2 ? totp_window : 11
    });
    if (res == null) {
        throw new Error(`Invalid token ${email} ${token}`);
    }
}
function getTotp(email) {
    return new mod17.TOTP({
        issuer: "App",
        label: "EmailToken",
        algorithm: "SHA3-256",
        digits: 6,
        period: 30,
        secret: mod17.Secret.fromUTF8(secret + email)
    });
}
function ensureEmailValid(email) {
    if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) {
        throw new Error(`Invalid email ${email}`);
    }
}
async function ensureJwtValid(jwt) {
    try {
        return await mod14.verify(jwt, jwt_public_key ?? jwt_private_key);
    } catch (_error) {
        throw new Error(`JWT signiture validation error ${jwt}`);
    }
}
function normaliseEmail(email) {
    return email.trim().toLowerCase();
}
const middleware = async (ctx, next)=>{
    try {
        const jwt = ctx.request.headers?.get("Authorization")?.replace("Bearer ", "") || mod12.helpers.getQuery(ctx)["jwt"];
        if (!jwt) throw new Error("Unauthorized");
        const jwt_verified = await ensureJwtValid(jwt);
        ctx.state.user = jwt_verified.sub;
    } catch (_error) {}
    await next();
};
const router = new mod12.Router().get("/jwtPublicKey", async (ctx)=>{
    ctx.response.body = mod1.encode(await crypto.subtle.exportKey("spki", jwt_public_key));
}).get("/sendToken", async (ctx)=>{
    await sendToken(mod12.helpers.getQuery(ctx)["email"]);
    ctx.response.body = "Sent";
}).get("/verifyToken", async (ctx)=>{
    try {
        const [isNewbie, jwt] = await verifyToken(mod12.helpers.getQuery(ctx)["token"], mod12.helpers.getQuery(ctx)["email"]);
        ctx.response.body = [
            isNewbie,
            jwt
        ];
    } catch (error16) {
        console.log(error16);
        ctx.response.status = 401;
    }
});
const classes = {};
const router1 = new mod12.Router().get("/readUser", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    ctx.response.body = await read("users", ctx.state.user);
    ctx.response.status = 200;
}).get("/updateUser", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const user_new = JSON.parse(mod12.helpers.getQuery(ctx)["user"]);
    if (!user_new || ctx.state.user != user_new.email || !validate_user(user_new)) {
        ctx.response.status = 400;
        return;
    } else {
        const user_old = await read("users", ctx.state.user);
        user_new.dateCreated = user_old.dateCreated;
        const user = {
            ...user_old,
            ...user_new
        };
        await write("users", ctx.state.user, user);
        ctx.response.body = user;
        ctx.response.status = 200;
    }
}).get("/canCreateClass", (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    ctx.response.body = can_create_class(ctx.state.user);
    ctx.response.status = 200;
}).get("/readClass/:class_id", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    const res = await get_class_and_role(class_id, ctx.state.user);
    if (res == undefined) {
        ctx.response.status = 404;
        return;
    }
    const [class_, role] = res;
    if (role == RoleName.Student) {
        ctx.response.body = {
            id: class_.id,
            dateCreated: class_.dateCreated,
            createdBy: class_.createdBy,
            name: class_.name,
            modules: class_.modules.map((m24)=>({
                    url: m24.url,
                    config: m24.config,
                    studentConfig: m24.studentConfig,
                    width: m24.width,
                    height: m24.height
                })),
            members: {
                [RoleName.Student]: [
                    ctx.state.user
                ]
            }
        };
        ctx.response.status = 200;
    } else if (role == RoleName.Teacher) {
        ctx.response.body = class_;
        ctx.response.status = 200;
    } else {
        ctx.response.status = 404;
    }
}).get("/createClass", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    if (can_create_class(ctx.state.user)) {
        const new_class_id = nanoid();
        const new_class = {
            id: new_class_id,
            createdBy: ctx.state.user,
            dateCreated: new Date().getTime(),
            name: "My New Class",
            members: {
                "teacher": [
                    ctx.state.user
                ],
                "student": []
            },
            modules: config_default_modules
        };
        await write("classes", new_class_id, new_class);
        ctx.response.body = new_class_id;
        ctx.response.status = 200;
    }
}).get("/updateClass/:class_id", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    const class_new = JSON.parse(mod12.helpers.getQuery(ctx)["class"]);
    if (!class_new || class_id != class_new.id || !validate_class(class_new)) {
        ctx.response.status = 400;
        return;
    }
    const res = await get_class_and_role(class_id, ctx.state.user);
    if (typeof res == "undefined") {
        ctx.response.status = 404;
        return;
    }
    const [class_old, role] = res;
    class_new.dateCreated = class_old.dateCreated;
    class_new.createdBy = class_old.createdBy;
    class_new.members.teacher.push(ctx.state.user);
    class_new.members.teacher = [
        ...new Set(class_new.members.teacher)
    ];
    class_new.members.student = [
        ...new Set(class_new.members.student)
    ];
    if (role == RoleName.Student) {
        ctx.response.status = 404;
    } else if (role == RoleName.Teacher) {
        const class_ = {
            ...class_old,
            ...class_new
        };
        await write("classes", class_id, class_);
        for (const user_id of Object.keys(classes[class_id]?.users || [])){
            if (!class_new.members.student.includes(user_id) && !class_new.members.teacher.includes(user_id)) {
                delete classes[class_id]?.users[user_id];
            }
        }
        await onClassUpdated(class_id);
        ctx.response.body = class_;
        ctx.response.status = 200;
    } else {
        ctx.response.status = 404;
    }
}).get("/deleteClass/:class_id", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    const res = await get_class_and_role(class_id, ctx.state.user);
    if (typeof res == "undefined") {
        ctx.response.status = 404;
        return;
    }
    const [_, role] = res;
    if (role == RoleName.Teacher) {
        await Object.values(classes[class_id]?.users || []).flatMap((u17)=>u17.connections).forEach(async (c35)=>{
            await c35.target.close();
        });
        delete classes[class_id];
        await write("classes", class_id, undefined);
        ctx.response.body = "OK";
        ctx.response.status = 200;
    } else {
        ctx.response.status = 404;
    }
}).get("/readLiveClass/:class_id", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    const display_name = mod12.helpers.getQuery(ctx)["displayName"];
    const is_station = mod12.helpers.getQuery(ctx)["isStation"] == "true";
    const username = is_station ? display_name : ctx.state.user;
    const res = await get_class_and_role(class_id, ctx.state.user);
    if (typeof res == "undefined" || !validate_name(display_name) || is_station && display_name.includes("@")) {
        ctx.response.status = 404;
        return;
    }
    const target = ctx.sendEvents();
    const [_, role] = res;
    let live_class1 = classes[class_id];
    if (role != RoleName.Teacher && is_station) {
        ctx.response.status = 401;
        return;
    }
    if (!live_class1) {
        classes[class_id] = {
            autoAssign: undefined,
            users: {},
            rooms: {
                "Lobby": {
                    studentPublicState: "",
                    teacherPublicState: "",
                    teacherPrivateState: ""
                },
                "Teacher's Lounge": {
                    studentPublicState: "",
                    teacherPublicState: "",
                    teacherPrivateState: ""
                }
            }
        };
        live_class1 = classes[class_id];
    }
    let connection_id = "";
    if (live_class1.users[username]) {
        connection_id = nanoid();
        live_class1.users[username].connections ??= [];
        live_class1.users[username].connections.push({
            id: connection_id,
            target: target
        });
    } else {
        live_class1.users[username] = {
            displayName: display_name,
            room: is_station ? `Station ${display_name}` : ReservedRoomNames.Lobby,
            role: role,
            dateJoined: new Date().getTime(),
            handRaised: false,
            connections: [
                {
                    id: connection_id,
                    target: target
                }
            ]
        };
        if (is_station) {
            live_class1.rooms[`Station ${display_name}`] = {
                studentPublicState: "",
                teacherPublicState: "",
                teacherPrivateState: "",
                userLinked: username
            };
        }
    }
    await onClassUpdated(class_id);
    if (!classes[class_id]?.users[username] || !classes[class_id]?.users[username].connections.length) {
        target.close();
    }
    const kaInterval = setInterval(()=>{
        target.dispatchComment("ka");
    }, 1000);
    target.addEventListener("close", async (_e)=>{
        clearInterval(kaInterval);
        const live_class = classes[class_id];
        if (!live_class) {
            return;
        }
        mod.debug([
            "Disconnection",
            username
        ]);
        const all_connections = Object.values(live_class.users).flatMap((u18)=>u18.connections);
        if (all_connections.length == 1) {
            delete classes[class_id];
        } else if (!live_class.users[username]) {
            delete classes[class_id]?.users[username];
        } else if (live_class.users[username]?.connections?.length == 1) {
            delete classes[class_id]?.users[username];
            Object.entries(live_class.rooms).filter((r56)=>r56[1].userLinked == username).forEach((r57)=>{
                delete classes[class_id]?.rooms[r57[0]];
            });
        } else {
            live_class.users[username].connections = live_class.users[username].connections?.filter((c36)=>c36.id != connection_id);
            live_class.users[username].connections ??= [];
        }
        await onClassUpdated(class_id);
    });
}).get("/updateLiveClass/:class_id", async (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    if (!classes[class_id]) {
        ctx.response.status = 404;
        return;
    }
    const res = await get_class_and_role(class_id, ctx.state.user);
    if (typeof res == "undefined") {
        ctx.response.status = 404;
        return;
    }
    const [_, role] = res;
    const live_class = classes[class_id];
    if (!live_class) {
        ctx.response.status = 400;
        return;
    }
    const stationId = mod12.helpers.getQuery(ctx)["stationId"];
    const username = stationId || ctx.state.user;
    if (role != RoleName.Teacher && stationId) {
        ctx.response.status = 401;
        return;
    }
    const user = live_class.users[username];
    const update_str = mod12.helpers.getQuery(ctx)["update"];
    if (update_str.length > 100000) {
        ctx.response.status = 401;
        return;
    }
    const update = JSON.parse(update_str);
    const update_path_str = JSON.stringify(update.path);
    if (role == RoleName.Student) {
        const valid_student_updates = [
            [
                JSON.stringify([
                    "rooms",
                    user.room,
                    "studentPublicState"
                ]),
                validate_live_state, 
            ],
            [
                JSON.stringify([
                    "users",
                    username,
                    "displayName"
                ]),
                validate_human_name, 
            ],
            [
                JSON.stringify([
                    "users",
                    username,
                    "handRaised"
                ]),
                (v24)=>v24 === true || v24 === false, 
            ], 
        ];
        if (!valid_student_updates.some((u19)=>u19[0] == update_path_str && u19[1](update.value))) {
            ctx.response.status = 401;
            return;
        }
    } else if (role == RoleName.Teacher) {
        if (update.path.length == 3 && update.path[0] == 'users' && update.path[2] == 'room') {
            const dateJoiendPath = [
                ...update.path
            ];
            dateJoiendPath[2] = 'dateJoined';
            setToValue(classes[class_id], dateJoiendPath, new Date().getTime());
        }
    }
    setToValue(classes[class_id], update.path, update.value);
    await onClassUpdated(class_id);
    ctx.response.status = 200;
}).get("/sendMessage/:class_id", (ctx)=>{
    if (!ctx.state.user) ctx.throw(401);
    const class_id = ctx?.params?.class_id;
    const message = JSON.parse(mod12.helpers.getQuery(ctx)["message"]);
    const user_role = classes[class_id]?.users[ctx.state.user]?.role || RoleName.Student;
    if (!class_id || !validate_message(message, user_role) || validate_email(message.from) && message.from != ctx.state.user || !validate_email(message.from) && user_role == 'student') {
        ctx.response.status = 400;
        return;
    }
    if (sendMessage(class_id, message)) {
        ctx.response.status = 200;
    } else {
        ctx.response.status = 401;
    }
});
async function onClassUpdated(class_id) {
    const live_class = classes[class_id];
    if (!live_class) {
        return false;
    }
    mod.debug([
        "Class Update",
        class_id,
        live_class
    ]);
    for (const user_id of Object.keys(classes[class_id]?.users || [])){
        const user = live_class.users[user_id];
        const connections = user?.connections;
        if (!user || !connections) {
            continue;
        }
        let res = undefined;
        if (user.role == RoleName.Student) {
            res = {
                rooms: {
                    [user.room]: {
                        ...live_class.rooms[user.room],
                        teacherPrivateState: undefined
                    }
                },
                users: {
                    [user_id]: {
                        ...user
                    }
                }
            };
        } else if (user.role == RoleName.Teacher) {
            res = live_class;
        }
        connections.forEach((c37)=>c37.target.dispatchEvent(new mod12.ServerSentEvent("update", res)));
    }
    return true;
}
function sendMessage(class_id, message) {
    const live_class = classes[class_id];
    if (!live_class) return false;
    mod.debug([
        "Message to be sent",
        class_id,
        message
    ]);
    const user_from = live_class.users[message.from];
    if (!user_from) return true;
    const user_conns_in_room = Object.entries(classes[class_id]?.users || []).filter((u20)=>u20[1].room == user_from.room).flatMap((u21)=>u21[1].connections);
    for (const user_conn of user_conns_in_room){
        user_conn.target.dispatchEvent(new mod12.ServerSentEvent("message", {
            ...message,
            date: new Date().getTime()
        }));
    }
    return true;
}
const app = new mod12.Application();
if (frontend_address) {
    app.use((ctx, next)=>{
        ctx.response.headers.set("Access-Control-Allow-Origin", frontend_address);
        ctx.response.headers.set("Access-Control-Allow-Credential", "true");
        ctx.response.headers.set("Access-Control-Allow-Methods", "GET,HEAD,OPTIONS");
        ctx.response.headers.set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization");
        return next();
    });
}
app.use(async (ctx, next)=>{
    await next();
    mod.info(`${new Date().toISOString()} ${ctx.request.method} ${ctx.request.url}`);
});
await mod.setup({
    handlers: {
        console: new mod.handlers.ConsoleHandler("DEBUG", {
            formatter: "{levelName} {datetime} {msg}"
        })
    },
    loggers: {
        default: {
            level: log_level,
            handlers: [
                "console"
            ]
        }
    }
});
const ping_router = new mod12.Router();
ping_router.get("/ping", (ctx)=>{
    ctx.response.body = address;
});
app.use(ping_router.routes());
app.use(ping_router.allowedMethods());
const auth_router = new mod12.Router().use("/auth", router.routes(), router.allowedMethods());
app.use(auth_router.routes());
app.use(auth_router.allowedMethods());
app.use(middleware);
const data_router = new mod12.Router().use("/data", router1.routes(), router1.allowedMethods());
app.use(data_router.routes());
app.use(data_router.allowedMethods());
app.use(async (context4, next)=>{
    try {
        await context4.send({
            root: serve_path,
            index: "index.html"
        });
    } catch  {
        next();
    }
});
const hostname = address.split(":")[0];
const port = address.split(":")[1];
mod.info(`Listening on ${hostname}:${port}`);
await app.listen({
    hostname: hostname,
    port: Number(port),
    alpnProtocols: [
        "h2"
    ]
});
